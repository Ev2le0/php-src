/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  |          Xinchen Hui <xinchen.h@zend.com>                            |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,      r14
 |.define IP,      r15
 |.define IPl,     r15d
 |.define CARG1,   rdi       // x64/POSIX C call arguments.
 |.define CARG2,   rsi
 |.define CARG3,   rdx
 |.define CARG4,   rcx
 |.define CARG5,   r8
 |.define CARG6,   r9
 |.define CARG1d,  edi
 |.define CARG2d,  esi
 |.define CARG3d,  edx
 |.define CARG4d,  ecx
 |.define CARG5d,  r8d
 |.define CARG6d,  r9d
 |.define FCARG1a, CARG1    // Simulate x86 fastcall.
 |.define FCARG2a, CARG2
 |.define FCARG1d, CARG1d
 |.define FCARG2d, CARG2d
 |.define SPAD,    8
 |.define SSE,     1
|.else
 |.define FP,      esi
 |.define IP,      edi
 |.define IPl,     edi
 |.define FCARG1a, ecx       // x86 fastcall arguments.
 |.define FCARG2a, edx
 |.define FCARG1d, ecx
 |.define FCARG2d, edx
 |.define SPAD,    12
 |.define SSE,     1
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_opline, IP

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code, cold_code

|.macro LOAD_ADDR, reg, addr
|.if X64
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.else
|	mov reg, addr
|.endif
|.endmacro

|.macro EXT_CALL, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	call qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	call tmp_reg
||}
|.else
|	call dword &func
|.endif
|.endmacro

|.macro EXT_JMP, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	jmp qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	jmp tmp_reg
||}
|.else
|	jmp dword &func
|.endif
|.endmacro

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0x7fffffff)

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OT_FUNC

|.macro LOAD_ZVAL_ADDR, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov reg, aword EX->literals
|   add reg, op.constant
|   .else
|   mov reg, op.zv
|   .endif
||} else {
|   lea reg, qword [FP + op.var]
||}
|.endmacro

|.macro PUSH_ZVAL_ADDR, op_type, op, tmp_reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov reg, aword EX->literals
|   add reg, op.constant
|	push reg
|   .else
|   push op.zv
|   .endif
||} else {
|   lea tmp_reg, qword [FP + op.var]
|	push tmp_reg
||}
|.endmacro

|.macro FP_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins qword [op.zv]
|   .endif
||} else {
|   fp_ins qword [FP + op.var]
||}
|.endmacro

|.macro FP_LOAD, op_type, op
|	FP_OP fld, op_type, op
|.endmacro

|.macro FP_MATH, opcode, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
|         FP_OP fadd, op_type, op
||        break;
||    case ZEND_SUB:
|         FP_OP fsub, op_type, op
||        break;
||    case ZEND_MUL:
|         FP_OP fmul, op_type, op
||        break;
||    case ZEND_DIV:
|         FP_OP fdiv, op_type, op
||        break;
||}
|.endmacro

|.macro FP_STORE, op
|    fstp qword [FP + op.var]
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro

|.macro SSE_OP, sse_ins, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   sse_ins reg, qword [r0 + op.constant]
|   .else
|   sse_ins reg, qword [op.zv]
|   .endif
||} else {
|   sse_ins reg, qword [FP + op.var]
||}
|.endmacro

|.macro SSE_LOAD_LONG, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   cvtsi2sd reg, qword [r0 + op.constant]
|   .else
|   cvtsi2sd reg, dword [op.zv]
|   .endif
||} else {
|   .if X64
|   cvtsi2sd reg, qword [FP + op.var]
|   .else
|   cvtsi2sd reg, dword [FP + op.var]
|   .endif
||}
|.endmacro

|.macro SSE_LOAD, op_type, op, reg
|	SSE_OP movsd, op_type, op, reg
|.endmacro

|.macro SSE_MATH, opcode, op_type, op, reg
||switch (opcode) {
||    case ZEND_ADD:
|         SSE_OP addsd, op_type, op, reg
||        break;
||    case ZEND_SUB:
|         SSE_OP subsd, op_type, op, reg
||        break;
||    case ZEND_MUL:
|         SSE_OP mulsd, op_type, op, reg
||        break;
||    case ZEND_DIV:
|         SSE_OP divsd, op_type, op, reg
||        break;
||}
|.endmacro

|.macro SSE_MATH2, opcode, reg1, reg2
||switch (opcode) {
||    case ZEND_ADD:
|         addsd reg2, reg1
||        break;
||    case ZEND_SUB:
|         subsd reg2, reg1
||        break;
||    case ZEND_MUL:
|         mulsd reg2, reg1
||        break;
||    case ZEND_DIV:
|         divsd reg2, reg1
||        break;
||}
|.endmacro

|.macro SSE_STORE, op, reg
|    movsd qword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro

|.macro LONG_OP, long_ins, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   	long_ins reg, r1
||  } else {
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   long_ins reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_LOAD, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  } else {
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   mov reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_MATH, opcode, op_type, op, reg
||switch (opcode) {
||    case ZEND_ADD:
|         LONG_OP add, op_type, op, reg
||        break;
||    case ZEND_SUB:
|         LONG_OP sub, op_type, op, reg
||        break;
||    case ZEND_MUL:
|         LONG_OP imul, op_type, op, reg
||        break;
||    case ZEND_DIV:
|         idiv aword [FP + op.var]
||        break;
||}
|.endmacro

|.macro LONG_MATH2, opcode, reg1, reg2
||switch (opcode) {
||    case ZEND_ADD:
|         add reg2, reg1
||        break;
||    case ZEND_SUB:
|         sub reg2, reg1
||        break;
||    case ZEND_MUL:
|         imul reg2, reg1
||        break;
||}
|.endmacro

|.macro LONGF_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins dword [op.zv]
|   .endif
||} else {
|   fp_ins aword [FP + op.var]
||}
|.endmacro

|.macro LONGF_LOAD, op_type, op
|	LONGF_OP fild, op_type, op
|.endmacro

|.macro LONGF_MATH, opcode
||switch (opcode) {
||    case ZEND_ADD:
|         fadd st1
||        break;
||    case ZEND_SUB:
|         fsub st1
||        break;
||    case ZEND_MUL:
|         fmul st1
||        break;
||    case ZEND_DIV:
|         fdiv st1
||        break;
||}
|.endmacro

|.macro LONG_STORE, op, reg
|    mov aword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_LONG
|.endmacro

|.macro ZVAL_COPY_CONST, dst_base, dst_offset, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst_base + dst_offset], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			mov qword [dst_base + dst_offset], tmp_reg
||		} else {
|			mov qword [dst_base + dst_offset], Z_LVAL_P(zv)
||		}
|.else
|		mov dword [dst_base + dst_offset], Z_LVAL_P(zv)
|.endif
||	}
||}
||if ((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) {
|	mov dword [dst_base + dst_offset + 8], Z_TYPE_INFO_P(zv);
||}
|.endmacro

|.macro ZVAL_COPY_VALUE, dst_base, dst_offset, src_base, src_offset, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		mov tmp_reg2, aword [src_base + src_offset]
| 		mov aword [dst_base + dst_offset], tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src_base + src_offset]
|		movsd qword [dst_base + dst_offset], xmm0
|.else
|		fld qword [src_base + src_offset]
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
|		mov tmp_reg2, aword [src_base + src_offset]
|		mov aword [dst_base + dst_offset], tmp_reg2
|.else
|		mov tmp_reg2, dword [src_base + src_offset]
|		mov tmp_reg1, dword [src_base + src_offset + 4]
|		mov dword [dst_base + dst_offset], tmp_reg2
|		mov dword [dst_base + dst_offset + 4], tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	mov dword [dst_base + dst_offset + 8], type
||} else {
|	mov tmp_reg1d, dword [src_base + src_offset + 8]
|	mov dword [dst_base + dst_offset + 8], tmp_reg1d
||}
|.endmacro

|.macro ZVAL_COPY_VALUE_REG, dst_base, dst_offset, src_reg, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		mov tmp_reg2, aword [src_reg]
| 		mov aword [dst_base + dst_offset], tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src_reg]
|		movsd qword [dst_base + dst_offset], xmm0
|.else
|		fld qword [src_reg]
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
|		mov tmp_reg2, aword [src_reg]
|		mov aword [dst_base + dst_offset], tmp_reg2
|.else
|		mov tmp_reg2, dword [src_reg]
|		mov tmp_reg1, dword [src_reg + 4]
|		mov dword [dst_base + dst_offset], tmp_reg2
|		mov dword [dst_base + dst_offset + 4], tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	mov dword [dst_base + dst_offset + 8], type
||} else {
|	mov tmp_reg1d, dword [src_reg + 8]
|	mov dword [dst_base + dst_offset + 8], tmp_reg1d
||}
|.endmacro

|.macro ADDREF_CONST, zv, tmp_reg
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			inc dword [tmp_reg]
||		} else {
|			inc dword [Z_LVAL_P(zv)]
||		}
|.else
|		inc dword [Z_LVAL_P(zv)]
|.endif
|.endmacro

|.macro TRY_ADDREF, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		and type_flags_reg, IS_TYPE_REFCOUNTED
|		je >1
||	}
|	inc	dword [value_ptr_reg]
|1:
||}
|.endmacro

|.macro ZVAL_DEREF, reg, info
||	if (info & MAY_BE_REF) {
|		cmp byte [reg + 8], IS_REFERENCE
|		jne >1
|		mov reg, [reg]
|		add reg, 8
|1:
||	}
|.endmacro

|.macro JNE_SLOW
|	jne >9
||	has_slow = 1;
|.endmacro

const zend_op *valid_opline;
static uint32_t valid_opline_offset;
#endif

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static inline zend_bool is_signed(double d)
{
    return (((unsigned char*)&d)[sizeof(double)-1] & 0x80) != 0;
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|.else
	|	push 0
	|.endif
	|	EXT_CALL zend_timeout, r0
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		|	mov CARG1, FP
		|.else
		|	push FP
		|.endif
		|	EXT_CALL zend_interrupt_function, r0
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	valid_opline = NULL;
	valid_opline_offset = 0;
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_set_valid_ip(dasm_State **Dst)
{
	if (valid_opline || valid_opline_offset) {
		if (!valid_opline) {
			|	add IP, sizeof(zend_op) * valid_opline_offset
		} else {
			const zend_op *target_opline = valid_opline + valid_opline_offset;

			valid_opline = NULL;
			|	LOAD_ADDR IP, target_opline
		}
		valid_opline_offset = 0;
	}
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	if (zend_interrupt_function) {
		if (!zend_jit_set_valid_ip(Dst)) {
			return 0;
		}
	}
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline, int may_throw)
{
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	EXT_CALL opline->handler, r0
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	add r4, SPAD // stack alignment
	|	EXT_JMP opline->handler, r0
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst)
{
	valid_opline_offset++;
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	valid_opline = target_opline;
	valid_opline_offset = 0;
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jnz =>target_label

	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	jz =>next_label
	|	cmp IPl, target_opline
	|	jz =>target_label

	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jz >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	if (!zend_jit_handler(Dst, opline, 1)) {
		return 0;
	}
	if (opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL) {
		zend_class_entry *ce = NULL;
#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC
		if (ssa->ops && ssa->var_info) {
			zend_ssa_var_info *res_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].result_def];
			if (res_ssa->ce && !res_ssa->is_instanceof) {
				ce = res_ssa->ce;
			}
		}
#else
		if (opline->op1_type == IS_CONST) {
			zval *zv = RT_CONSTANT(op_array, opline->op1);
			if (Z_TYPE_P(zv) == IS_STRING) {
				zval *lc = zv + 1;
				ce = (zend_class_entry*)zend_hash_find_ptr(EG(class_table), Z_STR_P(lc));
			}
		}
#endif
		(*opnum)++;
		if (!ce || ce->constructor) {
			zend_op *next_opline = opline + 1;
			|	cmp IPl, next_opline
			|	jnz >1
			zend_jit_call(Dst, next_opline);
			|1:
		} else {
			valid_opline_offset++;
		}
	}
	return 1;
}

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC

static int zend_jit_inc_dec(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	if (!ssa->ops || !ssa->var_info || opline->op1_type != IS_CV) {
		goto fallback;
	}
	op1_info = OP1_INFO();

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_STRING|MAY_BE_ARRAY)) {
		// TODO: support for IS_STRING and IS_ARRAY ???
		goto fallback;
	}
	if (!(op1_info & MAY_BE_LONG)) {
		goto fallback;
	}

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
		|	jne >2
	}
	||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC) &&
	||	    opline->result_type != IS_UNUSED) {
	|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_LONG, r0, eax, r1
	||	}
	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|	inc aword [FP + opline->op1.var]
	} else {
		|	dec aword [FP + opline->op1.var]
	}
	op1_def_info = OP1_DEF_INFO();
	if (op1_def_info & MAY_BE_DOUBLE) {
		|	jo >1
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
		|.cold_code
		|1:
		if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
			|.if X64
			|	mov64 rax, 0x43e0000000000000
			|	mov qword [FP + opline->op1.var], rax
			|.else
			|	mov dword [FP + opline->op1.var], 0
			|	mov dword [FP + opline->op1.var + 4], 0x41e00000
			|.endif
		} else {
			|.if X64
			|	mov64 rax, 0xc3e0000000000000
			|	mov qword [FP + opline->op1.var], rax
			|.else
			|	mov dword [FP + opline->op1.var], 0x00200000
			|	mov dword [FP + opline->op1.var + 4], 0xc1e00000
			|.endif
		}
		|	mov dword [FP + opline->op1.var + 8], IS_DOUBLE
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_DOUBLE, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	} else {
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
	}
	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|.cold_code
		|2:
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	// ZVAL_DEREF(var_ptr);
		|	ZVAL_DEREF FCARG1a, op1_info
		||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC)) {
		||		if (opline->result_type != IS_UNUSED) {
		|			ZVAL_COPY_VALUE_REG FP, opline->result.var, FCARG1a, op1_info, r0, eax, r2
		|			// zval_opt_copy_ctor(var_ptr);
		|			// ???
		|			TRY_ADDREF op1_info, ah, r2
		||		}
		||	} else {
		|		// SEPARATE_ZVAL_NOREF(var_ptr);
		|		// ???
		||	}
		||	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|		EXT_CALL increment_function, r0
		||	} else {
		|		EXT_CALL decrement_function, r0
		||	}
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, op1_def_info, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	}
	|3:
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_long_long(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t res_info = RES_INFO();
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);

	|	LONG_LOAD opline->op1_type, opline->op1, r0
	||	if (same_ops && opline->opcode != ZEND_DIV) {
	|		LONG_MATH2 opline->opcode, r0, r0
	||	} else {
	|		LONG_MATH opline->opcode, opline->op2_type, opline->op2, r0
	||	}
	if ((res_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) {
		|	LONG_STORE opline->result, r0
	} else {
		|	jo >1
		|.cold_code
		|1:
		|.if X64 or SSE
		|	SSE_LOAD_LONG opline->op1_type, opline->op1, xmm0
		|	SSE_LOAD_LONG opline->op2_type, opline->op2, xmm1
		|	SSE_MATH2 opline->opcode, xmm1, xmm0
		|	SSE_STORE opline->result, xmm0
		|.else
		|	LONGF_LOAD opline->op2_type, opline->op2
		|	LONGF_LOAD opline->op1_type, opline->op1
		|	LONGF_MATH opline->opcode
		|	FP_STORE opline->result
		|.endif
		|	jmp >2
		|.code
		|	LONG_STORE opline->result, r0
		|2:
	}

	return 1;
}

static int zend_jit_math_long_double(dasm_State **Dst, zend_op *opline)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG opline->op1_type, opline->op1, xmm0
	|	SSE_MATH opline->opcode, opline->op2_type, opline->op2, xmm0
	|	SSE_STORE opline->result, xmm0
	|.else
	|	LONGF_LOAD opline->op1_type, opline->op1
	|	FP_MATH opline->opcode, opline->op2_type, opline->op2
	|	FP_STORE opline->result
	|.endif

	return 1;
}

static int zend_jit_math_double_long(dasm_State **Dst, zend_op *opline)
{
	|.if X64 or SSE
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL) {
	|		SSE_LOAD_LONG opline->op2_type, opline->op2, xmm0
	|		SSE_MATH opline->opcode, opline->op1_type, opline->op1, xmm0
	|		SSE_STORE opline->result,  xmm0
	||	} else {
	|		SSE_LOAD opline->op1_type, opline->op1, xmm0
	|		SSE_LOAD_LONG opline->op2_type, opline->op2, xmm1
	|		SSE_MATH2 opline->opcode, xmm1, xmm0
	|		SSE_STORE opline->result,  xmm0
	||	}
	|.else
	|	LONGF_LOAD opline->op2_type, opline->op2
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL) {
	|		FP_MATH opline->opcode, opline->op1_type, opline->op1
	||	} else {
	|		FP_LOAD opline->op1_type, opline->op1
	|		LONGF_MATH opline->opcode
	||	}
	|	FP_STORE opline->result
	|.endif

	return 1;
}

static int zend_jit_math_double_double(dasm_State **Dst, zend_op *opline)
{
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);

	|.if X64 or SSE
	|	SSE_LOAD opline->op1_type, opline->op1, xmm0
	if (same_ops) {
		|	SSE_MATH2 opline->opcode, xmm0, xmm0
	} else {
		|	SSE_MATH opline->opcode, opline->op2_type, opline->op2, xmm0
	}
	|	SSE_STORE opline->result, xmm0
	|.else
	|	FP_LOAD opline->op1_type, opline->op1
	|	FP_MATH opline->opcode, opline->op2_type, opline->op2
	|	FP_STORE opline->result
	|.endif

	return 1;
}

static int zend_jit_math(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow = 0;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		goto fallback;
	}

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
			if (op1_info & MAY_BE_DOUBLE) {
				|	jne >4
			} else {
				|	JNE_SLOW
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
			if (op2_info & MAY_BE_DOUBLE) {
				|	jne >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					|	JNE_SLOW
				}
				if (!zend_jit_math_long_double(Dst, opline)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	JNE_SLOW
			}
		}
		if (!zend_jit_math_long_long(Dst, opline, op_array, ssa)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				|	JNE_SLOW
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					if (!same_ops) {
						|	jne >5
					} else {
						|	JNE_SLOW
					}
				}
				if (!zend_jit_math_double_double(Dst, opline)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
					|	JNE_SLOW
				}
				if (!zend_jit_math_double_long(Dst, opline)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_math_double_double(Dst, opline)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_math_double_long(Dst, opline)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_math_double_double(Dst, opline)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_math_long_double(Dst, opline)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	|6:
	valid_opline_offset++;

	if (has_slow) {
		|.cold_code
		|9:
		|	mov EX->opline, IP
		|	lea	FCARG1a, [FP + opline->result.var]
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		|.if X64
		|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
		|.else
		|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
		|.endif
		||	if (opline->opcode == ZEND_ADD) {
		|		EXT_CALL add_function, r0
		||	} else if (opline->opcode == ZEND_SUB) {
		|		EXT_CALL sub_function, r0
		||	} else if (opline->opcode == ZEND_MUL) {
		|		EXT_CALL mul_function, r0
		||	} else if (opline->opcode == ZEND_DIV) {
		|		EXT_CALL div_function, r0
		||	} else {
		||		ZEND_ASSERT(0);
		||	}
		||	if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
		||      (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|		and byte [FP + opline->op1.var + 9], IS_TYPE_REFCOUNTED
		|		je >1
		|		mov FCARG1a, aword [FP + opline->op1.var]
		|		dec dword [FCARG1a]
		|		jnz >1
		||		if (ZEND_DEBUG) {
		||			const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|			LOAD_ADDR FCARG2a, filename
		|			push opline->lineno
		||		}
		|		EXT_CALL _zval_dtor_func, r0
		|1:
		||	}
		||	if ((opline->op2_type & (IS_VAR|IS_TMP_VAR)) &&
		||	    (op2_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|		and byte [FP + opline->op2.var + 9], IS_TYPE_REFCOUNTED
		|		je >1
		|		mov FCARG1a, aword [FP + opline->op2.var]
		|		dec dword [FCARG1a]
		|		dec dword [FP + opline->op2.var]
		|		jnz >1
		||		if (ZEND_DEBUG) {
		||			const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|			LOAD_ADDR FCARG2a, filename
		|			push opline->lineno
		||		}
		|		EXT_CALL _zval_dtor_func, r0
		|1:
		||	}
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		|	jmp <6
		|.code
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp_long_long(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	LONG_LOAD opline->op1_type, opline->op1, r0
	|	LONG_OP cmp, opline->op2_type, opline->op2, r0
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	mov dword [FP + opline->result.var + 8], eax
	}

	return 1;
}

static int zend_jit_cmp_double_common(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jnae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jna => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				|	jp >1
				|	mov eax, IS_TRUE
				|	je >2
				|1:
				|	mov eax, IS_FALSE
				|2:
				break;
			case ZEND_IS_NOT_EQUAL:
				|	jp >1
				|	mov eax, IS_FALSE
				|	je >2
				|1:
				|	mov eax, IS_TRUE
				|2:
				break;
			case ZEND_IS_SMALLER:
				|	seta al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setae al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	mov dword [FP + opline->result.var + 8], eax
	}

	return 1;
}

static int zend_jit_cmp_long_double(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG opline->op1_type, opline->op1, xmm0
	|	SSE_OP ucomisd, opline->op2_type, opline->op2, xmm0
	|.else
	|	FP_LOAD opline->op2_type, opline->op2
	|	LONGF_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_long(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD opline->op1_type, opline->op1, xmm0
	|	SSE_LOAD_LONG opline->op2_type, opline->op2, xmm1
	|	ucomisd xmm0, xmm1
	|.else
	|	LONGF_LOAD opline->op2_type, opline->op2
	|	FP_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_double(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD opline->op1_type, opline->op1, xmm0
	|	SSE_OP ucomisd, opline->op2_type, opline->op2, xmm0
	|.else
	|	FP_LOAD opline->op2_type, opline->op2
	|	FP_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_slow(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	cmp aword [FP + opline->result.var], 0
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	mov dword [FP + opline->result.var + 8], eax
	}

	return 1;
}

static int zend_jit_cmp(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow = 0;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		goto fallback;
	}

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
			if (op1_info & MAY_BE_DOUBLE) {
				|	jne >4
			} else {
				|	JNE_SLOW
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
			if (op2_info & MAY_BE_DOUBLE) {
				|	jne >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					|	JNE_SLOW
				}
				if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	JNE_SLOW
			}
		}
		if (!zend_jit_cmp_long_long(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				|	JNE_SLOW
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					if (!same_ops) {
						|	jne >5
					} else {
						|	JNE_SLOW
					}
				}
				if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
					|	JNE_SLOW
				}
				if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	|6:
	if (((opline+1)->opcode == ZEND_JMPZ || (opline+1)->opcode == ZEND_JMPNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		valid_opline_offset += 2;
	} else {
		valid_opline_offset++;
	}

	if (has_slow) {
		|.cold_code
		|9:
		|	mov EX->opline, IP
		|	lea	FCARG1a, [FP + opline->result.var]
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		|.if X64
		|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
		|.else
		|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
		|.endif
		|	EXT_CALL compare_function, r0
		||	if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
		||      (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|		and byte [FP + opline->op1.var + 9], IS_TYPE_REFCOUNTED
		|		je >1
		|		mov FCARG1a, aword [FP + opline->op1.var]
		|		dec dword [FCARG1a]
		|		jnz >1
		||		if (ZEND_DEBUG) {
		||			const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|			LOAD_ADDR FCARG2a, filename
		|			push opline->lineno
		||		}
		|		EXT_CALL _zval_dtor_func, r0
		|1:
		||	}
		||	if ((opline->op2_type & (IS_VAR|IS_TMP_VAR)) &&
		||	    (op2_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|		and byte [FP + opline->op2.var + 9], IS_TYPE_REFCOUNTED
		|		je >1
		|		mov FCARG1a, aword [FP + opline->op2.var]
		|		dec dword [FCARG1a]
		|		dec dword [FP + opline->op2.var]
		|		jnz >1
		||		if (ZEND_DEBUG) {
		||			const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|			LOAD_ADDR FCARG2a, filename
		|			push opline->lineno
		||		}
		|		EXT_CALL _zval_dtor_func, r0
		|1:
		||	}
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		if (!zend_jit_cmp_slow(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		|	jmp <6
		|.code
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_simple_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t var, uint32_t var_info, zend_uchar val_type, znode_op val, uint32_t val_info)
{
	if (val_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		/* TODO: Support for references ??? */
		goto fallback;
	} else if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);
		|	ZVAL_COPY_CONST FP, var, var_info, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
		valid_opline_offset++;
		return 1;
	}

	|	ZVAL_COPY_VALUE FP, var, FP, val.var, val_info, r0, eax, r1
	||	if (val_type == IS_CV) {
	|		TRY_ADDREF val_info, ah, r1
	||	}
	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_qm_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->result.var, -1, opline->op1_type, opline->op1, op1_info);

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED || !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (!(op1_info & (MAY_BE_STRING|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_REF))) {
		return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info);
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_push_call_frame(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_function *func)
{
	if (!func) {
		assert(0);
	}

	uint32_t used_stack = zend_vm_calc_used_stack(opline->extended_value, func);

	|	// if (UNEXPECTED(used_stack > (size_t)(((char*)EG(vm_stack_end)) - (char*)call))) {
	|	mov r1, aword [&EG(vm_stack_top)]
	|	mov r2, aword [&EG(vm_stack_end)]
	|	sub r2,r1
	|	cmp r2, used_stack
	|	jb >2
	|	// EG(vm_stack_top) = (zval*)((char*)call + used_stack);
	|	add aword [&EG(vm_stack_top)], used_stack
	|	// zend_vm_init_call_frame(call, call_info, func, num_args, called_scope, object);
	|	// call->func = func;
	|	mov aword EX:r1->func, r0
	|	// ZEND_SET_CALL_INFO(call, 0, call_info);
	|	mov dword EX:r1->This.u1.type_info, (IS_UNDEF | (ZEND_CALL_NESTED_FUNCTION << ZEND_CALL_INFO_SHIFT))
	|1:
	|	// Z_CE(call->This) = called_scope;
	|	mov aword EX:r1->This.value.ptr, 0
	|	// ZEND_CALL_NUM_ARGS(call) = num_args;
	|	mov dword EX:r1->This.u2.num_args, opline->extended_value
	|.cold_code
	|2:
	|	mov FCARG1d, used_stack
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_extend_stack_helper, r0
	|	mov r1, r0
	|	jmp <1
	|.code

	return 1;
}

static int zend_jit_init_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_function *func = NULL;

	if (info) {
		zend_call_info *call_info = info->callee_info;

		while (call_info && call_info->caller_init_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|	LOAD_ADDR r0, func
	} else if (func && op_array == &func->op_array) {
		/* recursive call */
		|	mov r0,	EX->func
	} else {
		zval *zv = RT_CONSTANT(op_array, opline->op2);

		|	// if (CACHED_PTR(Z_CACHE_SLOT_P(fname)))
		|	mov r0,	EX->run_time_cache
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
		|	test r0, r0
		|	jz >1
		|.cold_code
		|1:
		|	// SAVE_OPLINE();
		|	mov EX->opline, IP
		|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
		|	EXT_CALL zend_jit_find_func_helper, r0
		|	// This opcode must not throw exception ???
		|		// test r0, r0
		|		// jz ->exception_handler */
		|	// CACHE_PTR(Z_CACHE_SLOT_P(fname), fbc);
		|	mov r1,	EX->run_time_cache
		|	mov aword [r1 + Z_CACHE_SLOT_P(zv)], r0
		|	jmp >3
		|.code
		|3:
	}
	if (!zend_jit_push_call_frame(Dst, opline, op_array, func)) {
		return 0;
	}
	|	// call->prev_execute_data = EX(call);
	if (call_level == 1) {
		|	mov aword EX:r1->prev_execute_data, 0
	} else {
		|	mov r0, EX->call
		|	mov EX:r1->prev_execute_data, r0
	}
	|	// EX(call) = call;
	|	mov EX->call, r1
	valid_opline_offset++;

	return 1;
}

static int zend_jit_do_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;
	uint32_t i;

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_call_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (!func ||
	    func->type != ZEND_USER_FUNCTION ||
	    call_info->num_args > func->op_array.num_args ||
	    (opline-1)->opcode == ZEND_SEND_UNPACK ||
	    (func->op_array.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0) {
		goto fallback;
	}

	|	// call = EX(call);
	|	mov r1, EX->call
	|	// fbc = call->func;
	|	// mov r2, EX:r1->func ???
	|	// SAVE_OPLINE();
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	mov EX->opline, IP
	||	if (call_level == 1) {
	|		mov aword EX->call, 0
	||	} else {
	|		//EX(call) = call->prev_execute_data;
	|		mov r0, EX:r1->prev_execute_data
	|		mov EX->call, r0
	||	}
	|	//call->prev_execute_data = execute_data;
	|	mov EX:r1->prev_execute_data, EX
	|
	|	// EX(call) = NULL;
	|	mov aword EX:r1->call, 0
	||	if (RETURN_VALUE_USED(opline)) {
	|		// ZVAL_NULL(EX_VAR(opline->result.var));
	|		mov dword [FP + opline->result.var + 8], IS_NULL
	|		// EX(return_value) = EX_VAR(opline->result.var);
	|		lea r0, aword [FP + opline->result.var]
	|		mov aword EX:r1->return_value, r0
	||	} else {
	|		// EX(return_value) = 0;
	|		mov aword EX:r1->return_value, 0
	||	}
	|
	||	for (i = call_info->num_args; i < func->op_array.last_var; i++) {
	||		uint32_t n = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
	|		mov dword [r1 + n + 8], IS_UNDEF
	||	}
	|
	|	//EX_LOAD_RUN_TIME_CACHE(op_array);
	||	if (func && op_array == &func->op_array) {
	||		/* recursive call */
	|		mov r0, EX->run_time_cache
	||	} else {
	|		mov r2, EX:r1->func
	|		mov r0, aword [r2 + offsetof(zend_op_array, run_time_cache)]
	||	}
	|	mov EX:r1->run_time_cache, r0
	|	//EX_LOAD_LITERALS(op_array);
	|.if X64
	|	LOAD_ADDR r0, func->op_array.literals
	|	mov EX:r1->literals, r0
	|.endif
	|	// EG(current_execute_data) = execute_data;
	|	mov aword [&EG(current_execute_data)], r1
	|	mov FP, r1
	|	// EX(opline) = op_array->opcodes;
	|	LOAD_ADDR IP, (func->op_array.opcodes + call_info->num_args)
	|	mov EX:r1->opline, IP
	||	if (func && op_array == &func->op_array) {
	||		/* recursive call */
	|		jmp =>call_info->num_args
	||	} else {
	|		add r4, SPAD // stack alignment
	|		jmp aword [IP]
	||	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	if (opline->opcode == ZEND_DO_FCALL ||
	    opline->opcode == ZEND_DO_UCALL ||
	    opline->opcode == ZEND_DO_FCALL_BY_NAME ){
		return zend_jit_call(Dst, opline);
	} else {
		return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
	}
}

static int zend_jit_send_val(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);

		|	mov r1, EX->call
		|	ZVAL_COPY_CONST r1, opline->result.var, -1, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
		valid_opline_offset++;
		return 1;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	|	mov r1, EX->call
	|	ZVAL_COPY_VALUE r1, opline->result.var, FP, opline->op1.var, op1_info, r0, eax, r2
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_send_var(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	if (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		// TODO: support for references ???
		goto fallback;
	}

	op1_info = OP1_INFO();
	|	mov r1, EX->call
	|	ZVAL_COPY_VALUE r1, opline->result.var, FP, opline->op1.var, op1_info, r0, eax, r2
	||	if (opline->op1_type == IS_CV) {
	|		TRY_ADDREF op1_info, ah, r2
	||	}
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_type_check(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	unsigned int target_label;
	zend_uchar type;

	if (!ssa->ops || !ssa->var_info || opline->extended_value == IS_RESOURCE) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	type = opline->extended_value;
	if ((op1_info & (MAY_BE_ANY|MAY_BE_UNDEF|MAY_BE_REF)) == (1<<type)) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			valid_opline_offset++;
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else {
			|	mov dword [FP + opline->result.var + 8], IS_TRUE
			valid_opline_offset++;
		}
    } else if (!(op1_info & (1<<type))) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			valid_opline_offset += 2;
		} else {
			|	mov dword [FP + opline->result.var + 8], IS_FALSE
			valid_opline_offset++;
		}
	} else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
