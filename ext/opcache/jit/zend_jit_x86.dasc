/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  |          Xinchen Hui <xinchen.h@zend.com>                            |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,      r14
 |.define IP,      r15
 |.define IPl,     r15d
 |.define CARG1,   rdi       // x64/POSIX C call arguments.
 |.define CARG2,   rsi
 |.define CARG3,   rdx
 |.define CARG4,   rcx
 |.define CARG5,   r8
 |.define CARG6,   r9
 |.define CARG1d,  edi
 |.define CARG2d,  esi
 |.define CARG3d,  edx
 |.define CARG4d,  ecx
 |.define CARG5d,  r8d
 |.define CARG6d,  r9d
 |.define FCARG1a, CARG1    // Simulate x86 fastcall.
 |.define FCARG2a, CARG2
 |.define FCARG1d, CARG1d
 |.define FCARG2d, CARG2d
 |.define SPAD,    8
 |.define SSE,     1
|.else
 |.define FP,      esi
 |.define IP,      edi
 |.define IPl,     edi
 |.define FCARG1a, ecx       // x86 fastcall arguments.
 |.define FCARG2a, edx
 |.define FCARG1d, ecx
 |.define FCARG2d, edx
 |.define SPAD,    12
 |.define SSE,     1
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_op, IP
|.type ZVAL, zval

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code, cold_code

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0x7fffffff)

|.macro LOAD_ADDR, reg, addr
|.if X64
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.else
|	mov reg, addr
|.endif
|.endmacro

|.macro EXT_CALL, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	call qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	call tmp_reg
||}
|.else
|	call dword &func
|.endif
|.endmacro

|.macro EXT_JMP, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	jmp qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	jmp tmp_reg
||}
|.else
|	jmp dword &func
|.endif
|.endmacro

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OT_FUNC

|.macro LOAD_ZVAL_ADDR, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov reg, aword EX->literals
|   add reg, op.constant
|   .else
|   mov reg, op.zv
|   .endif
||} else {
|   lea reg, qword [FP + op.var]
||}
|.endmacro

|.macro PUSH_ZVAL_ADDR, op_type, op, tmp_reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov tmp_reg, aword EX->literals
|   add tmp_reg, op.constant
|	push tmp_reg
|   .else
|   push op.zv
|   .endif
||} else {
|   lea tmp_reg, qword [FP + op.var]
|	push tmp_reg
||}
|.endmacro

|.macro GET_Z_TYPE_INFO, reg, zv
|	mov reg, dword [zv + 8]
|.endmacro

|.macro SET_Z_TYPE_INFO, zv, type
|	mov dword [zv + 8], type
|.endmacro

|.macro GET_Z_LVAL, reg, zv
|	mov reg, aword [zv]
|.endmacro

|.macro SET_Z_LVAL, zv, val
|	mov aword [zv], val
|.endmacro

|.macro GET_Z_PTR, reg, zv
|	mov reg, aword [zv]
|.endmacro

|.macro SET_Z_PTR, zv, val
|	mov aword [zv], val
|.endmacro

|.macro GET_Z_W2, reg, zv
|	mov reg, dword [zv + 4]
|.endmacro

|.macro SET_Z_W2, zv, val
|	mov dword [zv + 4], val
|.endmacro

|.macro FPU_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins qword [op.zv]
|   .endif
||} else {
|   fp_ins qword [FP + op.var]
||}
|.endmacro

|.macro FPU_LOAD, op_type, op
|	FPU_OP fld, op_type, op
|.endmacro

|.macro FPU_MATH, opcode, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
|         FPU_OP fadd, op_type, op
||        break;
||    case ZEND_SUB:
|         FPU_OP fsub, op_type, op
||        break;
||    case ZEND_MUL:
|         FPU_OP fmul, op_type, op
||        break;
||    case ZEND_DIV:
|         FPU_OP fdiv, op_type, op
||        break;
||}
|.endmacro

|.macro FPU_STORE, zv
|	fstp qword [zv]
|.endmacro

|.macro SSE_OP, sse_ins, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   sse_ins reg, qword [r0 + op.constant]
|   .else
|   sse_ins reg, qword [op.zv]
|   .endif
||} else {
|   sse_ins reg, qword [FP + op.var]
||}
|.endmacro

|.macro SSE_LOAD_LONG, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   cvtsi2sd reg, qword [r0 + op.constant]
|   .else
|   cvtsi2sd reg, dword [op.zv]
|   .endif
||} else {
|   .if X64
|   cvtsi2sd reg, qword [FP + op.var]
|   .else
|   cvtsi2sd reg, dword [FP + op.var]
|   .endif
||}
|.endmacro

|.macro SSE_LOAD, reg, op_type, op
|	SSE_OP movsd, reg, op_type, op
|.endmacro

|.macro SSE_MATH, opcode, reg, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
|         SSE_OP addsd, reg, op_type, op
||        break;
||    case ZEND_SUB:
|         SSE_OP subsd, reg, op_type, op
||        break;
||    case ZEND_MUL:
|         SSE_OP mulsd, reg, op_type, op
||        break;
||    case ZEND_DIV:
|         SSE_OP divsd, reg, op_type, op
||        break;
||}
|.endmacro

|.macro SSE_MATH2, opcode, dst_reg, src_reg
||switch (opcode) {
||    case ZEND_ADD:
|         addsd dst_reg, src_reg
||        break;
||    case ZEND_SUB:
|         subsd dst_reg, src_reg
||        break;
||    case ZEND_MUL:
|         mulsd dst_reg, src_reg
||        break;
||    case ZEND_DIV:
|         divsd dst_reg, src_reg
||        break;
||}
|.endmacro

|.macro SSE_STORE, zv, reg
|	movsd qword [zv], reg
|.endmacro

|.macro DOUBLE_STORE, zv, reg
|.if X64 or SSE
|	SSE_STORE zv, reg
|.else
|	FPU_STORE zv
|.endif
|.endmacro

|.macro LONG_OP, long_ins, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   	long_ins reg, r1
||  } else {
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   long_ins reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_LOAD, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  } else {
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   GET_Z_LVAL reg, FP + op.var
||}
|.endmacro

|.macro LONG_MATH, opcode, reg, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
|         LONG_OP add, reg, op_type, op
||        break;
||    case ZEND_SUB:
|         LONG_OP sub, reg, op_type, op
||        break;
||    case ZEND_MUL:
|         LONG_OP imul, reg, op_type, op
||        break;
||    case ZEND_DIV:
|         idiv aword [FP + op.var] // (reg == r0)
||        break;
||}
|.endmacro

|.macro LONG_MATH2, opcode, dst_reg, src_reg
||switch (opcode) {
||    case ZEND_ADD:
|         add dst_reg, src_reg
||        break;
||    case ZEND_SUB:
|         sub dst_reg, src_reg
||        break;
||    case ZEND_MUL:
|         imul dst_reg, src_reg
||        break;
||    case ZEND_DIV:
|         idiv src_reg // (reg1 == r0)
||        break;
||}
|.endmacro

|.macro FPU_LONG_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins dword [op.zv]
|   .endif
||} else {
|   fp_ins aword [FP + op.var]
||}
|.endmacro

|.macro FPU_LONG_LOAD, op_type, op
|	FPU_LONG_OP fild, op_type, op
|.endmacro

|.macro FPU_MATH2, opcode
||switch (opcode) {
||    case ZEND_ADD:
|         fadd st1
||        break;
||    case ZEND_SUB:
|         fsub st1
||        break;
||    case ZEND_MUL:
|         fmul st1
||        break;
||    case ZEND_DIV:
|         fdiv st1
||        break;
||}
|.endmacro

|.macro ZVAL_COPY_CONST, dst, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			SET_Z_LVAL dst, tmp_reg
||		} else {
|			SET_Z_LVAL dst, Z_LVAL_P(zv)
||		}
|.else
|		SET_Z_LVAL dst, Z_LVAL_P(zv)
|.endif
||	}
||}
||if ((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) {
|	SET_Z_TYPE_INFO dst, Z_TYPE_INFO_P(zv)
||}
|.endmacro

|.macro ZVAL_COPY_CONST_2, dst, dst2, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst]
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			SET_Z_LVAL dst, tmp_reg
|			SET_Z_LVAL dst2, tmp_reg
||		} else {
|			SET_Z_LVAL dst, Z_LVAL_P(zv)
|			SET_Z_LVAL dst2, Z_LVAL_P(zv)
||		}
|.else
|		SET_Z_LVAL dst, Z_LVAL_P(zv)
|		SET_Z_LVAL dst2, Z_LVAL_P(zv)
|.endif
||	}
||}
||if ((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) {
|	SET_Z_TYPE_INFO dst, Z_TYPE_INFO_P(zv)
||}
|	SET_Z_TYPE_INFO dst2, Z_TYPE_INFO_P(zv)
|.endmacro

|.macro ZVAL_COPY_VALUE, dst, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.else
|		GET_Z_PTR tmp_reg2, src
|		GET_Z_W2 tmp_reg1, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_W2 dst, tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
||}
|.endmacro

|.macro ZVAL_COPY_VALUE_2, dst, dst2, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
| 		SET_Z_PTR dst2, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|		fld qword [src]
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.else
|		GET_Z_PTR tmp_reg2, src
|		GET_Z_W2 tmp_reg1, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|		SET_Z_W2 dst, tmp_reg1
|		SET_Z_W2 dst2, tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
|	SET_Z_TYPE_INFO dst2, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
|	SET_Z_TYPE_INFO dst2, tmp_reg1d
||}
|.endmacro

|.macro IF_TYPE, type, val, label
|	cmp type, val
|	je label
|.endmacro

|.macro IF_NOT_TYPE, type, val, label
|	cmp type, val
|	jne label
|.endmacro

|.macro IF_Z_TYPE, zv, val, label
|	IF_TYPE byte [zv + 8], val, label
|.endmacro

|.macro IF_NOT_Z_TYPE, zv, val, label
|	IF_NOT_TYPE byte [zv + 8], val, label
|.endmacro

|.macro IF_FLAGS, type_flags, mask, label
|	test type_flags, mask
|	jnz label
|.endmacro

|.macro IF_NOT_FLAGS, type_flags, mask, label
|	test type_flags, mask
|	jz label
|.endmacro

|.macro IF_REFCOUNTED, type_flags, label
|	IF_FLAGS type_flags, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_NOT_REFCOUNTED, type_flags, label
|	IF_NOT_FLAGS type_flags, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_Z_FLAGS, zv, mask, label
|	IF_FLAGS byte [zv + 9], mask, label
|.endmacro

|.macro IF_NOT_Z_FLAGS, zv, mask, label
|	IF_NOT_FLAGS byte [zv + 9], mask, label
|.endmacro

|.macro IF_Z_REFCOUNTED, zv, label
|	IF_Z_FLAGS zv, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_NOT_Z_REFCOUNTED, zv, label
|	IF_NOT_Z_FLAGS zv, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro GC_ADDREF, zv
|	inc	dword [zv]
|.endmacro

|.macro GC_DELREF, zv
|	dec	dword [zv]
|.endmacro

|.macro IF_GC_INFO, ptr, label
|	cmp word [ptr + 6], 0
|	jne label
|.endmacro

|.macro IF_NOT_GC_INFO, ptr, label
|	cmp word [ptr + 6], 0
|	je label
|.endmacro

|.macro ADDREF_CONST, zv, tmp_reg
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			inc dword [tmp_reg]
||		} else {
|			inc dword [Z_LVAL_P(zv)]
||		}
|.else
|		inc dword [Z_LVAL_P(zv)]
|.endif
|.endmacro

|.macro TRY_ADDREF, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		IF_NOT_REFCOUNTED type_flags_reg, >1
||	}
|	GC_ADDREF value_ptr_reg
|1:
||}
|.endmacro

|.macro TRY_ADDREF_2, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		IF_NOT_REFCOUNTED type_flags_reg, >1
||	}
|	add dword [value_ptr_reg], 2
|1:
||}
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_COPY_CTOR_FUNC, filename, lineno // arg1 must be in FCARG1a
||	if (ZEND_DEBUG) {
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|		EXT_CALL _zval_copy_ctor_func, r0
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_COPY_CTOR, val_info, type_flags_reg, value_ptr_reg, filename, lineno
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
|		IF_NOT_FLAGS type_flags_reg, IS_TYPE_REFCOUNTED + IS_TYPE_IMMUTABLE, >2
|		IF_NOT_FLAGS type_flags_reg, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >1
|		GC_ADDREF value_ptr_reg
|		jmp >2
|1:
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|2:
||	} else {
|		TRY_ADDREF val_info, type_flags_reg, value_ptr_reg
||	}
||}
|.endmacro

|.macro ZVAL_DEREF, reg, info
||	if (info & MAY_BE_REF) {
|		IF_NOT_Z_TYPE, reg, IS_REFERENCE, >1
|		GET_Z_PTR reg, reg
|		add reg, offsetof(zend_reference, val)
|1:
||	}
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_DTOR_FUNC, filename, lineno // arg1 must be in FCARG1a
||	if (ZEND_DEBUG) {
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|		EXT_CALL _zval_dtor_func, r0
|.endmacro

|.macro ZVAL_PTR_DTOR_NOGC, zv, filename, lineno
|		IF_NOT_Z_REFCOUNTED zv, >1
|		GET_Z_PTR FCARG1a, zv
|		GC_DELREF FCARG1a
|		jnz >1
|		ZVAL_DTOR_FUNC filename, lineno
|1:
|.endmacro

|.macro ZVAL_PTR_DTOR, zv, info, cold, filename, lineno
||	if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
||		if (info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|			// if (Z_REFCOUNTED_P(cv)) {
||			if (cold) {
|				IF_Z_REFCOUNTED zv, >1
|.cold_code
|1:
||			} else {
|				IF_NOT_Z_REFCOUNTED zv, >3
||			}
||		}
|		// if (!Z_DELREF_P(cv)) {
|		GET_Z_PTR FCARG1a, zv
|		GC_DELREF FCARG1a
|		jnz >1
|		// ZVAL_NULL(cv);
|		SET_Z_TYPE_INFO zv, IS_NULL
|		// zval_dtor_func(r);
|		ZVAL_DTOR_FUNC filename, lineno
||		if (info & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT)) {
|			jmp >3
||		}
|1:
||		if (info & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT)) {
||			if (info & MAY_BE_REF) {
|				lea r1, [zv]
|				// ZVAL_DEREF(z);
|				ZVAL_DEREF r1, info
|				// if (Z_COLLECTABLE_P(z))
|				IF_NOT_Z_FLAGS r1, IS_TYPE_COLLECTABLE, >3
|				// if (UNEXPECTED(!Z_GC_INFO_P(z)))
|				GET_Z_PTR FCARG1a, r1
|				IF_GC_INFO FCARG1a, >3
||			} else {
|				// if (Z_COLLECTABLE_P(z))
|				IF_NOT_Z_FLAGS zv, IS_TYPE_COLLECTABLE, >3
|				// if (UNEXPECTED(!Z_GC_INFO_P(z)))
|				GET_Z_PTR FCARG1a, zv
|				IF_GC_INFO FCARG1a, >3
||			}
|			// gc_possible_root(Z_COUNTED_P(z))
|			EXT_CALL gc_possible_root, r0
||			if (cold && (info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|				jmp >3
|.code
||			}
||		} else if (cold && (info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|			jmp >3
|.code
||		}
|3:
||	}
|.endmacro

|.macro FREE_OP, op_type, op, op_info, op_array, lineno
||if ((op_type & (IS_VAR|IS_TMP_VAR)) &&
||   (op_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|	ZVAL_PTR_DTOR_NOGC FP + op.var, (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), lineno
||}
|.endmacro

|.macro EFREE_SIZE, ptr, size, op_array, opline
|	mov FCARG1a, ptr
||	if (ZEND_DEBUG) {
||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, opline->lineno
|		xor CARG4, CARG4
|		xor CARG5, CARG5
|.else
|		push opline->lineno
|		push 0
|		push 0
|.endif
||	}
|	EXT_CALL _efree, r0
|.endmacro

|.macro OBJ_RELEASE, reg, exit_label
|	GC_DELREF reg
|	jne >1
|	// zend_objects_store_del(obj);
|.if X64
|	mov CARG1, reg
|	EXT_CALL zend_objects_store_del, r0
|.else
|	sub r4, 12
|	push reg
|	EXT_CALL zend_objects_store_del, r0
|	add r4, 16
|.endif
|	jmp exit_label
|1:
|	// if (UNEXPECTED(!GC_INFO(obj))) {
|	IF_GC_INFO reg, exit_label
|	// gc_possible_root(obj)
|	mov FCARG1a, reg
|	EXT_CALL gc_possible_root, r0
|.endmacro

|.macro SAVE_VALID_OPLINE
||	if (valid_opline || valid_opline_offset) {
||		if (!valid_opline) {
|			lea r0, [IP + sizeof(zend_op) * valid_opline_offset]
||		} else {
||			const zend_op *target_opline = valid_opline + valid_opline_offset;
|			LOAD_ADDR r0, target_opline
||		}
|		mov EX->opline, r0
||	} else {
|		mov EX->opline, IP
||	}
|.endmacro

static const zend_op *valid_opline;
static uint32_t valid_opline_offset;
static int jit_return_label;
#endif

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static inline zend_bool is_signed(double d)
{
    return (((unsigned char*)&d)[sizeof(double)-1] & 0x80) != 0;
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|.else
	|	push 0
	|.endif
	|	EXT_CALL zend_timeout, r0
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		|	mov CARG1, FP
		|.else
		|	push FP
		|.endif
		|	EXT_CALL zend_interrupt_function, r0
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static int zend_jit_leave_function_stub(dasm_State **Dst)
{
	|->leave_function_handler:
	|	add r4, SPAD
	|	test FCARG1d, ZEND_CALL_TOP
	|	jnz >1
	|	EXT_JMP zend_jit_leave_nested_func_helper, r0
	|1:
	|	EXT_JMP zend_jit_leave_top_func_helper, r0

	return 1;
}

static int zend_jit_leave_throw_stub(dasm_State **Dst)
{
	|->leave_throw_handler:
	|	// if (opline->opcode != ZEND_HANDLE_EXCEPTION) {
	|	cmp byte OP:IP->opcode, ZEND_HANDLE_EXCEPTION
	|	je >5
	|	// EG(opline_before_exception) = opline;
	|	mov aword [&EG(opline_before_exception)], IP
	|	// if (RETURN_VALUE_USED(old_opline)) {
	|	cmp byte OP:IP->result_type, IS_UNUSED
	|	je >5
	|	// zval_ptr_dtor(EX_VAR(old_opline->result.var));
	|.if X64
	|	movsxd r0, dword OP:IP->result.var
	|.else
	|	mov r0, OP:IP->result.var
	|.endif
	|	add r0, FP
	|	ZVAL_PTR_DTOR r0, MAY_BE_ANY, 0, NULL, 0
	|5:
	|	// EX(opline) = EG(exception_op);
	|	LOAD_ADDR IP, &EG(exception_op)
	|	mov EX->opline, IP
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
	JIT_STUB(leave_function),
	JIT_STUB(leave_throw),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	valid_opline = NULL;
	valid_opline_offset = 0;
	jit_return_label = -1;
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_set_valid_ip(dasm_State **Dst)
{
	if (valid_opline || valid_opline_offset) {
		if (!valid_opline) {
			|	add IP, sizeof(zend_op) * valid_opline_offset
		} else {
			const zend_op *target_opline = valid_opline + valid_opline_offset;

			valid_opline = NULL;
			|	LOAD_ADDR IP, target_opline
		}
		valid_opline_offset = 0;
	}
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	if (zend_interrupt_function) {
		if (!zend_jit_set_valid_ip(Dst)) {
			return 0;
		}
	}
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline, int may_throw)
{
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	EXT_CALL opline->handler, r0
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	add r4, SPAD // stack alignment
	|	EXT_JMP opline->handler, r0
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst)
{
	valid_opline_offset++;
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	valid_opline = target_opline;
	valid_opline_offset = 0;
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jne =>target_label

	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	je =>next_label
	|	cmp IPl, target_opline
	|	je =>target_label

	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	je >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	if (!zend_jit_handler(Dst, opline, 1)) {
		return 0;
	}
	if (opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL) {
		zend_class_entry *ce = NULL;
#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC
		if (ssa->ops && ssa->var_info) {
			zend_ssa_var_info *res_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].result_def];
			if (res_ssa->ce && !res_ssa->is_instanceof) {
				ce = res_ssa->ce;
			}
		}
#else
		if (opline->op1_type == IS_CONST) {
			zval *zv = RT_CONSTANT(op_array, opline->op1);
			if (Z_TYPE_P(zv) == IS_STRING) {
				zval *lc = zv + 1;
				ce = (zend_class_entry*)zend_hash_find_ptr(EG(class_table), Z_STR_P(lc));
			}
		}
#endif
		(*opnum)++;
		if (!ce || ce->constructor) {
			zend_op *next_opline = opline + 1;
			|	cmp IPl, next_opline
			|	jne >1
			zend_jit_call(Dst, next_opline);
			|1:
		} else {
			valid_opline_offset++;
		}
	}
	return 1;
}

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC

static int zend_jit_inc_dec(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	op1_info = OP1_INFO();
	if (opline->op1_type != IS_CV || !(op1_info & MAY_BE_LONG)) {
		goto fallback;
	}

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >2
	}
	||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC) &&
	||	    opline->result_type != IS_UNUSED) {
	|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
	||	}
	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|	inc aword [FP + opline->op1.var]
	} else {
		|	dec aword [FP + opline->op1.var]
	}
	op1_def_info = OP1_DEF_INFO();
	if (op1_def_info & MAY_BE_DOUBLE) {
		|	jo >1
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
		|.cold_code
		|1:
		if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
			|.if X64
			|	mov64 rax, 0x43e0000000000000
			|	SET_Z_LVAL FP + opline->op1.var, rax
			|.else
			|	SET_Z_LVAL FP + opline->op1.var, 0
			|	SET_Z_W2 FP + opline->op1.var, 0x41e00000
			|.endif
		} else {
			|.if X64
			|	mov64 rax, 0xc3e0000000000000
			|	SET_Z_LVAL FP + opline->op1.var, rax
			|.else
			|	SET_Z_LVAL FP + opline->op1.var, 0x00200000
			|	SET_Z_W2 FP + opline->op1.var, 0xc1e00000
			|.endif
		}
		|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_DOUBLE
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_DOUBLE, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	} else {
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
	}
	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_LONG)) {
		|.cold_code
		|2:
		||	if (op1_info & MAY_BE_UNDEF) {
		|		IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >2
		|		// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|		mov FCARG1d, opline->op1.var
		|		EXT_CALL zend_jit_undefined_op_helper, r0
		|		SET_Z_TYPE_INFO FP + opline->op1.var, IS_NULL
		||	}
		|2:
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	// ZVAL_DEREF(var_ptr);
		|	ZVAL_DEREF FCARG1a, op1_info
		||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC)) {
		||		if (opline->result_type != IS_UNUSED) {
		|			ZVAL_COPY_VALUE FP + opline->result.var, FCARG1a, op1_info, r0, eax, r2
		|			//ZVAL_COPY_CTOR op1_info, ah, r2, (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		||			if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
		||				if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
		|					IF_NOT_FLAGS ah, IS_TYPE_REFCOUNTED + IS_TYPE_IMMUTABLE, >2
		|					IF_FLAGS ah, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >1
		|					GC_ADDREF r2
		|					jmp >2
		|1:
		|					mov aword [r4], FCARG1a // save
		|					ZVAL_COPY_CTOR_FUNC (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		|					mov FCARG1a, aword [r4] // restore
		|2:
		||				} else {
		|					TRY_ADDREF op1_info, ah, r2
		||				}
		||			}
		||		}
		||	} else {
		||		if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
		|			// SEPARATE_ZVAL_NOREF(var_ptr);
		|			IF_NOT_Z_FLAGS FCARG1a, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >2
		|			GET_Z_PTR r0, FCARG1a
		|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
		|			jbe >2
		|			IF_Z_FLAGS FCARG1a, IS_TYPE_IMMUTABLE, >1
		|			GC_DELREF r0
		|1:
		|			mov aword [r4], FCARG1a // save
		|			ZVAL_COPY_CTOR_FUNC (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		|			mov FCARG1a, aword [r4] // restore
		|2:
		||		}
		||	}
		||	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|		EXT_CALL increment_function, r0
		||	} else {
		|		EXT_CALL decrement_function, r0
		||	}
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, op1_def_info, r0, eax, r1
		|		TRY_ADDREF op1_def_info, ah, r1
		||	}
		|	jmp >3
		|.code
	}
	|3:
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_long_long(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t res_forward)
{
	uint32_t res_info = RES_INFO();
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);

	if (opline->opcode == ZEND_MUL &&
		((opline->op2_type == IS_CONST &&
		IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, opline->op2))) &&
		is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, opline->op2)))) ||
		(opline->op1_type == IS_CONST &&
		IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, opline->op1))) &&
		is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, opline->op1)))))) {
		if (opline->op2_type == IS_CONST) {
		|   LONG_LOAD r0, opline->op1_type, opline->op1
		|	shl r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, opline->op2)))
		} else {
		|   LONG_LOAD r0, opline->op2_type, opline->op2
		|	shl r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, opline->op1)))
		}
	} else if (opline->opcode == ZEND_DIV &&
			(opline->op2_type == IS_CONST &&
            is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, opline->op2))))) {
		|   LONG_LOAD r0, opline->op1_type, opline->op1
		| 	shr r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, opline->op2)))
	} else {
		|	LONG_LOAD r0, opline->op1_type, opline->op1
		if (same_ops && opline->opcode != ZEND_DIV) {
		|		LONG_MATH2 opline->opcode, r0, r0
		} else {
		|		LONG_MATH opline->opcode, r0, opline->op2_type, opline->op2
		}
	}
	if ((res_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) {
		if (res_forward) {
			|	SET_Z_LVAL r1 + res_forward, r0
			|	SET_Z_TYPE_INFO r1 + res_forward, IS_LONG
		} else {
			|	SET_Z_LVAL FP + opline->result.var, r0
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_LONG
		}
	} else {
		|	jo >1
		|.cold_code
		|1:
		|.if X64 or SSE
		|	SSE_LOAD_LONG xmm0, opline->op1_type, opline->op1
		|	SSE_LOAD_LONG xmm1, opline->op2_type, opline->op2
		|	SSE_MATH2 opline->opcode, xmm0, xmm1
		|.else
		|	FPU_LONG_LOAD opline->op2_type, opline->op2
		|	FPU_LONG_LOAD opline->op1_type, opline->op1
		|	FPU_MATH2 opline->opcode
		|.endif
		if (res_forward) {
			|	DOUBLE_STORE r1 + res_forward, xmm0
			|	SET_Z_TYPE_INFO r1 + res_forward, IS_DOUBLE
		} else {
			|	DOUBLE_STORE FP + opline->result.var, xmm0
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_DOUBLE
		}
		|	jmp >2
		|.code
		if (res_forward) {
			|	SET_Z_LVAL r1 + res_forward, r0
			|	SET_Z_TYPE_INFO r1 + res_forward, IS_LONG
		} else {
			|	SET_Z_LVAL FP + opline->result.var, r0
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_LONG
		}
		|2:
	}

	return 1;
}

static int zend_jit_math_long_double(dasm_State **Dst, zend_op *opline, uint32_t res_forward)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG xmm0, opline->op1_type, opline->op1
	|	SSE_MATH opline->opcode, xmm0, opline->op2_type, opline->op2
	|.else
	|	FPU_LONG_LOAD opline->op1_type, opline->op1
	|	FPU_MATH opline->opcode, opline->op2_type, opline->op2
	|.endif
	if (res_forward) {
		|	DOUBLE_STORE r1 + res_forward, xmm0
		|	SET_Z_TYPE_INFO r1 + res_forward, IS_DOUBLE
	} else {
		|	DOUBLE_STORE FP + opline->result.var, xmm0
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_DOUBLE
	}

	return 1;
}

static int zend_jit_math_double_long(dasm_State **Dst, zend_op *opline, uint32_t res_forward)
{
	|.if X64 or SSE
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL) {
	|		SSE_LOAD_LONG xmm0, opline->op2_type, opline->op2
	|		SSE_MATH opline->opcode, xmm0, opline->op1_type, opline->op1
	||	} else {
	|		SSE_LOAD xmm0, opline->op1_type, opline->op1
	|		SSE_LOAD_LONG xmm1, opline->op2_type, opline->op2
	|		SSE_MATH2 opline->opcode, xmm0, xmm1
	||	}
	|.else
	|	FPU_LONG_LOAD opline->op2_type, opline->op2
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL) {
	|		FPU_MATH opline->opcode, opline->op1_type, opline->op1
	||	} else {
	|		FPU_LOAD opline->op1_type, opline->op1
	|		FPU_MATH2 opline->opcode
	||	}
	|.endif
	if (res_forward) {
		|	DOUBLE_STORE r1 + res_forward, xmm0
		|	SET_Z_TYPE_INFO r1 + res_forward, IS_DOUBLE
	} else {
		|	DOUBLE_STORE FP + opline->result.var, xmm0
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_DOUBLE
	}

	return 1;
}

static int zend_jit_math_double_double(dasm_State **Dst, zend_op *opline, uint32_t res_forward)
{
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);

	|.if X64 or SSE
	|	SSE_LOAD xmm0, opline->op1_type, opline->op1
	if (same_ops) {
		|	SSE_MATH2 opline->opcode, xmm0, xmm0
	} else {
		|	SSE_MATH opline->opcode, xmm0, opline->op2_type, opline->op2
	}
	|.else
	|	FPU_LOAD opline->op1_type, opline->op1
	|	FPU_MATH opline->opcode, opline->op2_type, opline->op2
	|.endif
	if (res_forward) {
		|	DOUBLE_STORE r1 + res_forward, xmm0
		|	SET_Z_TYPE_INFO r1 + res_forward, IS_DOUBLE
	} else {
		|	DOUBLE_STORE FP + opline->result.var, xmm0
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_DOUBLE
	}

	return 1;
}


static int zend_jit_shift(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	zval *op2;
	uint32_t op1_info;
	zend_bool has_slow;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if ((op1_info & MAY_BE_UNDEF) ||
		opline->op2_type != IS_CONST ||
		Z_TYPE_P(RT_CONSTANT(op_array, opline->op2)) != IS_LONG ||
		Z_LVAL_P(RT_CONSTANT(op_array, opline->op2)) >= SIZEOF_ZEND_LONG * 8) {
		goto fallback;
	}

	has_slow = (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) != 0;

	op2 = RT_CONSTANT(op_array, opline->op2);

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
	|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
	}
	|	LONG_LOAD r0, opline->op1_type, opline->op1
	if (opline->opcode == ZEND_SR) {
	|	shr, r0, Z_LVAL_P(op2)
	} else {
	|	shl, r0, Z_LVAL_P(op2)
	}
	|	SET_Z_LVAL FP + opline->result.var, r0
	|	SET_Z_TYPE_INFO FP + opline->result.var, IS_LONG
	if (has_slow) {
	|2:
	}
	|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
	//END

	if (has_slow) {
		|.cold_code
		|9:
		|	lea FCARG1a, aword [FP + opline->result.var]
		|.if X64
		|	mov FCARG2a, r0
		|	mov CARG3, Z_LVAL_P(op2)
		|.else
		|	push r0
		|	push dword Z_LVAL_P(op2)
		|.endif
		if (opline->opcode == ZEND_SR) {
		|	EXT_CALL shift_right_function, r0
		} else {
		|	EXT_CALL shift_left_function, r0
		}
		|	jmp <2
		|.code
	}

	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math(dasm_State **Dst, zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow;
	uint32_t  res_forward = 0;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		goto fallback;
	}

	has_slow =
		(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		((op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) || 
		 (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))));

	if (opline->result_type == IS_TMP_VAR &&
	    (opline+1)->opcode == ZEND_SEND_VAL &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		/* Eliminate the following SEND_VAL */
		(*opnum)++;
		res_forward = (opline+1)->result.var;
		|	mov r1, EX->call
	}

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >4
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			if (op2_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
				if (!zend_jit_math_long_double(Dst, opline, res_forward)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
		}
		if (!zend_jit_math_long_long(Dst, opline, op_array, ssa, res_forward)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					if (!same_ops) {
						|	IF_NOT_Z_TYPE, FP + opline->op2.var, IS_DOUBLE, >5
					} else {
						|	IF_NOT_Z_TYPE, FP + opline->op2.var, IS_DOUBLE, >9
					}
				}
				if (!zend_jit_math_double_double(Dst, opline, res_forward)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
				}
				if (!zend_jit_math_double_long(Dst, opline, res_forward)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, res_forward)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
			if (!zend_jit_math_double_long(Dst, opline, res_forward)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, res_forward)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
			if (!zend_jit_math_long_double(Dst, opline, res_forward)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	|6:
	if (res_forward) {
		valid_opline_offset += 2;
	} else {
		valid_opline_offset++;
	}

	if (has_slow) {
		|.cold_code
		|9:
		|	mov EX->opline, IP
		if (res_forward) {
			|	lea	FCARG1a, [r1 + res_forward]
		} else {
			|	lea	FCARG1a, [FP + opline->result.var]
		}
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		|.if X64
		|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
		|.else
		|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
		|.endif
		||	if (opline->opcode == ZEND_ADD) {
		|		EXT_CALL add_function, r0
		||	} else if (opline->opcode == ZEND_SUB) {
		|		EXT_CALL sub_function, r0
		||	} else if (opline->opcode == ZEND_MUL) {
		|		EXT_CALL mul_function, r0
		||	} else if (opline->opcode == ZEND_DIV) {
		|		EXT_CALL div_function, r0
		||	} else {
		||		ZEND_ASSERT(0);
		||	}
		|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
		|	FREE_OP opline->op2_type, opline->op2, op2_info, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		|	jmp <6
		|.code
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp_long_long(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	LONG_LOAD r0, opline->op1_type, opline->op1
	|	LONG_OP cmp, r0, opline->op2_type, opline->op2
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_double_common(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jnae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jna => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	jp >1
				|	mov eax, IS_TRUE
				|	je >2
				|1:
				|	mov eax, IS_FALSE
				|2:
				break;
			case ZEND_IS_NOT_EQUAL:
				|	jp >1
				|	mov eax, IS_FALSE
				|	je >2
				|1:
				|	mov eax, IS_TRUE
				|2:
				break;
			case ZEND_IS_SMALLER:
				|	setnae al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setna al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_long_double(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG xmm0, opline->op1_type, opline->op1
	|	SSE_OP ucomisd, xmm0, opline->op2_type, opline->op2
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LONG_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_long(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD xmm0, opline->op1_type, opline->op1
	|	SSE_LOAD_LONG xmm1, opline->op2_type, opline->op2
	|	ucomisd xmm0, xmm1
	|.else
	|	FPU_LONG_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_double(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD xmm0, opline->op1_type, opline->op1
	|	SSE_OP ucomisd, xmm0, opline->op2_type, opline->op2
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_slow(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	cmp aword [FP + opline->result.var], 0
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	has_slow =
		(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		((op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) || 
		 (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))));

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >4
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			if (op2_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
				if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
		}
		if (!zend_jit_cmp_long_long(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					if (!same_ops) {
						|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >5
					} else {
						|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
					}
				}
				if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
				}
				if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
			if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
			if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	if (has_slow ||
	    (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
	    (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE)))) {
		if (has_slow) {
			|.cold_code
			|9:
		}
		|	mov EX->opline, IP
		if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
			|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			|1:
		}
		|	lea	FCARG1a, [FP + opline->result.var]
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		|.if X64
		|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
		|.else
		|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
		|.endif
		|	EXT_CALL compare_function, r0
		||	if (opline->opcode != ZEND_CASE) {
		|		FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
		||	}
		|	FREE_OP opline->op2_type, opline->op2, op2_info, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		if (!zend_jit_cmp_slow(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (has_slow) {
			|	jmp >6
			|.code
		}
	}

	|6:
	if (((opline+1)->opcode == ZEND_JMPZ || (opline+1)->opcode == ZEND_JMPNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		valid_opline_offset += 2;
	} else {
		valid_opline_offset++;
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_simple_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t var, uint32_t var_info, zend_uchar val_type, znode_op val, uint32_t val_info, int in_cold, uint32_t var2)
{
	if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);
		if (var2 == (uint32_t)-1) {
			|	ZVAL_COPY_CONST FP + var, var_info, zv, r0
		} else {
			|	ZVAL_COPY_CONST_2 FP + var, FP + var2, var_info, zv, r0
		}
		||	if (Z_REFCOUNTED_P(zv)) {
// TODO: += 2
		|		ADDREF_CONST zv, r0
		||	}
	} else {
		if (val_info & MAY_BE_UNDEF) {
			if (in_cold) {
				|	IF_NOT_Z_TYPE FP + val.var, IS_UNDEF, >2
			} else {
				|	IF_Z_TYPE FP + val.var, IS_UNDEF, >1
				|.cold_code
				|1:
			}
			|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
			|	mov FCARG1d, val.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|	SET_Z_TYPE_INFO FP + val.var, IS_NULL
			|	jmp	>3
			if (in_cold) {
				|2:
			} else {
				|.code
			}
		}
		if (val_info & MAY_BE_REF) {
			if (val_type == IS_CV) {
				|	lea r2, [FP + val.var]
				|	ZVAL_DEREF r2, val_info
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE FP + var, r2, val_info, r0, eax, r1
				} else {
					|	ZVAL_COPY_VALUE_2 FP + var, FP + var2, r2, val_info, r0, eax, r1
				}
			} else {
				if (in_cold) {
					|	IF_NOT_Z_TYPE FP + val.var, IS_REFERENCE, >1
				} else {
					|	IF_Z_TYPE FP + val.var, IS_REFERENCE, >1
					|.cold_code
					|1:
				}
				|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
				|	GET_Z_PTR r0, FP + val.var
				|	// ZVAL_COPY_VALUE(return_value, &ref->value);
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE FP + var, r0 + 8, val_info, r2, edx, r1
				} else {
					|	ZVAL_COPY_VALUE_2 FP + var, FP + var2, r0 + 8, val_info, r2, edx, r1
				}
				|	GC_DELREF r0
				|	je >2
				|	IF_NOT_REFCOUNTED dh, >3
				if (var2 == (uint32_t)-1) {
					|	GC_ADDREF r1
				} else {
					|	add dword [r1], 2
				}
				|	jmp >3
				|2:
				if (var2 != (uint32_t)-1) {
					|	IF_NOT_REFCOUNTED dh, >2
					|	GC_ADDREF r1
					|2:
				}
				|	EFREE_SIZE r0, sizeof(zend_reference), op_array, opline
				|	jmp >3
				if (in_cold) {
					|1:
				} else {
					|.code
				}
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE FP + var, FP + val.var, val_info, r0, eax, r1
				} else {
					|	ZVAL_COPY_VALUE_2 FP + var, FP + var2, FP + val.var, val_info, r0, eax, r1
				}
			}
		} else {
			if (var2 == (uint32_t)-1) {
				|	ZVAL_COPY_VALUE FP + var, FP + val.var, val_info, r0, eax, r1
			} else {
				|	ZVAL_COPY_VALUE_2 FP + var, FP + var2, FP + val.var, val_info, r0, eax, r1
			}
		}
		if (val_type == IS_CV) {
			if (var2 == (uint32_t)-1) {
				|	TRY_ADDREF val_info, ah, r1
			} else {
				|	TRY_ADDREF_2 val_info, ah, r1
			}
		} else {
			if (var2 != (uint32_t)-1) {
				|	TRY_ADDREF val_info, ah, r1
			}
		}
		|3:
	}
	return 1;
}

static int zend_jit_qm_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info = OP1_INFO();

	valid_opline_offset++;
	return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->result.var, -1, opline->op1_type, opline->op1, op1_info, 0, -1);
}

static int zend_jit_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		goto fallback;
	}

	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
		if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
			|	IF_Z_REFCOUNTED FP + opline->op1.var, >1
			|.cold_code
			|1:
		}
		|	// TODO: support for object->set
		|	// TODO: support for assignment to itself
		|	GET_Z_PTR r0, FP + opline->op1.var
		|	GC_DELREF r0
		|	jnz >4
		|	mov aword [r4], r0 // save
		if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info,
				(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) != 0,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
			return 0;
		}
		|	mov FCARG1a, aword [r4] // restore
		|	ZVAL_DTOR_FUNC (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		|	jmp >6
		|4:
		|	IF_NOT_Z_FLAGS FP + opline->op1.var, IS_TYPE_COLLECTABLE, >5
		|	GET_Z_PTR FCARG1a, FP + opline->op1.var
		|	IF_GC_INFO FCARG1a, >5
		|	EXT_CALL gc_possible_root, r0
		if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
			|	jmp >5
			|.code
		}
		|5:
	}

	if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info, 0,
			opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
		return 0;
	}
	|6:

	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_push_call_frame(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_function *func)
{
	if (!func) {
		assert(0);
	}

	uint32_t used_stack = zend_vm_calc_used_stack(opline->extended_value, func);

	|	// if (UNEXPECTED(used_stack > (size_t)(((char*)EG(vm_stack_end)) - (char*)call))) {
	|	mov r1, aword [&EG(vm_stack_top)]
	|	mov r2, aword [&EG(vm_stack_end)]
	|	sub r2,r1
	|	cmp r2, used_stack
	|	jb >2
	|	// EG(vm_stack_top) = (zval*)((char*)call + used_stack);
	|	add aword [&EG(vm_stack_top)], used_stack
	|	// zend_vm_init_call_frame(call, call_info, func, num_args, called_scope, object);
	|	// call->func = func;
	|	mov aword EX:r1->func, r0
	|	// ZEND_SET_CALL_INFO(call, 0, call_info);
	|	mov dword EX:r1->This.u1.type_info, (IS_UNDEF | (ZEND_CALL_NESTED_FUNCTION << ZEND_CALL_INFO_SHIFT))
	|1:
	|	// Z_CE(call->This) = called_scope;
	|	mov aword EX:r1->This.value.ptr, 0
	|	// ZEND_CALL_NUM_ARGS(call) = num_args;
	|	mov dword EX:r1->This.u2.num_args, opline->extended_value
	|.cold_code
	|2:
	|	mov FCARG1d, used_stack
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_extend_stack_helper, r0
	|	mov r1, r0
	|	jmp <1
	|.code

	return 1;
}

static int zend_jit_init_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_function *func = NULL;

	if (info) {
		zend_call_info *call_info = info->callee_info;

		while (call_info && call_info->caller_init_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|	LOAD_ADDR r0, func
	} else if (func && op_array == &func->op_array) {
		/* recursive call */
		|	mov r0,	EX->func
	} else {
		zval *zv = RT_CONSTANT(op_array, opline->op2);

		|	// if (CACHED_PTR(Z_CACHE_SLOT_P(fname)))
		|	mov r0,	EX->run_time_cache
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
		|	test r0, r0
		|	jz >1
		|.cold_code
		|1:
		|	// SAVE_OPLINE();
		|	mov EX->opline, IP
		|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
		|	EXT_CALL zend_jit_find_func_helper, r0
		|	// This opcode must not throw exception ???
		|		// test r0, r0
		|		// jz ->exception_handler */
		|	// CACHE_PTR(Z_CACHE_SLOT_P(fname), fbc);
		|	mov r1,	EX->run_time_cache
		|	mov aword [r1 + Z_CACHE_SLOT_P(zv)], r0
		|	jmp >3
		|.code
		|3:
	}
	if (!zend_jit_push_call_frame(Dst, opline, op_array, func)) {
		return 0;
	}
	|	// call->prev_execute_data = EX(call);
	if (call_level == 1) {
		|	mov aword EX:r1->prev_execute_data, 0
	} else {
		|	mov r0, EX->call
		|	mov EX:r1->prev_execute_data, r0
	}
	|	// EX(call) = call;
	|	mov EX->call, r1
	valid_opline_offset++;

	return 1;
}

static int zend_jit_do_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;
	uint32_t i;

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_call_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (!func ||
	    func->type != ZEND_USER_FUNCTION ||
	    call_info->num_args > func->op_array.num_args ||
	    (opline-1)->opcode == ZEND_SEND_UNPACK ||
	    (func->op_array.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0) {
		goto fallback;
	}

	|	// call = EX(call);
	|	mov r1, EX->call
	|	// fbc = call->func;
	|	// mov r2, EX:r1->func ???
	|	// SAVE_OPLINE();
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	mov EX->opline, IP
	||	if (call_level == 1) {
	|		mov aword EX->call, 0
	||	} else {
	|		//EX(call) = call->prev_execute_data;
	|		mov r0, EX:r1->prev_execute_data
	|		mov EX->call, r0
	||	}
	|	//call->prev_execute_data = execute_data;
	|	mov EX:r1->prev_execute_data, EX
	|
	|	// EX(call) = NULL;
	|	mov aword EX:r1->call, 0
	||	if (RETURN_VALUE_USED(opline)) {
	|		// ZVAL_NULL(EX_VAR(opline->result.var));
	|		SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
	|		// EX(return_value) = EX_VAR(opline->result.var);
	|		lea r0, aword [FP + opline->result.var]
	|		mov aword EX:r1->return_value, r0
	||	} else {
	|		// EX(return_value) = 0;
	|		mov aword EX:r1->return_value, 0
	||	}
	|
	||	for (i = call_info->num_args; i < func->op_array.last_var; i++) {
	||		uint32_t n = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
	|		SET_Z_TYPE_INFO r1 + n, IS_UNDEF
	||	}
	|
	|	//EX_LOAD_RUN_TIME_CACHE(op_array);
	||	if (!func || func->op_array.cache_size) {
	||		if (func && op_array == &func->op_array) {
	||			/* recursive call */
	||			if (func->op_array.cache_size > sizeof(void*)) {
	|				mov r0, EX->run_time_cache
	|				mov EX:r1->run_time_cache, r0
	||			}
	||		} else {
	|			mov r2, EX:r1->func
	|			mov r0, aword [r2 + offsetof(zend_op_array, run_time_cache)]
	|			mov EX:r1->run_time_cache, r0
	||		}
	||	}
	|	//EX_LOAD_LITERALS(op_array);
	|.if X64
	|	LOAD_ADDR r0, func->op_array.literals
	|	mov EX:r1->literals, r0
	|.endif
	|	// EG(current_execute_data) = execute_data;
	|	mov aword [&EG(current_execute_data)], r1
	|	mov FP, r1
	|	// EX(opline) = op_array->opcodes;
	|	LOAD_ADDR IP, (func->op_array.opcodes + call_info->num_args)
	|	mov EX:r1->opline, IP
	||	if (func && op_array == &func->op_array) {
	||		/* recursive call */
	|		jmp =>call_info->num_args
	||	} else {
	|		add r4, SPAD // stack alignment
	|		jmp aword [IP]
	||	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	if (opline->opcode == ZEND_DO_FCALL ||
	    opline->opcode == ZEND_DO_UCALL ||
	    opline->opcode == ZEND_DO_FCALL_BY_NAME ){
		return zend_jit_call(Dst, opline);
	} else {
		return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
	}
}

static int zend_jit_send_val(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	uint32_t arg_num = opline->op2.num;

	if (opline->opcode == ZEND_SEND_VAL_EX && arg_num > MAX_ARG_FLAG_NUM) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	|	mov r1, EX->call

	if (opline->opcode == ZEND_SEND_VAL_EX) {
		uint32_t mask = ZEND_SEND_BY_REF << ((arg_num + 3) * 2);

		|	mov r0, EX:r1->func
		if (arg_num <= MAX_ARG_FLAG_NUM) {
			|	mov eax, dword [r0 + offsetof(zend_function, quick_arg_flags)]
			|	test eax, mask
			|	jnz	>1
		} else {
			ZEND_ASSERT(0);
		}
		|.cold_code
		|1:
		|	SET_Z_TYPE_INFO r1 + opline->result.var, IS_UNDEF
		|	mov EX->opline, IP
		|.if X64
		|	mov CARG1, 0
		|	LOAD_ADDR CARG2, "Cannot pass parameter %d by reference"
		|	mov CARG3d, arg_num
		|	EXT_CALL zend_throw_error, r0
		|.else
		|	sub r4, 4
		|	push arg_num
		|	push "Cannot pass parameter %d by reference"
		|	push 0
		|	EXT_CALL zend_throw_error, r0
		|	add r4, 16
		|.endif
		|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
		|	jmp ->exception_handler
		|.code
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);

		|	ZVAL_COPY_CONST r1 + opline->result.var, -1, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
	} else {
		|	ZVAL_COPY_VALUE r1 + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
	}
	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_send_var(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	if (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		// TODO: support for references ???
		goto fallback;
	}

	op1_info = OP1_INFO();
	|	mov r1, EX->call
	|	ZVAL_COPY_VALUE r1 + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
	||	if (opline->op1_type == IS_CV) {
	|		TRY_ADDREF op1_info, ah, r2
	||	}
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_type_check(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, mask;
	unsigned int target_label;
	zend_uchar type;

	if (!ssa->ops || !ssa->var_info || opline->extended_value == IS_RESOURCE) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	type = opline->extended_value;
	if (type == IS_RESOURCE) {
		goto fallback;
	} else if (type == _IS_BOOL) {
		mask = MAY_BE_FALSE | MAY_BE_TRUE;
	} else {
		mask = (1 << type);
	}
	if (!(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF|MAY_BE_REF) - mask))) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			valid_opline_offset++;
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
			valid_opline_offset++;
		}
    } else if (!(op1_info & mask)) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			valid_opline_offset += 2;
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
			valid_opline_offset++;
		}
	} else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_free_compiled_variables(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
    uint32_t i, j, info;

	// Use type inference to avoid useless zval_ptr_dtor()
	for (i = 0 ; i < op_array->last_var; i++) {
		if (ssa->vars && ssa->var_info) {
			info = ssa->var_info[i].type;
			for (j = op_array->last_var; j < ssa->vars_count; j++) {
				if (ssa->vars[j].var == i) {
					info |= ssa->var_info[j].type;
				}
			}
		} else {
			info = MAY_BE_RC1 | MAY_BE_RCN | MAY_BE_REF | MAY_BE_ANY | MAY_BE_UNDEF;
		}

		if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
			uint32_t offset = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
			| ZVAL_PTR_DTOR FP + offset, info, 1, (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		}
	}
	return 1;
}

static int zend_jit_leave_func(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	// Avoid multiple leave sequnces
	if (jit_return_label >= 0) {
		| jmp =>jit_return_label
		return 1;
	}

	jit_return_label = ssa->cfg.blocks_count * 2;

	|=>jit_return_label:

	// i_free_compiled_variables(execute_data);
	if (!zend_jit_free_compiled_variables(Dst, opline, op_array, ssa)) {
		return 0;
	}

	|	movzx FCARG1d, byte [FP + offsetof(zend_execute_data, This.u1.type_info) + 2]
	|	test FCARG1d, (ZEND_CALL_TOP|ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_ALLOCATED)
	|	jnz ->leave_function_handler
	|	// EG(current_execute_data) = EX(prev_execute_data);
	|	mov r0, EX->prev_execute_data
	|	mov aword [&EG(current_execute_data)], r0
	|	// if (call_info & ZEND_CALL_RELEASE_THIS)
	if (op_array->scope) {
		|	test FCARG1d, ZEND_CALL_RELEASE_THIS
		if (op_array->fn_flags & ZEND_ACC_STATIC) {
			|	jnz >1
			|.cold_code
			|1:
		} else {
			|	je >2
		}
		|	// zend_object *object = Z_OBJ(execute_data->This);
		|	mov r0, EX->This.value.obj
		if (op_array->scope && op_array->scope->constructor == (zend_function*)op_array) {
			|	// if (UNEXPECTED(EG(exception) != NULL)
			|	cmp aword [&EG(exception)], 0
			|	jne >6
			|.cold_code
			|6:
			|	// if (call_info & ZEND_CALL_CTOR)
			|	test FCARG1d, ZEND_CALL_CTOR
			|	jz >5
			|	// GC_REFCOUNT(object)--;
			|	GC_DELREF r0
			|	// zend_object_store_ctor_failed(object);
			|.if X64
			|	mov CARG1, r0
			|	EXT_CALL zend_object_store_ctor_failed, r0
			|.else
			|	sub r4, 12
			|	push r0
			|	EXT_CALL zend_object_store_ctor_failed, r0
			|	add r4, 16
			|.endif
			|	// reload registers
			|	mov r0, EX->This.value.obj
			|	jmp >5
			|.code
			|5:
		}
		|	// OBJ_RELEASE(object);
		|	OBJ_RELEASE r0, >4
		|	jmp >4
		if (op_array->fn_flags & ZEND_ACC_STATIC) {
			|.code
		} else {
			|2:
		}
	}
	|	test FCARG1d, ZEND_CALL_CLOSURE
	|	jnz >3
	|.cold_code
	|3:
	|	// OBJ_RELEASE((zend_object*)execute_data->func->op_array.prototype);
	|	mov r0, EX->func
	|	mov r0, aword [r0 + offsetof(zend_op_array, prototype)]
	|	OBJ_RELEASE r0, >4
	|	jmp >4
	|.code
	|4:
	|	// EG(vm_stack_top) = (zval*)execute_data;
	|	mov aword [&EG(vm_stack_top)], FP
	|	// execute_data = EX(prev_execute_data);
	|	mov FP, EX->prev_execute_data
	|	// if (EG(exception))
	|	cmp aword [&EG(exception)], 0
	|	mov IP, EX->opline
	|	jne ->leave_throw_handler
	|	// EX(opline)++
	|	add IP, sizeof(zend_op)
	|	mov EX->opline, IP
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_return(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (op_array->type == ZEND_EVAL_CODE || !op_array->function_name || !ssa->ops || !ssa->var_info) {
		// TODO: support for top-level code
		return zend_jit_tail_handler(Dst, opline);
	}

	op1_info = OP1_INFO();
	if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
		// TODO: support for IS_UNDEF ???
		return zend_jit_tail_handler(Dst, opline);
	}

	// if (!EX(return_value))
	|	mov r1, EX->return_value
	|	test r1, r1
	if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
	    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	jz >1
		|.cold_code
		|1:
		||	if (jit_return_label >= 0) {
		|		IF_NOT_Z_REFCOUNTED FP + opline->op1.var, =>jit_return_label
		||	} else {
		|		IF_NOT_Z_REFCOUNTED FP + opline->op1.var, >9
		||	}
		|	GET_Z_PTR FCARG1a, FP + opline->op1.var
		|	GC_DELREF FCARG1a
		||	if (jit_return_label >= 0) {
		|		jnz =>jit_return_label
		||	} else {
		|		jnz >9
		||	}
		|	//SAVE_OPLINE()
		|	mov EX->opline, IP
		|	ZVAL_DTOR_FUNC (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		|	mov r1, EX->return_value // reload ???
		||	if (jit_return_label >= 0) {
		|		jmp =>jit_return_label
		||	} else {
		|		jmp >9
		||	}
		|.code
	} else {
		||	if (jit_return_label >= 0) {
		|		jz =>jit_return_label
		||	} else {
		|		jz >9
		||	}
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);
		|	ZVAL_COPY_CONST r1, -1, zv, r0
		if (Z_REFCOUNTED_P(zv)) {
		|	ADDREF_CONST zv, r0
		}
	} else if (opline->op1_type == IS_TMP_VAR) {
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
	} else if (opline->op1_type == IS_CV) {
		if (op1_info & MAY_BE_REF) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >1
			|.cold_code
			|1:
			|	// retval_ptr = Z_REFVAL_P(retval_ptr);
			|	GET_Z_PTR r0, FP + opline->op1.var
			|	//	ZVAL_COPY(return_value, retval_ptr);
			|	GET_Z_TYPE_INFO edx, r0 + offsetof(zend_reference, val)
			|	SET_Z_TYPE_INFO r1, edx
			|	IF_REFCOUNTED dh, >2
			|.if X64
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|.else
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|	GET_Z_W2 r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_W2 r1, r2
			|.endif
			|	jmp >3
			|2:
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|	GC_ADDREF r2
			|	jmp >3
			|.code
		}
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
		|	// TODO: JIT: if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) ZVAL_NULL(retval_ptr); ???
		|	TRY_ADDREF op1_info, ah, r2
		|3:
	} else {
		if (op1_info & MAY_BE_REF) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >1
			|.cold_code
			|1:
			|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
			|	GET_Z_PTR r0, FP + opline->op1.var
			|	// ZVAL_COPY_VALUE(return_value, &ref->value);
			|.if X64
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|.else
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|	GET_Z_W2 r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_W2 r1 + 4, r2
			|.endif
			|	GET_Z_TYPE_INFO edx, r0 + offsetof(zend_reference, val)
			|	SET_Z_TYPE_INFO r1, edx
			|	GC_DELREF r0
			|	je >2
			|	// if (IS_REFCOUNTED())
			||	if (jit_return_label >= 0) {
			|		IF_NOT_REFCOUNTED dh, =>jit_return_label
			||	} else {
			|		IF_NOT_REFCOUNTED dh, >9
			||	}
			|	// ADDREF
			|	GET_Z_PTR r2, r1
			|	GC_ADDREF r2
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|2:
			|	EFREE_SIZE r0, sizeof(zend_reference), op_array, opline
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|.code
		}
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
	}

	|9:
	//JIT: ZEND_VM_DISPATCH_TO_HELPER(zend_leave_helper);
	return zend_jit_leave_func(Dst, opline, op_array, ssa);
}

static int zend_jit_fetch_dim_read(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, res_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	res_info = RES_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
		if (op2_info & MAY_BE_LONG) {
			if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) {
				|	// if (EXPECTED(Z_TYPE_P(dim) == IS_LONG))
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
			}
			|	// hval = Z_LVAL_P(dim);
			|	LONG_LOAD FCARG2a, opline->op2_type, opline->op2

			if (opline->op2_type == IS_CONST) {
				zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));
				if (val >= 0 && val < HT_MAX_SIZE) {
					|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
					|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
					|	jz >1 // HASH_FIND
					|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed))
					|.if X64
					|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
					|	cmp r0, val
					|.else
					|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], val
					|.endif
					|	jle >2 // NOT_FOUND
					|	// _ret = &_ht->arData[_h].val;
					|	mov r0, aword [FCARG1a + offsetof(zend_array, arData)]
					|	add r0, val * sizeof(Bucket)
					|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8 //FOUND
					|	jmp >2 // NOT_FOUND
				}
			} else {
				|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
				|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
				|	jz >1 // HASH_FIND
				|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed))
				|.if X64
				|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
				|	cmp r0, FCARG2a
				|.else
				|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], FCARG2a
				|.endif
				|	jle >2 // NOT_FOUND
				|	// _ret = &_ht->arData[_h].val;
				|.if X64
				|	shl FCARG2a, 5
				|.else
				|	imul FCARG2a, sizeof(Bucket)
				|.endif
				|	mov r0, aword [FCARG1a + offsetof(zend_array, arData)]
				|	add r0, FCARG2a
				|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8 // FOUND
				|	jmp >2 // NOT_FOUND
			}
			|1:
			|	EXT_CALL zend_hash_index_find, r0
			|	test r0, r0
			|	jz >2 // NOT_FOUND
			|.cold_code
			|2:
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	// zend_error(E_NOTICE,"Undefined offset: " ZEND_LONG_FMT, hval);
				|.if X64
				|	mov CARG1, E_NOTICE
				|	LOAD_ADDR CARG2, "Undefined offset: " ZEND_LONG_FMT
				|	LONG_LOAD CARG3, opline->op2_type, opline->op2
				|	EXT_CALL zend_error, r0
				|.else
				|	sub r4, 4
				|	LONG_LOAD r0, opline->op2_type, opline->op2
				|	push r0
				|	push "Undefined offset: " ZEND_LONG_FMT
				|	push E_NOTICE
				|	EXT_CALL zend_error, r0
				|	add r4, 16
				|.endif
			}
			|	// retval = &EG(uninitialized_zval);
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
			|	jmp >9 // END
			|.code
			if (op2_info & (MAY_BE_ANY - MAY_BE_STRING)) {
				|	jmp >8 // FOUND
			}
			if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) {
				|3:
			}
		}
		if (op2_info & MAY_BE_STRING) {
			if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
				|	// if (EXPECTED(Z_TYPE_P(dim) == IS_STRING))
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_STRING, >3
			}
			|	// offset_key = Z_STR_P(dim);
			|	LONG_LOAD FCARG2a, opline->op2_type, opline->op2
			|	// retval = zend_hash_find(ht, offset_key);
			if (opline->op2_type != IS_CONST) {
				|	EXT_CALL zend_jit_symtable_find, r0
			} else {
				|	EXT_CALL zend_hash_find, r0
			}
			|	test r0, r0
			|	jz >2 // NOT_FOUND
			|	// if (UNEXPECTED(Z_TYPE_P(retval) == IS_INDIRECT))
			|	IF_Z_TYPE r0, IS_INDIRECT, >1 // SLOW
			|.cold_code
			|1:
			|	//	retval = Z_INDIRECT_P(retval);
			|	GET_Z_PTR r0, r0
			|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8 // COPY
			|2:
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				//	zend_error(E_NOTICE, "Undefined index: %s", ZSTR_VAL(offset_key));
				|.if X64
				|	mov CARG1, E_NOTICE
				|	LOAD_ADDR CARG2, "Undefined index: %s"
				|	LONG_LOAD CARG3, opline->op2_type, opline->op2
				|	add CARG3, offsetof(zend_string, val)
				|	EXT_CALL zend_error, r0
				|.else
				|	sub r4, 4
				|	LONG_LOAD r0, opline->op2_type, opline->op2
				|	add r0, offsetof(zend_string, val)
				|	push r0
				|	push "Undefined index: %s"
				|	push E_NOTICE
				|	EXT_CALL zend_error, r0
				|	add r4, 16
				|.endif
			}
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
			|	jmp >9 // END
			|.code
			if (op2_info & (MAY_BE_ANY - (MAY_BE_LONG|MAY_BE_STRING))) {
				|	jmp >8 // FOUND
			}
		}
		if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
			if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
				|.cold_code
				|3:
			}
			|	SAVE_VALID_OPLINE
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
				|.code
			}
		}
	}

	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_ARRAY)) {
		if (op1_info & MAY_BE_ARRAY) {
			|.cold_code
			|7:
		}

		if (op1_info & MAY_BE_STRING) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING))) {
			    if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_STRING, >6
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_STRING, >6
			    }
			}
			|	SAVE_VALID_OPLINE
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_str_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_str_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			|6:
		}

		if (op1_info & MAY_BE_OBJECT) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_OBJECT))) {
			    if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_OBJECT, >6
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_OBJECT, >6
			    }
			}
			|	SAVE_VALID_OPLINE
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_obj_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_obj_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			|6:
		}

		if (opline->opcode != ZEND_FETCH_DIM_IS && (op1_info & MAY_BE_UNDEF)) {
		    if (op1_info & MAY_BE_REF) {
				|	IF_NOT_Z_TYPE FCARG1a, IS_UNDEF, >1
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
		    }
			|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
			|	mov FCARG1d, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		if (op2_info & MAY_BE_UNDEF) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_UNDEF, >1
			|	mov FCARG1d, opline->op2.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
		|	jmp >9 // END
		if (op1_info & MAY_BE_ARRAY) {
			|.code
		}
	}

	|8:
	if (res_info & MAY_BE_REF) {
	|	// ZVAL_COPY_UNREF
	|	IF_NOT_Z_REFCOUNTED r0, >2
	|	GET_Z_PTR r1, r0
	|	IF_NOT_Z_TYPE r0, IS_REFERENCE, >1
	|	cmp dword [r1], 1
	|	jne >1
	|	lea FCARG1a, [FP + opline->result.var]
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_zval_copy_unref_helper, r0
	|	jmp >9
	|1:
	|	GC_ADDREF r1
	|2:
	|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
	} else  {
	|	// ZVAL_COPY
	|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
	|	TRY_ADDREF res_info, ch, r2
	}
	|9: // END

	|	FREE_OP opline->op2_type, opline->op2, op2_info, op_array, opline->lineno
	|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno

	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}

	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_bind_global(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	zval *varname = RT_CONSTANT(op_array, opline->op2);

	if (!ssa->ops || !ssa->var_info) {
		op1_info = MAY_BE_ANY|MAY_BE_REF;
	} else {
		op1_info = OP1_INFO();
	}

	//idx = (uint32_t)(uintptr_t)CACHED_PTR(Z_CACHE_SLOT_P(varname)) - 1;
	|	mov	r0, EX->run_time_cache
	|	mov r0, aword [r0 + Z_CACHE_SLOT_P(varname)]
	|	dec r0
	//if (EXPECTED(idx < EG(symbol_table).nNumUsed))
	|	cmp r0, [&EG(symbol_table).nNumUsed]
	|	jae >9
	//Bucket *p = EG(symbol_table).arData + idx;
	|.if X64
	|	shl r0, 5
	|.else
	|	imul r0, sizeof(Bucket)
	|.endif
	|.if X64
	|	LOAD_ADDR r1, &EG(symbol_table.arData)
	|	add r0, [r1]
	|.else
	|	add r0, [&EG(symbol_table).arData]
	|.endif
	|	IF_Z_TYPE r0, IS_UNDEF, >9
	//	(EXPECTED(p->key == Z_STR_P(varname))
	|	LOAD_ADDR r1, Z_PTR_P(varname)
	|	cmp [r0 + offsetof(Bucket, key)], r1
	|	jne >1
	|.cold_code
	|1:
	//(EXPECTED(p->h == ZSTR_H(Z_STR_P(varname)))
	|.if X64
	|	mov64 r1, ZSTR_H(Z_STR_P(varname))
	|	cmp qword [r0 + offsetof(Bucket, h)], r1
	|.else
	|	cmp dword [r0 + offsetof(Bucket, h)], ZSTR_H(Z_STR_P(varname))
	|.endif
	|	jne >9
	//EXPECTED(p->key != NULL)
	|	mov r1, [r0 + offsetof(Bucket, key)]
	|	test r1, r1
	|	jz >9
	//EXPECTED(ZSTR_LEN(p->key) == Z_STRLEN_P(varname))
	|	cmp dword [r1 + offsetof(zend_string, len)], Z_STRLEN_P(varname)
	|	jne >9
	//EXPECTED(memcmp(ZSTR_VAL(p->key), Z_STRVAL_P(varname), Z_STRLEN_P(varname)) == 0)
	|	add r1, offsetof(zend_string, val)
	|	mov [r4], r0
	|.if X64
	|	mov CARG1, r1
	|	LOAD_ADDR CARG2, Z_STRVAL_P(varname)
	|	mov CARG3, Z_STRLEN_P(varname)
	|	call &memcmp
	|.else
	|	sub r4, 4
	|	push r1
	|	push Z_STRVAL_P(varname)
	|	push Z_STRLEN_P(varname)
	|	call &memcmp
	|	add r4, 16
	|.endif
	|	test al, al
	|	mov r0, aword [r4]
	|	jnz >9
	|	jmp >2
	|.code
	|2:
	// if (UNEXPECTED(Z_TYPE_P(value) == IS_INDIRECT))
	|	mov cl, byte [r0 + 8]
	|	cmp cl, IS_INDIRECT
	|	je >1
	|.cold_code
	|1:
	//value = Z_INDIRECT_P(value)
	|	mov r0, [r0]
	|	mov cl, byte [r0 + 8]
	|	cmp cl, IS_UNDEF
	|	jne >2
	|	SET_Z_TYPE_INFO r0, IS_NULL
	|	jmp >8
	|.code
	|2:
	|	cmp cl, IS_REFERENCE
	|	jne >8
	|1:
	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		//stash this for later use
	|	mov r2, r0
	}
	|	GET_Z_PTR r0, r0
	|	GC_ADDREF r0
	//if (UNEXPECTED(Z_REFCOUNTED_P(variable_ptr)))
	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		if (op1_info & (MAY_BE_ANY - (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	IF_Z_REFCOUNTED FP + opline->op1.var, >2
		}
		|.cold_code
		//zval_dtor_func(Z_COUNTED_P(variable_ptr))
		|2:
		//if (EXPECTED(variable_ptr != value))
		|	lea FCARG1a, aword [FP + opline->op1.var]
		|	cmp FCARG1a, r2
		|	je >4
		|	GET_Z_PTR FCARG1a, FCARG1a
		|	GC_DELREF FCARG1a
		if (op1_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
		|	jnz >3
		} 
		|	mov aword [r4], r0 // save
		|	ZVAL_DTOR_FUNC (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		|	mov r0, aword [r4] // restore
		|	jmp >5
		if (op1_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
		|3:
		// GC_ZVAL_CHECK_POSSIBLE_ROOT(variable_ptr)
		|	IF_NOT_Z_REFCOUNTED FP + opline->op1.var, >5
		|	IF_GC_INFO FCARG1a, >5
		|	mov aword [r4], r0 //save
		|	EXT_CALL gc_possible_root, r1
		|	mov r0, aword [r4] // restore
		|	jmp >5
		}
		|4:
		|	GET_Z_PTR FCARG1a, FCARG1a
		|	GC_DELREF FCARG1a
		|	jmp >5
		|.code
	}
	|5:
	//ZVAL_REF(variable_ptr, ref)
	|	SET_Z_PTR FP + opline->op1.var, r0
	|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_REFERENCE_EX
	//END of handler

	|.cold_code
	|8:
	|	mov FCARG1a, r0
	|	EXT_CALL zend_jit_new_ref_helper, r0
	|	jmp <1
	|9:
	|	mov FCARG1a, FP
	|	LOAD_ADDR FCARG2a, (ptrdiff_t)varname
	|	EXT_CALL zend_jit_fetch_global_helper, r0
	|	jmp <1
	|.code

	valid_opline_offset++;

	return 1;
}

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
