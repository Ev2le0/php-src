/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,     r14
 |.define IP,     r15
 |.define IPl,    r15d
 |.define CARG1,  rdi       // x64/POSIX C call arguments.
 |.define CARG2,  rsi
 |.define CARG3,  rdx
 |.define CARG4,  rcx
 |.define CARG5,  r8
 |.define CARG6,  r9
 |.define CARG1d, edi
 |.define CARG2d, esi
 |.define CARG3d, edx
 |.define CARG4d, ecx
 |.define CARG5d, r8d
 |.define CARG6d, r9d
 |.define FCARG1, CARG1d    // Simulate x86 fastcall.
 |.define FCARG2, CARG2d
 |.define SPAD,   8
|.else
 |.define FP,     esi
 |.define IP,     edi
 |.define IPl,    edi
 |.define FCARG1, ecx       // x86 fastcall arguments.
 |.define FCARG2, edx
 |.define SPAD,   12
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_opline, IP

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code

|.macro load_addr, reg, addr
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.endmacro


static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|	load_addr rax, zend_timeout
	|	call rax
	|.else
	|	push 0
	|	call &zend_timeout
	|.endif
	|1:
	|	//} else if (zend_interrupt_function) {
	|	mov r0, aword [zend_interrupt_function]
	|	test r0, r0
	|	je >2
	|	//SAVE_OPLINE();
	|	mov EX->opline, IP
	|	//zend_interrupt_function(execute_data);
	|.if X64
	|	mov CARG1, FP
	|.else
	|	push FP
	|.endif
	|	call r0
	|	//ZEND_VM_ENTER();
	|		//execute_data = EG(current_execute_data);
	|	mov FP, aword [&EG(current_execute_data)]
	|		// LOAD_OPLINE();
	|	mov IP, EX->opline
	|	//}
	|2:
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|.if X64
	|	load_addr rax, EG(exception_op)->handler
	|	jmp rax
	|.else
	|	jmp &(EG(exception_op)->handler)
	|.endif

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline)
{
	const void *handler = opline->handler;

	|.if X64
	|	load_addr rax, handler
	|	call rax
	|.else
	|	call aword &handler
	|.endif
	zend_jit_check_exception(Dst);
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	const void *handler = opline->handler;

	|	add r4, SPAD // stack alignment
	|.if X64
	|	load_addr rax, handler
	|	jmp rax
	|.else
	|	jmp aword &handler
	|.endif
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst, uint32_t skip)
{
	|	add IP, sizeof(zend_op) * skip
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	|.if X64
	|	load_addr IP, target_opline
	|.else
	|	mov IP, target_opline
	|.endif
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jnz =>target_label
	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	jz =>next_label
	|	cmp IPl, target_opline
	|	jz =>target_label
	return 1;
}

static int zend_jit_recv(dasm_State **Dst, zend_op *opline)
{
	|	cmp IPl, opline
	|	jnz >1
	zend_jit_handler(Dst, opline);
	|1:
	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jz >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline)) return 0;
	if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL)) {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jnz >1
		zend_jit_call(Dst, next_opline);
		|1:
	}
	return 1;
}

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
