/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  |          Xinchen Hui <xinchen.h@zend.com>                            |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,      r14
 |.define IP,      r15
 |.define IPl,     r15d
 |.define RX,      IP        // the same as VM IP reused as a general purpos reg
 |.define RXl,     IPl
 |.define CARG1,   rdi       // x64/POSIX C call arguments.
 |.define CARG2,   rsi
 |.define CARG3,   rdx
 |.define CARG4,   rcx
 |.define CARG5,   r8
 |.define CARG6,   r9
 |.define CARG1d,  edi
 |.define CARG2d,  esi
 |.define CARG3d,  edx
 |.define CARG4d,  ecx
 |.define CARG5d,  r8d
 |.define CARG6d,  r9d
 |.define FCARG1a, CARG1    // Simulate x86 fastcall.
 |.define FCARG2a, CARG2
 |.define FCARG1d, CARG1d
 |.define FCARG2d, CARG2d
 |.define SPAD,    8
 |.define SSE,     1
|.else
 |.define FP,      esi
 |.define IP,      edi
 |.define IPl,     edi
 |.define RX,      IP        // the same as VM IP reused as a general purpos reg
 |.define RXl,     IPl
 |.define FCARG1a, ecx       // x86 fastcall arguments.
 |.define FCARG2a, edx
 |.define FCARG1d, ecx
 |.define FCARG2d, edx
 |.define SPAD,    12
 |.define SSE,     1
|.endif

#define r0        0
#define r1        1
#define r2        2
#define r3        3
#define r4        4
#define r5        5
#define r6        6
#define r7        7
#if SIZEOF_SIZE_T == 8
# define r8       8
# define r9       9
# define r10     10
# define r11     11
# define r12     12
# define r13     13
# define r14     14
# define r15     15
# define FP      r14
# define IP      r15
# define RX      IP
# define FCARG1a r7
#else
# define FP      r6
# define IP      r7
# define RX      IP
# define FCARG1a r1
#endif

|.type EX, zend_execute_data, FP
|.type OP, zend_op, IP
|.type ZVAL, zval

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code, cold_code

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0xffffffff)

#define IS_SIGNED_32BIT(val) ((((intptr_t)(val)) <= 0x7fffffff) && (((intptr_t)(val)) >= (-2147483647 - 1)))

#define BP_JIT_IS 6

|.macro LOAD_ADDR, reg, addr
|.if X64
||if (IS_32BIT(addr)) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.else
|	mov reg, ((ptrdiff_t)addr)
|.endif
|.endmacro

|.macro PUSH_ADDR, addr, tmp_reg
|.if X64
||if (IS_32BIT(addr)) {
|	push ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 tmp_reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
|	push tmp_reg
||}
|.else
|	push ((ptrdiff_t)addr)
|.endif
|.endmacro

|.macro EXT_CALL, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	call qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	call tmp_reg
||}
|.else
|	call dword &func
|.endif
|.endmacro

|.macro EXT_JMP, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	jmp qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	jmp tmp_reg
||}
|.else
|	jmp dword &func
|.endif
|.endmacro

|.macro LOAD_ZVAL_ADDR, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov reg, aword EX->literals
|   add reg, op.constant
|   .else
|   mov reg, op.zv
|   .endif
||} else {
|   lea reg, qword [FP + op.var]
||}
|.endmacro

|.macro PUSH_ZVAL_ADDR, op_type, op, tmp_reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov tmp_reg, aword EX->literals
|   add tmp_reg, op.constant
|	push tmp_reg
|   .else
|   push op.zv
|   .endif
||} else {
|   lea tmp_reg, qword [FP + op.var]
|	push tmp_reg
||}
|.endmacro

|.macro GET_Z_TYPE_INFO, reg, zv
|	mov reg, dword [zv + 8]
|.endmacro

|.macro SET_Z_TYPE_INFO, zv, type
|	mov dword [zv + 8], type
|.endmacro

|.macro GET_Z_LVAL, reg, zv
|	mov reg, aword [zv]
|.endmacro

|.macro SET_Z_LVAL, zv, val
|	mov aword [zv], val
|.endmacro

|.macro GET_Z_PTR, reg, zv
|	mov reg, aword [zv]
|.endmacro

|.macro SET_Z_PTR, zv, val
|	mov aword [zv], val
|.endmacro

|.macro GET_Z_W2, reg, zv
|	mov reg, dword [zv + 4]
|.endmacro

|.macro SET_Z_W2, zv, val
|	mov dword [zv + 4], val
|.endmacro

|.macro FPU_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins qword [op.zv]
|   .endif
||} else {
|   fp_ins qword [FP + op.var]
||}
|.endmacro

|.macro FPU_LOAD, op_type, op
|	FPU_OP fld, op_type, op
|.endmacro

|.macro FPU_MATH, opcode, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         FPU_OP fadd, op_type, op
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         FPU_OP fsub, op_type, op
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         FPU_OP fmul, op_type, op
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         FPU_OP fdiv, op_type, op
||        break;
||}
|.endmacro

|.macro FPU_STORE, zv
|	fstp qword [zv]
|.endmacro

|.macro SSE_OP, sse_ins, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   sse_ins reg, qword [r0 + op.constant]
|   .else
|   sse_ins reg, qword [op.zv]
|   .endif
||} else {
|   sse_ins reg, qword [FP + op.var]
||}
|.endmacro

|.macro SSE_LOAD_LONG, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   cvtsi2sd reg, qword [r0 + op.constant]
|   .else
|   cvtsi2sd reg, dword [op.zv]
|   .endif
||} else {
|   cvtsi2sd reg, aword [FP + op.var]
||}
|.endmacro

|.macro SSE_GET_Z_LVAL, reg, zv
|   cvtsi2sd reg, aword [zv]
|.endmacro

|.macro SSE_LOAD, reg, op_type, op
|	SSE_OP movsd, reg, op_type, op
|.endmacro

|.macro SSE_GET_Z_DVAL, reg, zv
|   movsd reg, qword [zv]
|.endmacro

|.macro SSE_MATH, opcode, reg, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         SSE_OP addsd, reg, op_type, op
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         SSE_OP subsd, reg, op_type, op
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         SSE_OP mulsd, reg, op_type, op
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         SSE_OP divsd, reg, op_type, op
||        break;
||}
|.endmacro

|.macro SSE_MATH2, opcode, dst_reg, src_reg
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         addsd dst_reg, src_reg
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         subsd dst_reg, src_reg
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         mulsd dst_reg, src_reg
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         divsd dst_reg, src_reg
||        break;
||}
|.endmacro

|.macro SSE_STORE, zv, reg
|	movsd qword [zv], reg
|.endmacro

|.macro DOUBLE_STORE, zv, reg
|.if X64 or SSE
|	SSE_STORE zv, reg
|.else
|	FPU_STORE zv
|.endif
|.endmacro

|.macro LONG_OP, long_ins, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   	long_ins reg, r1
||  } else {
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   long_ins reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_LOAD, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  } else {
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   GET_Z_LVAL reg, FP + op.var
||}
|.endmacro

|.macro LONG_MATH, opcode, reg, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         LONG_OP add, reg, op_type, op
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         LONG_OP sub, reg, op_type, op
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         LONG_OP imul, reg, op_type, op
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         idiv aword [FP + op.var] // (reg == r0)
||        break;
||}
|.endmacro

|.macro LONG_MATH2, opcode, dst_reg, src_reg
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         add dst_reg, src_reg
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         sub dst_reg, src_reg
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         imul dst_reg, src_reg
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         idiv src_reg // (reg1 == r0)
||        break;
||}
|.endmacro

|.macro FPU_LONG_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins dword [op.zv]
|   .endif
||} else {
|   fp_ins aword [FP + op.var]
||}
|.endmacro

|.macro FPU_LONG_LOAD, op_type, op
|	FPU_LONG_OP fild, op_type, op
|.endmacro

|.macro FPU_GET_Z_LVAL, zv
|	fild aword [zv]
|.endmacro

|.macro FPU_GET_Z_DVAL, zv
|   fld qword [zv]
|.endmacro

|.macro FPU_MATH2, opcode, reg
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         fadd reg
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         fsub reg
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         fmul reg
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         fdiv reg
||        break;
||}
|.endmacro

|.macro ZVAL_COPY_CONST, dst, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			SET_Z_LVAL dst, tmp_reg
||		} else {
|			SET_Z_LVAL dst, Z_LVAL_P(zv)
||		}
|.else
|		SET_Z_LVAL dst, Z_LVAL_P(zv)
|.endif
||	}
||}
||if (((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) ||  (dst_info & (MAY_BE_STRING|MAY_BE_ARRAY))) {
|	SET_Z_TYPE_INFO dst, Z_TYPE_INFO_P(zv)
||}
|.endmacro

|.macro ZVAL_COPY_CONST_2, dst, dst2, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst]
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			SET_Z_LVAL dst, tmp_reg
|			SET_Z_LVAL dst2, tmp_reg
||		} else {
|			SET_Z_LVAL dst, Z_LVAL_P(zv)
|			SET_Z_LVAL dst2, Z_LVAL_P(zv)
||		}
|.else
|		SET_Z_LVAL dst, Z_LVAL_P(zv)
|		SET_Z_LVAL dst2, Z_LVAL_P(zv)
|.endif
||	}
||}
||if (((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) ||  (dst_info & (MAY_BE_STRING|MAY_BE_ARRAY))) {
|	SET_Z_TYPE_INFO dst, Z_TYPE_INFO_P(zv)
||}
|	SET_Z_TYPE_INFO dst2, Z_TYPE_INFO_P(zv)
|.endmacro

|.macro ZVAL_COPY_VALUE, dst, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.else
|		GET_Z_PTR tmp_reg2, src
|		GET_Z_W2 tmp_reg1, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_W2 dst, tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
||}
|.endmacro

/* the same as above, but "src" may overlap with "tmp_reg1d" */
|.macro ZVAL_COPY_VALUE_clobber_src, dst, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.else
|		GET_Z_W2 tmp_reg2, src
|		SET_Z_W2 dst, tmp_reg2
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
||}
|.endmacro

|.macro ZVAL_COPY_VALUE_2, dst, dst2, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
| 		SET_Z_PTR dst2, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|		fld qword [src]
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.else
|		GET_Z_PTR tmp_reg2, src
|		GET_Z_W2 tmp_reg1, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|		SET_Z_W2 dst, tmp_reg1
|		SET_Z_W2 dst2, tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
|	SET_Z_TYPE_INFO dst2, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
|	SET_Z_TYPE_INFO dst2, tmp_reg1d
||}
|.endmacro

/* the same as above, but "src" may overlap with "tmp_reg1d" */
|.macro ZVAL_COPY_VALUE_clobber_src_2, dst, dst2, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
| 		SET_Z_PTR dst2, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|		fld qword [src]
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.else
|		GET_Z_W2 tmp_reg2, src
|		SET_Z_W2 dst, tmp_reg2
|		SET_Z_W2 dst2, tmp_reg2
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
|	SET_Z_TYPE_INFO dst2, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
|	SET_Z_TYPE_INFO dst2, tmp_reg1d
||}
|.endmacro

|.macro IF_TYPE, type, val, label
|	cmp type, val
|	je label
|.endmacro

|.macro IF_NOT_TYPE, type, val, label
|	cmp type, val
|	jne label
|.endmacro

|.macro IF_Z_TYPE, zv, val, label
|	IF_TYPE byte [zv + 8], val, label
|.endmacro

|.macro IF_NOT_Z_TYPE, zv, val, label
|	IF_NOT_TYPE byte [zv + 8], val, label
|.endmacro

|.macro IF_FLAGS, type_flags, mask, label
|	test type_flags, mask
|	jnz label
|.endmacro

|.macro IF_NOT_FLAGS, type_flags, mask, label
|	test type_flags, mask
|	jz label
|.endmacro

|.macro IF_REFCOUNTED, type_flags, label
|	IF_FLAGS type_flags, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_NOT_REFCOUNTED, type_flags, label
|	IF_NOT_FLAGS type_flags, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_Z_FLAGS, zv, mask, label
|	IF_FLAGS byte [zv + 9], mask, label
|.endmacro

|.macro IF_NOT_Z_FLAGS, zv, mask, label
|	IF_NOT_FLAGS byte [zv + 9], mask, label
|.endmacro

|.macro IF_Z_REFCOUNTED, zv, label
|	IF_Z_FLAGS zv, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_NOT_Z_REFCOUNTED, zv, label
|	IF_NOT_Z_FLAGS zv, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro GC_ADDREF, zv
|	inc	dword [zv]
|.endmacro

|.macro GC_DELREF, zv
|	dec	dword [zv]
|.endmacro

|.macro IF_GC_MAY_NOT_LEAK, ptr, tmp_reg, label
|	mov tmp_reg, dword [ptr + 4]
|	and tmp_reg, (GC_INFO_MASK | (GC_COLLECTABLE << GC_FLAGS_SHIFT))
|	cmp tmp_reg, (GC_COLLECTABLE << GC_FLAGS_SHIFT)
|	jne label
|.endmacro

|.macro ADDREF_CONST, zv, tmp_reg
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			inc dword [tmp_reg]
||		} else {
|			inc dword [Z_LVAL_P(zv)]
||		}
|.else
|		inc dword [Z_LVAL_P(zv)]
|.endif
|.endmacro

|.macro ADDREF_CONST_2, zv, tmp_reg
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			add dword [tmp_reg], 2
||		} else {
|			add dword [Z_LVAL_P(zv)], 2
||		}
|.else
|		inc dword [Z_LVAL_P(zv)]
|.endif
|.endmacro

|.macro TRY_ADDREF, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		IF_NOT_REFCOUNTED type_flags_reg, >1
||	}
|	GC_ADDREF value_ptr_reg
|1:
||}
|.endmacro

|.macro TRY_ADDREF_2, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		IF_NOT_REFCOUNTED type_flags_reg, >1
||	}
|	add dword [value_ptr_reg], 2
|1:
||}
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_COPY_CTOR_FUNC, filename, lineno // arg1 must be in FCARG1a
||	if (ZEND_DEBUG) {
||		if (filename) {
|			LOAD_ADDR FCARG2a, ZSTR_VAL((zend_string*)filename)
||		} else {
|			mov FCARG2a, 0
||		}
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|		EXT_CALL _zval_copy_ctor_func, r0
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_COPY_CTOR, val_info, type_flags_reg, value_ptr_reg, filename, lineno
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
|		IF_NOT_FLAGS type_flags_reg, IS_TYPE_REFCOUNTED + IS_TYPE_IMMUTABLE, >2
|		IF_NOT_FLAGS type_flags_reg, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >1
|		GC_ADDREF value_ptr_reg
|		jmp >2
|1:
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|2:
||	} else {
|		TRY_ADDREF val_info, type_flags_reg, value_ptr_reg
||	}
||}
|.endmacro

|.macro ZVAL_DEREF, reg, info
||	if (info & MAY_BE_REF) {
|		IF_NOT_Z_TYPE, reg, IS_REFERENCE, >1
|		GET_Z_PTR reg, reg
|		add reg, offsetof(zend_reference, val)
|1:
||	}
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_DTOR_FUNC, filename, lineno // arg1 must be in FCARG1a
||	if (ZEND_DEBUG) {
||		if (filename) {
|			LOAD_ADDR FCARG2a, ZSTR_VAL((zend_string*)filename)
||		} else {
|			mov FCARG2a, 0
||		}
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|		EXT_CALL _zval_dtor_func, r0
|.endmacro

|.macro ZVAL_PTR_DTOR, zv, op_info, gc, cold, safe, filename, lineno
||	if ((op_info) & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
||		if ((op_info) & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|			// if (Z_REFCOUNTED_P(cv)) {
||			if (cold) {
|				IF_Z_REFCOUNTED zv, >1
|.cold_code
|1:
||			} else {
|				IF_NOT_Z_REFCOUNTED zv, >2
||			}
||		}
|		// if (!Z_DELREF_P(cv)) {
|		GET_Z_PTR FCARG1a, zv
|		GC_DELREF FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
||			if (RC_MAY_BE_N(op_info)) {
||				if (gc && RC_MAY_BE_N(op_info) && ((op_info) & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
|					jnz >1
||				} else {
|					jnz >2
||				}
||			}
||			if (safe) {
|				// ZVAL_NULL(cv);
|				SET_Z_TYPE_INFO zv, IS_NULL
||			}
|			// zval_dtor_func(r);
|			ZVAL_DTOR_FUNC filename, lineno
||			if (gc && RC_MAY_BE_N(op_info) && ((op_info) & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
|				jmp >2
||			}
|1:
||		}
||		if (gc && RC_MAY_BE_N(op_info) && ((op_info) & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
||			if ((op_info) & MAY_BE_REF) {
|				GET_Z_PTR FCARG1a, zv
|				cmp byte [FCARG1a + 4], IS_REFERENCE
|				jnz >1
|				GET_Z_PTR FCARG1a, FCARG1a + offsetof(zend_reference, val)
|				IF_NOT_Z_REFCOUNTED zv, >2
|				GET_Z_PTR FCARG1a, zv
|1:
||			}
|			IF_GC_MAY_NOT_LEAK FCARG1a, eax, >2
|			// gc_possible_root(Z_COUNTED_P(z))
|			EXT_CALL gc_possible_root, r0
||			if (cold && ((op_info) & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|				jmp >2
|.code
||			}
||		} else if (cold && ((op_info) & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|			jmp >2
|.code
||		}
|2:
||	}
|.endmacro

|.macro FREE_OP, op_type, op, op_info, cold, op_array, lineno
||if (op_type & (IS_VAR|IS_TMP_VAR)) {
|	ZVAL_PTR_DTOR FP + op.var, op_info, 0, cold, 0, op_array->filename, lineno
||}
|.endmacro

|.macro SEPARATE_ZVAL_NOREF, zv, op_info, cold, filename, lineno
||	if ((op_info & (MAY_BE_STRING|MAY_BE_ARRAY)) && RC_MAY_BE_N(op_info)) {
||		if (cold) {
|			IF_Z_FLAGS zv, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >1
|.cold_code
|1:
||		} else {
|			IF_NOT_Z_FLAGS zv, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >2
||		}
|		GET_Z_PTR r0, zv
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
|			jbe >2
||		}
|		IF_Z_FLAGS zv, IS_TYPE_IMMUTABLE, >1
|		GC_DELREF r0
|1:
|		lea FCARG1a, [zv]
|		ZVAL_COPY_CTOR_FUNC filename, lineno
||		if (cold) {
|			jmp >2
|.code
||		}
|2:
||	}
|.endmacro

|.macro SEPARATE_ZVAL_NOREF_REG, op_info, cold, filename, lineno
||	if ((op_info & (MAY_BE_STRING|MAY_BE_ARRAY)) && RC_MAY_BE_N(op_info)) {
||		if (cold) {
|			IF_Z_FLAGS FCARG1a, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >1
|.cold_code
|1:
||		} else {
|			IF_NOT_Z_FLAGS FCARG1a, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >2
||		}
|		GET_Z_PTR r0, FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
|			jbe >2
||		}
|		IF_Z_FLAGS FCARG1a, IS_TYPE_IMMUTABLE, >1
|		GC_DELREF r0
|1:
|		mov aword [r4], FCARG1a // save
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|		mov FCARG1a, aword [r4] // restore
||		if (cold) {
|			jmp >2
|.code
||		}
|2:
||	}
|.endmacro

|.macro SEPARATE_ARRAY, op_type, op, op_info, cold, filename, lineno
|	LONG_LOAD FCARG1a, op_type, op
||	if (RC_MAY_BE_N(op_info)) {
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [FCARG1a], 1 // if (GC_REFCOUNTED() > 1)
||			if (cold) {
|				ja >1
|.cold_code
|1:
||			} else {
|				jbe >2
||			}
||		}
|		IF_Z_FLAGS FP + op.var, IS_TYPE_IMMUTABLE, >1
|		GC_DELREF FCARG1a
|1:
|		LOAD_ZVAL_ADDR FCARG1a, op_type, op
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|		LONG_LOAD FCARG1a, op_type, op
||		if (RC_MAY_BE_1(op_info)) {
||			if (cold) {
|				jmp >2
|.code
||			}
||		}
|2:
||	}
|.endmacro

|.macro SEPARATE_ARRAY_REG, op_info, cold, filename, lineno
||	if (RC_MAY_BE_N(op_info)) {
|		GET_Z_PTR r0, FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
||			if (cold) {
|				ja >1
|.cold_code
|1:
||			} else {
|				jbe >2
||			}
||		}
|		IF_Z_FLAGS FCARG1a, IS_TYPE_IMMUTABLE, >1
|		GC_DELREF r0
|1:
|		mov aword [r4], FCARG1a // save
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|		mov FCARG1a, aword [r4] // restore
|		GET_Z_PTR FCARG1a, FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
||			if (cold) {
|				jmp >2
|.code
||			}
||		}
|		mov FCARG1a, r0
|2:
||	} else {
|		GET_Z_PTR FCARG1a, FCARG1a
||	}
|.endmacro

|.macro EFREE_REG_24, op_array, opline
||#if ZEND_DEBUG
||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, opline->lineno
|		xor CARG4, CARG4
|		xor CARG5, CARG5
|.else
|		push 0
|		push 0
|		push opline->lineno
|.endif
|		EXT_CALL _efree, r0
||#else
|		EXT_CALL _efree_24, r0
||#endif
|.endmacro

|.macro EFREE_24, ptr, op_array, opline
|	mov FCARG1a, ptr
|	EFREE_REG_24 op_array, opline
|.endmacro

|.macro EMALLOC, size, op_array, opline
||#if ZEND_DEBUG
||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
|		mov FCARG1a, size
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, opline->lineno
|		xor CARG4, CARG4
|		xor CARG5, CARG5
|.else
|		push 0
|		push 0
|		push opline->lineno
|.endif
|		EXT_CALL _emalloc, r0
||#else
||	if (size == 24) {
|		EXT_CALL _emalloc_24, r0
||	} else {
|		mov FCARG1a, size
|		EXT_CALL _emalloc, r0
||	}
||#endif
|.endmacro

|.macro OBJ_RELEASE, reg, tmp_reg, exit_label
|	GC_DELREF reg
|	jne >1
|	// zend_objects_store_del(obj);
|.if X64
|	mov CARG1, reg
|	EXT_CALL zend_objects_store_del, r0
|.else
|	sub r4, 12
|	push reg
|	EXT_CALL zend_objects_store_del, r0
|	add r4, 16
|.endif
|	jmp exit_label
|1:
|	IF_GC_MAY_NOT_LEAK reg, tmp_reg, >1
|	// gc_possible_root(obj)
|	mov FCARG1a, reg
|	EXT_CALL gc_possible_root, r0
|1:
|.endmacro

|.macro SAVE_VALID_OPLINE, opline
|| if (opline == last_valid_opline) {
|		mov aword EX->opline, IP
|| } else {
|.if X64
||		if (IS_32BIT(opline)) {
|			mov aword EX->opline, ((ptrdiff_t)opline)
||		} else {
|			mov64 r0, ((ptrdiff_t)opline)
|			mov aword EX->opline, r0
||		}
|.else
|		mov aword EX->opline, opline
|.endif
||	}
|.endmacro

|.macro UNDEFINED_OFFSET, opline
|| if (opline == last_valid_opline) {
|	call ->undefined_offset_ex
|| } else {
|	SAVE_VALID_OPLINE, opline
|	call ->undefined_offset
|| }
|.endmacro

|.macro UNDEFINED_INDEX, opline
|| if (opline == last_valid_opline) {
|	call ->undefined_index_ex
|| } else {
|	SAVE_VALID_OPLINE, opline
|	call ->undefined_index
|| }
|.endmacro

|.macro CANNOT_ADD_ELEMENT, opline
|| if (opline == last_valid_opline) {
|	call ->cannot_add_element_ex
|| } else {
|	SAVE_VALID_OPLINE, opline
|	call ->cannot_add_element
|| }
|.endmacro

static zend_bool reuse_ip;
static zend_bool delayed_call_chain;
static uint32_t  delayed_call_level;
static const zend_op *last_valid_opline;
static int jit_return_label;

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static inline zend_bool is_signed(double d)
{
    return (((unsigned char*)&d)[sizeof(double)-1] & 0x80) != 0;
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|.else
	|	push 0
	|.endif
	|	EXT_CALL zend_timeout, r0
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		|	mov CARG1, FP
		|	EXT_CALL zend_interrupt_function, r0
		|.else
		|	sub r4, 12
		|	push FP
		|	EXT_CALL zend_interrupt_function, r0
		|	add r4, 16
		|.endif
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static int zend_jit_leave_function_stub(dasm_State **Dst)
{
	|->leave_function_handler:
	|	add r4, SPAD
	|	test FCARG1d, ZEND_CALL_TOP
	|	jnz >1
	|	EXT_JMP zend_jit_leave_nested_func_helper, r0
	|1:
	|	EXT_JMP zend_jit_leave_top_func_helper, r0

	return 1;
}

static int zend_jit_leave_throw_stub(dasm_State **Dst)
{
	|->leave_throw_handler:
	|	// if (opline->opcode != ZEND_HANDLE_EXCEPTION) {
	|	cmp byte OP:IP->opcode, ZEND_HANDLE_EXCEPTION
	|	je >5
	|	// EG(opline_before_exception) = opline;
	|	mov aword [&EG(opline_before_exception)], IP
	|	// if (RETURN_VALUE_USED(old_opline)) {
	|	cmp byte OP:IP->result_type, IS_UNUSED
	|	je >5
	|	// zval_ptr_dtor(EX_VAR(old_opline->result.var));
	|.if X64
	|	movsxd r0, dword OP:IP->result.var
	|.else
	|	mov r0, OP:IP->result.var
	|.endif
	|	add r0, FP
	|	ZVAL_PTR_DTOR r0, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN|MAY_BE_REF, 1, 0, 0, NULL, 0
	|5:
	|	// opline = EG(exception_op);
	|	LOAD_ADDR IP, &EG(exception_op)
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static int zend_jit_icall_throw_stub(dasm_State **Dst)
{
	|->icall_throw_handler:
	|	mov IP, EX->opline
	|	//	zend_throw_exception_internal(NULL);
	|.if X64
	|	xor CARG1, CARG1
	|	EXT_CALL zend_throw_exception_internal, r0
	|.else
	|	sub r4, 12
	|	push 0
	|	EXT_CALL zend_throw_exception_internal, r0
	|	add r4, 16
	|.endif
	|	// if (opline->result_type != IS_UNUSED) {
	|	cmp byte OP:IP->result_type, IS_UNUSED
	|	je >5
	|	// zval_ptr_dtor(EX_VAR(opline->result.var));
	|.if X64
	|	movsxd r0, dword OP:IP->result.var
	|.else
	|	mov r0, OP:IP->result.var
	|.endif
	|	add r0, FP
	|	ZVAL_PTR_DTOR r0, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN|MAY_BE_REF, 1, 0, 0, NULL, 0
	|5:
	|	//	HANDLE_EXCEPTION()
	|	jmp ->exception_handler

	return 1;
}

static int zend_jit_throw_cannot_pass_by_ref_stub(dasm_State **Dst)
{
	|->throw_cannot_pass_by_ref:
	|	mov r0, EX->opline
	|.if X64
	|	movsxd r1, dword OP:r0->result.var
	|.else
	|	mov r1, OP:r0->result.var
	|.endif
	|	SET_Z_TYPE_INFO RX+r1, IS_UNDEF
	|	mov RX, r0
	|.if X64
	|	mov CARG1, 0
	|	LOAD_ADDR CARG2, "Cannot pass parameter %d by reference"
	|	mov CARG3d, dword OP:r0->op2.num
	|	EXT_CALL zend_throw_error, r0
	|.else
	|	mov r1, dword OP:r0->op2.num
	|	sub r4, 4
	|	push r1
	|	push "Cannot pass parameter %d by reference"
	|	push 0
	|	EXT_CALL zend_throw_error, r0
	|	add r4, 16
	|.endif
	|	cmp byte OP:RX->op1_type, IS_TMP_VAR
	|	jne >9
	|.if X64
	|	movsxd r0, dword OP:RX->op1.var
	|.else
	|	mov r0, OP:RX->op1.var
	|.endif
	|	add r0, FP
	|	ZVAL_PTR_DTOR r0, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN|MAY_BE_REF, 0, 0, 0, NULL, 0
	|9:
	|	jmp ->exception_handler

	return 1;
}

static int zend_jit_undefined_offset_ex_stub(dasm_State **Dst)
{
	|->undefined_offset_ex:
	|	mov aword EX->opline, IP
	|	jmp ->undefined_offset

	return 1;
}

static int zend_jit_undefined_offset_stub(dasm_State **Dst)
{
	|->undefined_offset:
	|.if X64
	|	sub r4, 8
	|.else
	|	sub r4, 12
	|.endif
	|	mov r0, EX->opline
	|.if X64
	|	movsxd r1, dword OP:r0->result.var
	|.else
	|	mov r1, OP:r0->result.var
	|.endif
	|	cmp byte OP:r0->op2_type, IS_CONST
	|	SET_Z_TYPE_INFO FP + r1, IS_NULL
	|	jne >2
	|.if X64
	|	movsxd r0, dword OP:r0->op2.constant
	|   add r0, aword EX->literals
	|.else
	|	mov r0, aword OP:r0->op2.zv
	|.endif
	|	jmp >3
	|2:
	|.if X64
	|	movsxd r0, dword OP:r0->op2.var
	|.else
	|	mov r0, OP:r0->op2.var
	|.endif
	|	add r0, FP
	|3:
	|.if X64
	|	mov CARG1, E_NOTICE
	|	LOAD_ADDR CARG2, "Undefined offset: " ZEND_LONG_FMT
	|	mov CARG3, aword [r0]
	|	EXT_CALL zend_error, r0
	|	add r4, 8 // stack alignment
	|.else
	|	sub r4, 4
	|	push aword [r0]
	|	push "Undefined offset: " ZEND_LONG_FMT
	|	push E_NOTICE
	|	EXT_CALL zend_error, r0
	|	add r4, 28
	|.endif
	|	ret

	return 1;
}

static int zend_jit_undefined_index_ex_stub(dasm_State **Dst)
{
	|->undefined_index_ex:
	|	mov aword EX->opline, IP
	|	jmp ->undefined_index

	return 1;
}

static int zend_jit_undefined_index_stub(dasm_State **Dst)
{
	|->undefined_index:
	|.if X64
	|	sub r4, 8
	|.else
	|	sub r4, 12
	|.endif
	|	mov r0, EX->opline
	|.if X64
	|	movsxd r1, dword OP:r0->result.var
	|.else
	|	mov r1, OP:r0->result.var
	|.endif
	|	cmp byte OP:r0->op2_type, IS_CONST
	|	SET_Z_TYPE_INFO FP + r1, IS_NULL
	|	jne >2
	|.if X64
	|	movsxd r0, dword OP:r0->op2.constant
	|   add r0, aword EX->literals
	|.else
	|	mov r0, aword OP:r0->op2.zv
	|.endif
	|	jmp >3
	|2:
	|.if X64
	|	movsxd r0, dword OP:r0->op2.var
	|.else
	|	mov r0, OP:r0->op2.var
	|.endif
	|	add r0, FP
	|3:
	|.if X64
	|	mov CARG1, E_NOTICE
	|	LOAD_ADDR CARG2, "Undefined index: %s"
	|	mov CARG3, aword [r0]
	|	add CARG3, offsetof(zend_string, val)
	|	EXT_CALL zend_error, r0
	|	add r4, 8
	|.else
	|	sub r4, 4
	|	mov r0, aword [r0]
	|	add r0, offsetof(zend_string, val)
	|	push r0
	|	push "Undefined index: %s"
	|	push E_NOTICE
	|	EXT_CALL zend_error, r0
	|	add r4, 28
	|.endif
	|	ret

	return 1;
}

static int zend_jit_cannot_add_element_ex_stub(dasm_State **Dst)
{
	|->cannot_add_element_ex:
	|	mov aword EX->opline, IP
	|	jmp ->cannot_add_element

	return 1;
}

static int zend_jit_cannot_add_element_stub(dasm_State **Dst)
{
	|->cannot_add_element:
	|.if X64
	|	sub r4, 8
	|.else
	|	sub r4, 12
	|.endif
	|	mov r0, EX->opline
	|	cmp byte OP:r0->result_type, IS_UNUSED
	|	jz >1
	|.if X64
	|	movsxd r0, dword OP:r0->result.var
	|.else
	|	mov r0, OP:r0->result.var
	|.endif
	|	SET_Z_TYPE_INFO FP + r0, IS_NULL
	|1:
	|.if X64
	|	mov CARG1, E_WARNING
	|	LOAD_ADDR CARG2, "Cannot add element to the array as the next element is already occupied"
	|	EXT_CALL zend_error, r0
	|	add r4, 8
	|.else
	|	sub r4, 8
	|	push "Cannot add element to the array as the next element is already occupied"
	|	push E_WARNING
	|	EXT_CALL zend_error, r0
	|	add r4, 28
	|.endif
	|	ret

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
	JIT_STUB(leave_function),
	JIT_STUB(leave_throw),
	JIT_STUB(icall_throw),
	JIT_STUB(throw_cannot_pass_by_ref),
	JIT_STUB(undefined_offset),
	JIT_STUB(undefined_index),
	JIT_STUB(cannot_add_element),
	JIT_STUB(undefined_offset_ex),
	JIT_STUB(undefined_index_ex),
	JIT_STUB(cannot_add_element_ex),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	reuse_ip = 0;
	delayed_call_chain = 0;
	last_valid_opline = NULL;
	jit_return_label = -1;
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_save_call_chain(dasm_State **Dst, uint32_t call_level)
{
	|	// call->prev_execute_data = EX(call);
	if (call_level == 1) {
		|	mov aword EX:RX->prev_execute_data, 0
	} else {
		|	mov r0, EX->call
		|	mov EX:RX->prev_execute_data, r0
	}
	|	// EX(call) = call;
	|	mov EX->call, RX

	delayed_call_chain = 0;

	return 1;
}

static int zend_jit_set_valid_ip(dasm_State **Dst, const zend_op *opline)
{
	if (delayed_call_chain) {
		if (!zend_jit_save_call_chain(Dst, delayed_call_level)) {
			return 0;
		}
	}
	if (!last_valid_opline) {
		|	LOAD_ADDR  IP, opline
	} else if (last_valid_opline != opline) {
		|	add IP, (opline - last_valid_opline) * sizeof(zend_op);
	}
	last_valid_opline = opline;
	reuse_ip = 0;
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst, const zend_op *opline)
{
	if (zend_interrupt_function) {
		if (!zend_jit_set_valid_ip(Dst, opline)) {
			return 0;
		}
	}
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, const zend_op *opline, int may_throw)
{
	if (!zend_jit_set_valid_ip(Dst, opline)) {
		return 0;
	}
	|	EXT_CALL opline->handler, r0
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	last_valid_opline++;

	/* Skip the following OP_DATA */
	switch (opline->opcode) {
		case ZEND_ASSIGN_DIM:
		case ZEND_ASSIGN_OBJ:
			last_valid_opline++;
			break;
		case ZEND_ASSIGN_ADD:
		case ZEND_ASSIGN_SUB:
		case ZEND_ASSIGN_MUL:
		case ZEND_ASSIGN_DIV:
		case ZEND_ASSIGN_MOD:
		case ZEND_ASSIGN_SL:
		case ZEND_ASSIGN_SR:
		case ZEND_ASSIGN_CONCAT:
		case ZEND_ASSIGN_BW_OR:
		case ZEND_ASSIGN_BW_AND:
		case ZEND_ASSIGN_BW_XOR:
		case ZEND_ASSIGN_POW:
			if (opline->extended_value) {
				last_valid_opline++;
			}
			break;
		default:
			break;
	}

	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, const zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst, opline)) {
		return 0;
	}
	|	add r4, SPAD // stack alignment
	|	EXT_JMP opline->handler, r0
	last_valid_opline = NULL;
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, const zend_op *target_opline)
{
	if (!reuse_ip) {
		last_valid_opline = target_opline;
	}
	return 1;
}

static int zend_jit_reset_opline(dasm_State **Dst, const zend_op *target_opline)
{
	last_valid_opline = NULL;
	return 1;
}

static void zend_jit_start_reuse_ip(void) {
	last_valid_opline = NULL;
	reuse_ip = 1;
}

static void zend_jit_stop_reuse_ip(void) {
	reuse_ip = 0;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, const zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jne =>target_label

	last_valid_opline = next_opline;

	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, const zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	const zend_op *next_opline = opline + 1;
	const zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	je =>next_label
	|	cmp IPl, target_opline
	|	je =>target_label

	return 1;
}

#ifdef CONTEXT_THREADED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, const zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	je >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, const zend_op *opline)
{
#ifdef CONTEXT_THREADED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, const zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	if (!zend_jit_handler(Dst, opline, 1)) {
		return 0;
	}
	if (opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL) {
		zend_class_entry *ce = NULL;

		if (zend_jit_level >= ZEND_JIT_LEVEL_OPT_FUNC) {
			if (ssa->ops && ssa->var_info) {
				zend_ssa_var_info *res_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].result_def];
				if (res_ssa->ce && !res_ssa->is_instanceof) {
					ce = res_ssa->ce;
				}
			}
		} else {
			if (opline->op1_type == IS_CONST) {
				zval *zv = RT_CONSTANT(op_array, opline->op1);
				if (Z_TYPE_P(zv) == IS_STRING) {
					zval *lc = zv + 1;
					ce = (zend_class_entry*)zend_hash_find_ptr(EG(class_table), Z_STR_P(lc));
				}
			}
		}

		(*opnum)++;
		if (!ce || ce->constructor) {
			const zend_op *next_opline = opline + 1;

			|	cmp IPl, next_opline
			|	jne >1
			zend_jit_call(Dst, next_opline);
			|1:
		}
	}
	return 1;
}

static int zend_jit_inc_dec(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	op1_info = OP1_INFO();
	if (opline->op1_type != IS_CV || !(op1_info & MAY_BE_LONG)) {
		goto fallback;
	}

	if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY)-MAY_BE_LONG)) {
		|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >2
	}
	||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC) &&
	||	    opline->result_type != IS_UNUSED) {
	|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
	||	}
	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|	inc aword [FP + opline->op1.var]
	} else {
		|	dec aword [FP + opline->op1.var]
	}
	op1_def_info = OP1_DEF_INFO();

	if ((op1_def_info & MAY_BE_DOUBLE) && zend_may_overflow(opline, op_array, ssa)) {
		|	jo >1
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
		|.cold_code
		|1:
		if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
			|.if X64
			|	mov64 rax, 0x43e0000000000000
			|	SET_Z_LVAL FP + opline->op1.var, rax
			|.else
			|	SET_Z_LVAL FP + opline->op1.var, 0
			|	SET_Z_W2 FP + opline->op1.var, 0x41e00000
			|.endif
		} else {
			|.if X64
			|	mov64 rax, 0xc3e0000000000000
			|	SET_Z_LVAL FP + opline->op1.var, rax
			|.else
			|	SET_Z_LVAL FP + opline->op1.var, 0x00200000
			|	SET_Z_W2 FP + opline->op1.var, 0xc1e00000
			|.endif
		}
		|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_DOUBLE
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_DOUBLE, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	} else {
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
	}
	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_LONG)) {
		|.cold_code
		|2:
		|	SAVE_VALID_OPLINE opline
		||	if (op1_info & MAY_BE_UNDEF) {
		|		IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >2
		|		// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|		mov FCARG1d, opline->op1.var
		|		EXT_CALL zend_jit_undefined_op_helper, r0
		|		SET_Z_TYPE_INFO FP + opline->op1.var, IS_NULL
		||		op1_info |= MAY_BE_NULL;
		||	}
		|2:
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	// ZVAL_DEREF(var_ptr);
		|	ZVAL_DEREF FCARG1a, op1_info
		||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC)) {
		||		if (opline->result_type != IS_UNUSED) {
		|			ZVAL_COPY_VALUE FP + opline->result.var, FCARG1a, op1_info, r0, eax, r2
		|			//ZVAL_COPY_CTOR op1_info, ah, r2, op_array->filename, opline->lineno
		||			if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
		||				if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
		|					IF_NOT_FLAGS ah, IS_TYPE_REFCOUNTED + IS_TYPE_IMMUTABLE, >2
		|					IF_FLAGS ah, IS_TYPE_COPYABLE + IS_TYPE_IMMUTABLE, >1
		|					GC_ADDREF r2
		|					jmp >2
		|1:
		|					mov aword [r4], FCARG1a // save
		|					ZVAL_COPY_CTOR_FUNC op_array->filename, opline->lineno
		|					mov FCARG1a, aword [r4] // restore
		|2:
		||				} else {
		|					TRY_ADDREF op1_info, ah, r2
		||				}
		||			}
		||		}
		||	} else {
		|		SEPARATE_ZVAL_NOREF_REG op1_info, 0, op_array->filename, opline->lineno
		||	}
		||	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|		EXT_CALL increment_function, r0
		||	} else {
		|		EXT_CALL decrement_function, r0
		||	}
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, op1_def_info, r0, eax, r1
		|		TRY_ADDREF op1_def_info, ah, r1
		||	}
		|	jmp >3
		|.code
	}
	|3:
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_long_long(dasm_State    **Dst,
                                   const zend_op  *opline,
                                   zend_op_array  *op_array,
                                   zend_ssa       *ssa,
                                   zend_uchar      op1_type,
                                   znode_op        op1,
                                   uint32_t        op1_reg,
                                   uint32_t        op1_offset,
                                   zend_uchar      op2_type,
                                   znode_op        op2,
                                   uint32_t        op2_reg,
                                   uint32_t        op2_offset,
                                   uint32_t        res_reg,
                                   uint32_t        res_offset,
                                   uint32_t        res_info)
{
	zend_bool same_ops = (op1_type == op2_type) && (op1.var == op2.var);

	if (opline->opcode == ZEND_MUL &&
		((op2_type == IS_CONST &&
		IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op2))) &&
		is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, op2)))) ||
		(op1_type == IS_CONST &&
		IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op1))) &&
		is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, op1)))))) {
		if (op2_type == IS_CONST) {
			if (op1_type == IS_CONST) {
				|  	LONG_LOAD r0, op1_type, op1
			} else {
				|  	GET_Z_LVAL r0, Ra(op1_reg)+op1_offset
			}
			|	shl r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, op2)))
		} else {
			if (op2_type == IS_CONST) {
				|   LONG_LOAD r0, op2_type, op2
			} else {
				|  	GET_Z_LVAL r0, Ra(op2_reg)+op2_offset
			}
			|	shl r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, op1)))
		}
	} else if (opline->opcode == ZEND_DIV &&
			(op2_type == IS_CONST &&
            is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, op2))))) {
		if (op1_type == IS_CONST) {
			|  	LONG_LOAD r0, op1_type, op1
		} else {
			|  	GET_Z_LVAL r0, Ra(op1_reg)+op1_offset
		}
		| 	shr r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, op2)))
	} else {
		if (op1_type == IS_CONST) {
			|  	LONG_LOAD r0, op1_type, op1
		} else {
			|  	GET_Z_LVAL r0, Ra(op1_reg)+op1_offset
		}
		if (same_ops && opline->opcode != ZEND_DIV) {
			|	LONG_MATH2 opline->opcode, r0, r0
		} else if (op2_type == IS_CONST) {
			|	LONG_MATH opline->opcode, r0, op2_type, op2
		} else {
			|	LONG_MATH2 opline->opcode, r0, aword [Ra(op2_reg)+op2_offset]
		}
	}
	if ((res_info & MAY_BE_DOUBLE) && zend_may_overflow(opline, op_array, ssa)) {
		|	jo >1
		|.cold_code
		|1:
		|.if X64 or SSE
		if (op1_type == IS_CONST) {
			|	SSE_LOAD_LONG xmm0, op1_type, op1
		} else {
			|  	SSE_GET_Z_LVAL xmm0, Ra(op1_reg)+op1_offset
		}
		if (op2_type == IS_CONST) {
			|	SSE_LOAD_LONG xmm1, op2_type, op2
		} else {
			|  	SSE_GET_Z_LVAL xmm1, Ra(op2_reg)+op2_offset
		}
		|	SSE_MATH2 opline->opcode, xmm0, xmm1
		|.else
		if (op2_type == IS_CONST) {
			|	FPU_LONG_LOAD op2_type, op2
		} else {
			|  	FPU_GET_Z_LVAL Ra(op2_reg)+op2_offset
		}
		if (op1_type == IS_CONST) {
			|	FPU_LONG_LOAD op1_type, op1
		} else {
			|  	FPU_GET_Z_LVAL Ra(op1_reg)+op1_offset
		}
		|	FPU_MATH2 opline->opcode, st1
		|.endif
		|	DOUBLE_STORE Ra(res_reg)+res_offset, xmm0
		|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE
		|	jmp >2
		|.code
		|	SET_Z_LVAL Ra(res_reg)+res_offset, r0
		if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
			|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_LONG
		}
		|2:
	} else {
		|	SET_Z_LVAL Ra(res_reg)+res_offset, r0
		if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
			|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_LONG
		}
	}

	return 1;
}

static int zend_jit_math_long_double(dasm_State    **Dst,
                                     const zend_op  *opline,
                                     zend_uchar      op1_type,
                                     znode_op        op1,
                                     uint32_t        op1_reg,
                                     uint32_t        op1_offset,
                                     zend_uchar      op2_type,
                                     znode_op        op2,
                                     uint32_t        op2_reg,
                                     uint32_t        op2_offset,
                                     uint32_t        res_reg,
                                     uint32_t        res_offset)
{
	|.if X64 or SSE
		if (op1_type == IS_CONST) {
			|	SSE_LOAD_LONG xmm0, op1_type, op1
		} else {
			|	SSE_GET_Z_LVAL xmm0, Ra(op1_reg)+op1_offset
		}
		if (op2_type == IS_CONST) {
			|	SSE_MATH opline->opcode, xmm0, op2_type, op2
		} else {
			|	SSE_MATH2 opline->opcode, xmm0, qword [Ra(op2_reg)+op2_offset]
		}
	|.else
		if (op1_type == IS_CONST) {
			|	FPU_LONG_LOAD op1_type, op1
		} else {
			|	FPU_GET_Z_LVAL Ra(op1_reg)+op1_offset
		}
		if (op2_type == IS_CONST) {
			|	FPU_MATH opline->opcode, op2_type, op2
		} else {
			|	FPU_MATH2 opline->opcode, qword [Ra(op2_reg)+op2_offset]
		}
	|.endif
	|	DOUBLE_STORE Ra(res_reg)+res_offset, xmm0
	|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE

	return 1;
}

static int zend_jit_math_double_long(dasm_State    **Dst,
                                     const zend_op  *opline,
                                     zend_uchar      op1_type,
                                     znode_op        op1,
                                     uint32_t        op1_reg,
                                     uint32_t        op1_offset,
                                     zend_uchar      op2_type,
                                     znode_op        op2,
                                     uint32_t        op2_reg,
                                     uint32_t        op2_offset,
                                     uint32_t        res_reg,
                                     uint32_t        res_offset)
{
	|.if X64 or SSE
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL || opline->opcode == ZEND_ASSIGN_ADD || opline->opcode == ZEND_ASSIGN_MUL) {
	||		if (op2_type == IS_CONST) {
	|			SSE_LOAD_LONG xmm0, op2_type, op2
	||		} else {
	|			SSE_GET_Z_LVAL xmm0, Ra(op2_reg)+op2_offset
	||		}
	||		if (op1_type == IS_CONST) {
	|			SSE_MATH opline->opcode, xmm0, op1_type, op1
	||		} else {
	|			SSE_MATH2 opline->opcode, xmm0, qword [Ra(op1_reg)+op1_offset]
	||		}
	||	} else {
	||		if (op1_type == IS_CONST) {
	|			SSE_LOAD xmm0, op1_type, op1
	||		} else {
	|			SSE_GET_Z_DVAL xmm0, Ra(op1_reg)+op1_offset
	||		}
	||		if (op2_type == IS_CONST) {
	|			SSE_LOAD_LONG xmm1, op2_type, op2
	||		} else {
	|			SSE_GET_Z_LVAL xmm1, Ra(op2_reg)+op2_offset
	||		}
	|		SSE_MATH2 opline->opcode, xmm0, xmm1
	||	}
	|.else
	||	if (op2_type == IS_CONST) {
	|		FPU_LONG_LOAD op2_type, op2
	||	} else {
	|		FPU_GET_Z_LVAL Ra(op2_reg)+op2_offset
	||	}
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL || opline->opcode == ZEND_ASSIGN_ADD || opline->opcode == ZEND_ASSIGN_MUL) {
	||		if (op1_type == IS_CONST) {
	|			FPU_MATH opline->opcode, op1_type, op1
	||		} else {
	|			FPU_MATH2 opline->opcode, qword [Ra(op1_reg)+op1_offset]
	||		}
	||	} else {
	||		if (op1_type == IS_CONST) {
	|			FPU_LOAD op1_type, op1
	||		} else {
	|			FPU_GET_Z_DVAL Ra(op1_reg)+op1_offset
	||		}
	|		FPU_MATH2 opline->opcode, st1
	||	}
	|.endif
	|	DOUBLE_STORE Ra(res_reg)+res_offset, xmm0
	if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
		|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE
	}
	return 1;
}

static int zend_jit_math_double_double(dasm_State    **Dst,
                                       const zend_op  *opline,
                                       zend_uchar      op1_type,
                                       znode_op        op1,
                                       uint32_t        op1_reg,
                                       uint32_t        op1_offset,
                                       zend_uchar      op2_type,
                                       znode_op        op2,
                                       uint32_t        op2_reg,
                                       uint32_t        op2_offset,
                                       uint32_t        res_reg,
                                       uint32_t        res_offset)
{
	zend_bool same_ops = (op1_type == op2_type) && (op1.var == op2.var);

	|.if X64 or SSE
	if (op1_type == IS_CONST) {
		|	SSE_LOAD xmm0, op1_type, op1
	} else {
		|	SSE_GET_Z_DVAL xmm0, Ra(op1_reg)+op1_offset
	}
	if (same_ops) {
		|	SSE_MATH2 opline->opcode, xmm0, xmm0
	} else if (op2_type == IS_CONST) {
		|	SSE_MATH opline->opcode, xmm0, op2_type, op2
	} else {
		|	SSE_MATH2 opline->opcode, xmm0, qword [Ra(op2_reg)+op2_offset]
	}
	|.else
	if (op1_type == IS_CONST) {
		|	FPU_LOAD op1_type, op1
	} else {
		|	FPU_GET_Z_DVAL Ra(op1_reg)+op1_offset
	}
	if (op2_type == IS_CONST) {
		|	FPU_MATH opline->opcode, op2_type, op2
	} else {
		|	FPU_MATH2 opline->opcode, qword [Ra(op2_reg)+op2_offset]
	}
	|.endif
	|	DOUBLE_STORE Ra(res_reg)+res_offset, xmm0
	if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
		|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE
	}

	return 1;
}


static int zend_jit_shift(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	zval *op2;
	uint32_t op1_info;
	zend_bool has_slow;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if ((op1_info & MAY_BE_UNDEF) ||
		opline->op2_type != IS_CONST ||
		Z_TYPE_P(RT_CONSTANT(op_array, opline->op2)) != IS_LONG ||
		Z_LVAL_P(RT_CONSTANT(op_array, opline->op2)) >= SIZEOF_ZEND_LONG * 8) {
		goto fallback;
	}

	has_slow = (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) != 0;

	op2 = RT_CONSTANT(op_array, opline->op2);

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
	|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
	}
	|	LONG_LOAD r0, opline->op1_type, opline->op1
	if (opline->opcode == ZEND_SR) {
	|	shr, r0, Z_LVAL_P(op2)
	} else {
	|	shl, r0, Z_LVAL_P(op2)
	}
	|	SET_Z_LVAL FP + opline->result.var, r0
	|	SET_Z_TYPE_INFO FP + opline->result.var, IS_LONG

	if (has_slow) {
		|.cold_code
		|9:
		|   lea FCARG1a, aword [FP + opline->result.var]
		|   lea FCARG2a, aword [FP + opline->op1.var]
		|.if X64
		|   LOAD_ADDR CARG3, op2
		|.else
		|   push dword op2
		|.endif
		if (opline->opcode == ZEND_SR) {
		|   EXT_CALL shift_right_function, r0
		} else {
		|   EXT_CALL shift_left_function, r0
		}
		|   jmp >1
		|.code
		|1:
	}

	|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline->lineno

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_helper(dasm_State    **Dst,
                                const zend_op  *opline,
                                zend_op_array  *op_array,
                                zend_ssa       *ssa,
                                zend_uchar      op1_type,
                                znode_op        op1,
                                uint32_t        op1_reg,
                                uint32_t        op1_offset,
                                uint32_t        op1_info,
                                zend_uchar      op2_type,
                                znode_op        op2,
                                uint32_t        op2_reg,
                                uint32_t        op2_offset,
                                uint32_t        op2_info,
                                uint32_t        res_reg,
                                uint32_t        res_offset,
                                uint32_t        res_info,
                                zend_bool       separate_op1)
/* Labels: 1,2,3,4,5 */
{
	zend_bool same_ops = (op1_type == op2_type) && (op1.var == op2.var);
	zend_bool has_slow =
		(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		((op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
		 (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))));

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_LONG, >3
			} else {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_LONG, >5
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			if (op2_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >1
				|.cold_code
				|1:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >5
				}
				if (!zend_jit_math_long_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
					return 0;
				}
				|	jmp >4
				|.code
			} else {
				|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >5
			}
		}
		if (!zend_jit_math_long_long(Dst, opline, op_array, ssa, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset, res_info)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >5
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					if (!same_ops) {
						|	IF_NOT_Z_TYPE, Ra(op2_reg)+op2_offset, IS_DOUBLE, >1
					} else {
						|	IF_NOT_Z_TYPE, Ra(op2_reg)+op2_offset, IS_DOUBLE, >5
					}
				}
				if (!zend_jit_math_double_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
					return 0;
				}
				|	jmp >4
			}
			if (!same_ops) {
				|1:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >5
				}
				if (!zend_jit_math_double_long(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
					return 0;
				}
				|	jmp >4
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >5
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >1
				} else {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >5
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |1:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >5
			}
			if (!zend_jit_math_double_long(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >4
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >5
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >1
				} else {
					|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >5
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|1:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_LONG, >5
			}
			if (!zend_jit_math_long_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >4
				|.code
			}
		}
	}

	|4:

	if (has_slow) {
		|.cold_code
		|5:
		|	SAVE_VALID_OPLINE opline
		if (separate_op1) {
			if (op1_reg != FCARG1a || op1_offset != 0) {
				|	SEPARATE_ZVAL_NOREF Ra(op1_reg)+op1_offset, op1_info, 0, op_array->filename, opline->lineno
			} else {
				|	SEPARATE_ZVAL_NOREF_REG op1_info, 0, op_array->filename, opline->lineno
			}
		}
		if (res_reg != FCARG1a || res_offset != 0) {
			|	lea	FCARG1a, [Ra(res_reg)+res_offset]
		}
		if (op1_type == IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, op1_type, op1
		} else {
			|	lea FCARG2a, [Ra(op1_reg)+op1_offset]
		}
		if (op2_type == IS_CONST) {
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, op2_type, op2
			|.else
			|	PUSH_ZVAL_ADDR op2_type, op2, r0
			|.endif
		} else {
			|.if X64
			|	lea CARG3, [Ra(op2_reg)+op2_offset]
			|.else
			|	lea r0, [Ra(op2_reg)+op2_offset]
			|	push r0
			|.endif
		}
		||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_ASSIGN_ADD) {
		|		EXT_CALL add_function, r0
		||	} else if (opline->opcode == ZEND_SUB || opline->opcode == ZEND_ASSIGN_SUB) {
		|		EXT_CALL sub_function, r0
		||	} else if (opline->opcode == ZEND_MUL || opline->opcode == ZEND_ASSIGN_MUL) {
		|		EXT_CALL mul_function, r0
		||	} else if (opline->opcode == ZEND_DIV || opline->opcode == ZEND_ASSIGN_DIV) {
		|		EXT_CALL div_function, r0
		||	} else {
		||		ZEND_ASSERT(0);
		||	}
		|	FREE_OP op1_type, op1, op1_info, 0, op_array, opline->lineno
		|	FREE_OP op2_type, op2, op2_info, 0, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		|	jmp <4
		|.code
	}

	return 1;
}

static int zend_jit_math(dasm_State **Dst, const zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		goto fallback;
	}

	if (opline->result_type == IS_TMP_VAR &&
	    (opline+1)->opcode == ZEND_SEND_VAL &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		/* Eliminate the following SEND_VAL */
		(*opnum)++;
		if (!reuse_ip) {
			zend_jit_start_reuse_ip();
			|	// call = EX(call);
			|	mov RX, EX->call
		}
		return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, RX, (opline+1)->result.var, RES_INFO(), 0);
	} else {
		return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, FP, opline->result.var, RES_INFO(), 0);
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_concat_helper(dasm_State    **Dst,
                                  const zend_op  *opline,
                                  zend_op_array  *op_array,
                                  zend_ssa       *ssa,
                                  zend_uchar      op1_type,
                                  znode_op        op1,
                                  uint32_t        op1_reg,
                                  uint32_t        op1_offset,
                                  uint32_t        op1_info,
                                  zend_uchar      op2_type,
                                  znode_op        op2,
                                  uint32_t        op2_reg,
                                  uint32_t        op2_offset,
                                  uint32_t        op2_info,
                                  uint32_t        res_reg,
                                  uint32_t        res_offset,
                                  uint32_t        res_info)
{
#if 1
	if ((op1_info & MAY_BE_STRING) && (op2_info & MAY_BE_STRING)) {
		if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING)) {
			|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_STRING, >5
		}
		if (op2_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING)) {
			|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_STRING, >5
		}
		if (op1_type != IS_CONST && op1_reg == res_reg && op1_offset == res_offset) {
			if (res_reg != FCARG1a || res_offset != 0) {
				|	lea	FCARG1a, [Ra(res_reg)+res_offset]
			}
			if (op2_type == IS_CONST) {
				|	LOAD_ZVAL_ADDR FCARG2a, op2_type, op2
			} else {
				|	lea FCARG2a, [Ra(op2_reg)+op2_offset]
			}
			|	EXT_CALL zend_jit_fast_assign_concat_helper, r0
		} else {
			if (res_reg != FCARG1a || res_offset != 0) {
				|	lea	FCARG1a, [Ra(res_reg)+res_offset]
			}
			if (op1_type == IS_CONST) {
				|	LOAD_ZVAL_ADDR FCARG2a, op1_type, op1
			} else {
				|	lea FCARG2a, [Ra(op1_reg)+op1_offset]
			}
			if (op2_type == IS_CONST) {
				|.if X64
				|	LOAD_ZVAL_ADDR CARG3, op2_type, op2
				|.else
				|	PUSH_ZVAL_ADDR op2_type, op2, r0
				|.endif
			} else {
				|.if X64
				|	lea CARG3, [Ra(op2_reg)+op2_offset]
				|.else
				|	lea r0, [Ra(op2_reg)+op2_offset]
				|	push r0
				|.endif
			}
			|	EXT_CALL zend_jit_fast_concat_helper, r0
		}
		|	FREE_OP op1_type, op1, op1_info, 0, op_array, opline->lineno
		|	FREE_OP op2_type, op2, op2_info, 0, op_array, opline->lineno
		|4:
	}
	if ((op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING)) ||
	    (op2_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING))) {
		if ((op1_info & MAY_BE_STRING) && (op2_info & MAY_BE_STRING)) {
			|.cold_code
			|5:
		}
#endif
		|	SAVE_VALID_OPLINE opline
		if (res_reg != FCARG1a || res_offset != 0) {
			|	lea	FCARG1a, [Ra(res_reg)+res_offset]
		}
		if (op1_type == IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, op1_type, op1
		} else {
			|	lea FCARG2a, [Ra(op1_reg)+op1_offset]
		}
		if (op2_type == IS_CONST) {
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, op2_type, op2
			|.else
			|	PUSH_ZVAL_ADDR op2_type, op2, r0
			|.endif
		} else {
			|.if X64
			|	lea CARG3, [Ra(op2_reg)+op2_offset]
			|.else
			|	lea r0, [Ra(op2_reg)+op2_offset]
			|	push r0
			|.endif
		}
		|	EXT_CALL concat_function, r0
		|	FREE_OP op1_type, op1, op1_info, 0, op_array, opline->lineno
		|	FREE_OP op2_type, op2, op2_info, 0, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
#if 1
		if ((op1_info & MAY_BE_STRING) && (op2_info & MAY_BE_STRING)) {
			|	jmp <4
			|.code
		}
	}
#endif

	return 1;
}

static int zend_jit_concat(dasm_State **Dst, const zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & MAY_BE_STRING) ||
	    !(op2_info & MAY_BE_STRING)) {
		goto fallback;
	}

	if (opline->result_type == IS_TMP_VAR &&
	    (opline+1)->opcode == ZEND_SEND_VAL &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		/* Eliminate the following SEND_VAL */
		(*opnum)++;
		if (!reuse_ip) {
			zend_jit_start_reuse_ip();
			|	// call = EX(call);
			|	mov RX, EX->call
		}
		return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, RX, (opline+1)->result.var, RES_INFO());
	} else {
		return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, FP, opline->result.var, RES_INFO());
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_fetch_dimension_address_inner(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, uint32_t type, uint32_t op1_info, uint32_t op2_info, uint32_t found, uint32_t not_found)
/* Labels: 1,2,3,4,5 */
{
	if (op2_info & MAY_BE_LONG) {
		if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) {
			|	// if (EXPECTED(Z_TYPE_P(dim) == IS_LONG))
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
		}
		|	// hval = Z_LVAL_P(dim);
		|	LONG_LOAD FCARG2a, opline->op2_type, opline->op2
		if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
			if (opline->op2_type == IS_CONST) {
				zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));
				if (val >= 0 && val < HT_MAX_SIZE) {
					|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
					|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
					|	jz >4 // HASH_FIND
					|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed))
					|.if X64
					|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
					|	cmp r0, val
					|.else
					|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], val
					|.endif
					if (type == BP_JIT_IS) {
						|	jbe >9 // NOT_FOUND
					} else {
						|	jbe >2 // NOT_FOUND
					}
					|	// _ret = &_ht->arData[_h].val;
					|	mov r0, aword [FCARG1a + offsetof(zend_array, arData)]
					|	add r0, val * sizeof(Bucket)
					if (type == BP_JIT_IS) {
						|	jmp >5
					} else {
						|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8
					}
				}
			} else {
				|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
				|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
				|	jz >4 // HASH_FIND
				|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed))
				|.if X64
				|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
				|	cmp r0, FCARG2a
				|.else
				|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], FCARG2a
				|.endif
				if (type == BP_JIT_IS) {
					|	jbe >9 // NOT_FOUND
				} else {
					|	jbe >2 // NOT_FOUND
				}
				|	// _ret = &_ht->arData[_h].val;
				|.if X64
				|	mov r0, FCARG2a
				|	shl r0, 5
				|.else
				|	imul r0, FCARG2a, sizeof(Bucket)
				|.endif
				|	add r0, aword [FCARG1a + offsetof(zend_array, arData)]
				if (type == BP_JIT_IS) {
					|	jmp >5
				} else {
					|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8
				}
			}
		}
		switch (type) {
			case BP_JIT_IS:
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					|4:
				}
				|	EXT_CALL zend_hash_index_find, r0
				|	test r0, r0
				|	jz >9 // NOT_FOUND
				if (op2_info & MAY_BE_STRING) {
					|	jmp >5
				}
				break;
			case BP_VAR_R:
			case BP_VAR_IS:
			case BP_VAR_UNSET:
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					if (opline->op2_type == IS_CONST) {
						zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));
						if (val >= 0 && val < HT_MAX_SIZE) {
							|	jmp >2 // NOT_FOUND
						}
					} else {
						|	jmp >2 // NOT_FOUND
					}
					|4:
				}
				|	EXT_CALL zend_hash_index_find, r0
				|	test r0, r0
				|	jz >2 // NOT_FOUND
				|.cold_code
				|2:
				switch (type) {
					case BP_VAR_R:
						|	// zend_error(E_NOTICE,"Undefined offset: " ZEND_LONG_FMT, hval);
						|	// retval = &EG(uninitialized_zval);
						|	UNDEFINED_OFFSET opline
						|	jmp >9
						break;
					case BP_VAR_IS:
					case BP_VAR_UNSET:
						|	// retval = &EG(uninitialized_zval);
						|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
						|	jmp >9
						break;
					default:
						ZEND_ASSERT(0);
				}
				|.code
				break;
			case BP_VAR_RW:
				|2:
				|	SAVE_VALID_OPLINE opline
				|	// zend_error(E_NOTICE,"Undefined offset: " ZEND_LONG_FMT, hval);
				|	//retval = zend_hash_index_update(ht, hval, &EG(uninitialized_zval));
				|	EXT_CALL zend_jit_fetch_dimension_rw_long_helper, r0
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					|	jmp >8
					|4:
					|	SAVE_VALID_OPLINE opline
					|	EXT_CALL zend_jit_hash_index_lookup_rw, r0
				}
				break;
			case BP_VAR_W:
				|2:
				|	//retval = zend_hash_index_add_new(ht, hval, &EG(uninitialized_zval));
				||	if (ZEND_DEBUG) {
				||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
				|.if X64
				|		LOAD_ADDR CARG4, filename
				|		mov CARG5d, opline->lineno
				|.else
				|		push opline->lineno
				|		push filename
				|.endif
				||	}
				|.if X64
				|		LOAD_ADDR CARG3, &EG(uninitialized_zval)
				|.else
				|		PUSH_ADDR &EG(uninitialized_zval), r0
				|.endif
				|	EXT_CALL _zend_hash_index_add_new, r0
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					|	jmp >8
					|4:
					|	EXT_CALL zend_jit_hash_index_lookup_w, r0
				}
				break;
			default:
				ZEND_ASSERT(0);
		}

		if (type != BP_JIT_IS && (op2_info & MAY_BE_STRING)) {
			|	jmp >8
		}
	}

	if (op2_info & MAY_BE_STRING) {
		|3:
		if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
			|	// if (EXPECTED(Z_TYPE_P(dim) == IS_STRING))
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_STRING, >3
		}
		|	// offset_key = Z_STR_P(dim);
		|	LONG_LOAD FCARG2a, opline->op2_type, opline->op2
		|	// retval = zend_hash_find(ht, offset_key);
		switch (type) {
			case BP_JIT_IS:
				if (opline->op2_type != IS_CONST) {
					|	EXT_CALL zend_jit_symtable_find, r0
				} else {
					|	EXT_CALL zend_hash_find, r0
				}
				|	test r0, r0
				|	jz >9 // NOT_FOUND
				|	// if (UNEXPECTED(Z_TYPE_P(retval) == IS_INDIRECT))
				|	IF_NOT_Z_TYPE r0, IS_INDIRECT, >1
				|	GET_Z_PTR r0, r0
				|1:
				break;
			case BP_VAR_R:
			case BP_VAR_IS:
			case BP_VAR_UNSET:
				if (opline->op2_type != IS_CONST) {
					|	EXT_CALL zend_jit_symtable_find, r0
				} else {
					|	EXT_CALL zend_hash_find, r0
				}
				|	test r0, r0
				|	jz >2 // NOT_FOUND
				|	// if (UNEXPECTED(Z_TYPE_P(retval) == IS_INDIRECT))
				|	IF_Z_TYPE r0, IS_INDIRECT, >1 // SLOW
				|.cold_code
				|1:
				|	//	retval = Z_INDIRECT_P(retval);
				|	GET_Z_PTR r0, r0
				|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8
				|2:
				switch (type) {
					case BP_VAR_R:
						//	zend_error(E_NOTICE, "Undefined index: %s", ZSTR_VAL(offset_key));
						|	UNDEFINED_INDEX opline
						|	jmp >9
						break;
					case BP_VAR_IS:
					case BP_VAR_UNSET:
						|	// retval = &EG(uninitialized_zval);
						|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
						|	jmp >9
						break;
					default:
						ZEND_ASSERT(0);
				}
				|.code
				break;
			case BP_VAR_RW:
				|	SAVE_VALID_OPLINE opline
				if (opline->op2_type != IS_CONST) {
					|	EXT_CALL zend_jit_symtable_lookup_rw, r0
				} else {
					|	EXT_CALL zend_jit_hash_lookup_rw, r0
				}
				break;
			case BP_VAR_W:
				if (opline->op2_type != IS_CONST) {
					|	EXT_CALL zend_jit_symtable_lookup_w, r0
				} else {
					|	EXT_CALL zend_jit_hash_lookup_w, r0
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
	}

	if (type == BP_JIT_IS && (op2_info & (MAY_BE_LONG|MAY_BE_STRING))) {
	    |5:
		if (op1_info & MAY_BE_ARRAY_OF_REF) {
			|	ZVAL_DEREF r0, MAY_BE_REF
		}
		|	cmp byte [r0 + 8], IS_NULL
		|	jle >9 // NOT FOUND
	}

	if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
		if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
			|.cold_code
			|3:
		}
		|	SAVE_VALID_OPLINE opline
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		switch (type) {
			case BP_VAR_R:
				|.if X64
				|   lea CARG3, [FP + opline->result.var]
				|.else
				|   lea r0, [FP + opline->result.var]
				|	push r0
				|.endif
				|	EXT_CALL zend_jit_fetch_dim_r_helper, r0
				|	jmp >9
				break;
			case BP_JIT_IS:
				|	EXT_CALL zend_jit_fetch_dim_isset_helper, r0
				|	test r0, r0
				|	jne >8
				|	jmp >9
				break;
			case BP_VAR_IS:
			case BP_VAR_UNSET:
				|.if X64
				|   lea CARG3, [FP + opline->result.var]
				|.else
				|   lea r0, [FP + opline->result.var]
				|	push r0
				|.endif
				|	EXT_CALL zend_jit_fetch_dim_is_helper, r0
				|	jmp >9
				break;
			case BP_VAR_RW:
				|	EXT_CALL zend_jit_fetch_dim_rw_helper, r0
				|	test r0, r0
				|	jne >8
				|	jmp >9
				break;
			case BP_VAR_W:
				|	EXT_CALL zend_jit_fetch_dim_w_helper, r0
				|	test r0, r0
				|	jne >8
				|	jmp >9
				break;
			default:
				ZEND_ASSERT(0);
		}
		if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
			|.code
		}
	}

	return 1;
}

static int zend_jit_simple_assign(dasm_State    **Dst,
                                  const zend_op  *opline,
                                  zend_op_array  *op_array,
                                  zend_ssa       *ssa,
                                  uint32_t        var_reg,
                                  uint32_t        var_offset,
                                  uint32_t        var_info,
                                  zend_uchar      val_type,
                                  znode_op        val,
                                  uint32_t        val_info,
                                  uint32_t        var2,
                                  int             in_cold)
/* Labels: 1,2,3 */
{
	ZEND_ASSERT(var_reg != r0);
	if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);
		if (var2 == (uint32_t)-1) {
			|	ZVAL_COPY_CONST Ra(var_reg)+var_offset, var_info, zv, r0
		} else {
			|	ZVAL_COPY_CONST_2 Ra(var_reg)+var_offset, FP + var2, var_info, zv, r0
		}
		if (Z_REFCOUNTED_P(zv)) {
			if (var2 == (uint32_t)-1) {
				|	ADDREF_CONST zv, r0
			} else {
				|	ADDREF_CONST_2 zv, r0
			}
		}
	} else {
		if (val_info & MAY_BE_UNDEF) {
			if (in_cold) {
				|	IF_NOT_Z_TYPE FP + val.var, IS_UNDEF, >2
			} else {
				|	IF_Z_TYPE FP + val.var, IS_UNDEF, >1
				|.cold_code
				|1:
			}
			|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
			if (var_reg != FP) {
				|	mov aword [r4], Ra(var_reg) // save
			}
			|	SAVE_VALID_OPLINE opline
			|	mov FCARG1d, val.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			if (var_reg != FP) {
				|	mov Ra(var_reg), aword [r4] // restore
			}
			|	SET_Z_TYPE_INFO Ra(var_reg)+var_offset, IS_NULL
			if (var2 != (uint32_t)-1) {
				|	SET_Z_TYPE_INFO FP + var2, IS_NULL
			}
			|	jmp	>3
			if (in_cold) {
				|2:
			} else {
				|.code
			}
		}
		if (val_info & MAY_BE_REF) {
			if (val_type == IS_CV) {
				ZEND_ASSERT(var_reg != r2);
				|	lea r2, [FP + val.var]
				|	ZVAL_DEREF r2, val_info
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE_clobber_src Ra(var_reg)+var_offset, r2, val_info, r2, edx, r0
				} else {
					|	ZVAL_COPY_VALUE_clobber_src_2 Ra(var_reg)+var_offset, FP + var2, r2, val_info, r2, edx, r0
				}
			} else {
				if (in_cold) {
					|	IF_NOT_Z_TYPE FP + val.var, IS_REFERENCE, >1
				} else {
					|	IF_Z_TYPE FP + val.var, IS_REFERENCE, >1
					|.cold_code
					|1:
				}
				|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
				|	GET_Z_PTR r2, FP + val.var
				|	GC_DELREF r2
				|	// ZVAL_COPY_VALUE(return_value, &ref->value);
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE_clobber_src Ra(var_reg)+var_offset, r2 + 8, val_info, r2, edx, r0
				} else {
					|	ZVAL_COPY_VALUE_clobber_src_2 Ra(var_reg)+var_offset, FP + var2, r2 + 8, val_info, r2, edx, r0
				}
				|	je >2
				|	IF_NOT_REFCOUNTED dh, >3
				if (var2 == (uint32_t)-1) {
					|	GC_ADDREF r0
				} else {
					|	add dword [r0], 2
				}
				|	jmp >3
				|2:
				if (var2 != (uint32_t)-1) {
					|	IF_NOT_REFCOUNTED dh, >2
					|	GC_ADDREF r0
					|2:
				}
				|	EFREE_24 aword [FP + val.var], op_array, opline
				|	jmp >3
				if (in_cold) {
					|1:
				} else {
					|.code
				}
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE Ra(var_reg)+var_offset, FP + val.var, val_info, r2, edx, r0
				} else {
					|	ZVAL_COPY_VALUE_2 Ra(var_reg)+var_offset, FP + var2, FP + val.var, val_info, r2, edx, r0
				}
			}
		} else {
			if (var2 == (uint32_t)-1) {
				|	ZVAL_COPY_VALUE Ra(var_reg)+var_offset, FP + val.var, val_info, r2, edx, r0
			} else {
				|	ZVAL_COPY_VALUE_2 Ra(var_reg)+var_offset, FP + var2, FP + val.var, val_info, r2, edx, r0
			}
		}
		if (val_type == IS_CV) {
			if (var2 == (uint32_t)-1) {
				|	TRY_ADDREF val_info, dh, r0
			} else {
				|	TRY_ADDREF_2 val_info, dh, r0
			}
		} else {
			if (var2 != (uint32_t)-1) {
				|	TRY_ADDREF val_info, dh, r0
			}
		}
		|3:
	}
	return 1;
}

static int zend_jit_assign_to_variable(dasm_State    **Dst,
                                       const zend_op  *opline,
                                       zend_op_array  *op_array,
                                       zend_ssa       *ssa,
                                       uint32_t        var_reg,
                                       uint32_t        var_offset,
                                       uint32_t        var_info,
                                       zend_uchar      val_type,
                                       znode_op        val,
                                       uint32_t        val_info,
                                       uint32_t        var2)
/* Labels: 1,2,3,4,5 */
{
	if (var_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
		int in_cold = 0;

		ZEND_ASSERT(var_reg != r0);
		if (var_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
			|	IF_Z_REFCOUNTED Ra(var_reg)+var_offset, >1
			|.cold_code
			|1:
			in_cold = 1;
		}
		|	// TODO: support for object->set
		|	// TODO: support for assignment to itself
		|	GET_Z_PTR r0, Ra(var_reg)+var_offset
		|	GC_DELREF r0
		if (RC_MAY_BE_1(var_info)) {
			if (RC_MAY_BE_N(var_info)) {
				|	jnz >4
			}
			|	mov aword [r4], r0 // save
			if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, var_reg, var_offset, var_info, val_type, val, val_info, var2, in_cold)) {
				return 0;
			}
			|	mov FCARG1a, aword [r4] // restore
			|	ZVAL_DTOR_FUNC op_array->filename, opline->lineno
			|	jmp >3
			|4:
		}
		if (RC_MAY_BE_N(var_info)) {
			if (var_reg == FP) {
				|	GET_Z_PTR FCARG1a, Ra(var_reg)+var_offset
				|	IF_GC_MAY_NOT_LEAK FCARG1a, eax, >5
			} else if (var_reg != FCARG1a) {
				|	GET_Z_PTR FCARG1a, Ra(var_reg)+var_offset
				|	IF_GC_MAY_NOT_LEAK FCARG1a, eax, >5
				|	mov [r4], Ra(var_reg) // save
			} else {
				|	GET_Z_PTR r0, Ra(var_reg)+var_offset
				|	IF_GC_MAY_NOT_LEAK r0, eax, >5
				|	mov [r4], Ra(var_reg) // save
				|	GET_Z_PTR FCARG1a, Ra(var_reg)+var_offset
			}
			|	EXT_CALL gc_possible_root, r0
			if (var_reg != FP) {
				|	mov Ra(var_reg), [r4] // restore
			}
			if (in_cold) {
				|	jmp >5
				|.code
			}
	    } else if (in_cold) {
			|.code
	    }
		|5:
	}

	if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, var_reg, var_offset, var_info, val_type, val, val_info, var2, 0)) {
		return 0;
	}
	|3:

	return 1;
}

static int zend_jit_assign_dim(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, val_info;

	if (opline->op1_type != IS_CV) {
		goto fallback;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	val_info = OP1_DATA_INFO();

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	SEPARATE_ARRAY_REG op1_info, 1, op_array->filename, opline->lineno
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	SEPARATE_ARRAY opline->op1_type, opline->op1, op1_info, 1, op_array->filename, opline->lineno
		}
	} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) {
		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
		    if (op1_info & MAY_BE_REF) {
				|	cmp byte [FCARG1a + 8], IS_FALSE
			} else {
				|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
			}
			|	jg >7
		}
		|	// ZVAL_NEW_ARR(container);
		|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
		if (op1_info & MAY_BE_REF) {
			|	mov [r4], FCARG1a // save
		}
		||	if (ZEND_DEBUG) {
		||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|.if X64
		|		LOAD_ADDR CARG3, filename
		|		xor CARG4d, opline->lineno
		|.else
		|		push opline->lineno
		|		push filename
		|.endif
		||	} else {
		|.if not X64
		|		sub r4, 8
		|.endif
		||	}
		|.if X64
		|	LOAD_ADDR CARG2, 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|.else
		|	push 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|	push FCARG1a
		|.endif
		|	EXT_CALL _array_init, r0
		|.if not X64
		|	add r4, 16
		|.endif
		if (op1_info & MAY_BE_REF) {
			|	mov FCARG1a, [r4] // restore
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
		|6:
		if (opline->op2_type == IS_UNUSED) {
			|	// var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		mov CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	}
			|	EXT_CALL _zend_hash_next_index_insert, r0
			|	// if (UNEXPECTED(!var_ptr)) {
			|	test r0, r0
			|	jz >1
			|.cold_code
			|1:
			|	// zend_error(E_WARNING, "Cannot add element to the array as the next element is already occupied");
			|	CANNOT_ADD_ELEMENT opline
			|	//ZEND_VM_C_GOTO(assign_dim_op_ret_null);
			|	jmp >9
			|.code
			|	mov FCARG1a, r0
		} else {
			if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, BP_VAR_W, op1_info, op2_info, 8, 8)) {
				return 0;
			}

			|8:
			|	mov FCARG1a, r0
		}

		if (opline->op2_type == IS_UNUSED) {
			uint32_t var_info = zend_array_element_type(op1_info, 0, 0);

			if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, val_info,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var, 0)) {
				return 0;
			}
		} else {
			uint32_t var_info = zend_array_element_type(op1_info, 0, 0);

			|	// value = zend_assign_to_variable(variable_ptr, value, OP_DATA_TYPE);
			|	ZVAL_DEREF FCARG1a, var_info
			if (!zend_jit_assign_to_variable(Dst, opline, op_array, ssa, FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, val_info,
					opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
				return 0;
			}
		}
	}

	if (((op1_info & MAY_BE_ARRAY) &&
	     (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE))) ||
	    (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)))) {
		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			|.cold_code
			|7:
		}

		if ((op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) &&
		    (op1_info & MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
			    if (op1_info & MAY_BE_REF) {
					|	cmp byte [FCARG1a + 8], IS_FALSE
				} else {
					|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
				}
				|	jg >2
			}
			|	// ZVAL_NEW_ARR(container);
			|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
			if (op1_info & MAY_BE_REF) {
				|	mov [r4], FCARG1a // save
			}
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		xor CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	} else {
			|.if not X64
			|		sub r4, 8
			|.endif
			||	}
			|.if X64
			|	LOAD_ADDR CARG2, 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|.else
			|	push 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|	push FCARG1a
			|.endif
			|	EXT_CALL _array_init, r0
			|.if not X64
			|	add r4, 16
			|.endif
			if (op1_info & MAY_BE_REF) {
				|	mov FCARG1a, [r4] // restore
				|	GET_Z_PTR FCARG1a, FCARG1a
			} else {
				|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
			}
			|	// ZEND_VM_C_GOTO(assign_dim_op_new_array);
			|	jmp <6
			|2:
		}

		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			}
		    if (opline->op2_type == IS_UNUSED) {
				|	xor FCARG2a, FCARG2a
			} else {
				|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			}
			if (opline->result_type == IS_UNUSED) {
				|.if X64
				|	xor CARG4, CARG4
				|.else
				|	push 0
				|.endif
			} else {
				|.if X64
				|	LOAD_ZVAL_ADDR CARG4, opline->result_type, opline->result
				|.else
				|	PUSH_ZVAL_ADDR opline->result_type, opline->result, r0
				|.endif
			}
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, (opline+1)->op1_type, (opline+1)->op1
			|.else
			|	PUSH_ZVAL_ADDR (opline+1)->op1_type, (opline+1)->op1, r0
			|.endif
			|	EXT_CALL zend_jit_assign_dim_helper, r0

#ifdef ZEND_JIT_USE_RC_INFERENCE
			if (((opline+1)->op1_type & (IS_TMP_VAR|IS_VAR)) && (val_info & MAY_BE_RC1)) {
				/* ASSIGN_DIM may increase refcount of the value */
				val_info |= MAY_BE_RCN;
			}
#endif

			|	FREE_OP (opline+1)->op1_type, (opline+1)->op1, val_info, 0, op_array, opline->lineno
		}

		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
				|	jmp >9 // END
			}
			|.code
		}
	}

#ifdef ZEND_JIT_USE_RC_INFERENCE
	if ((opline->op2_type & (IS_TMP_VAR|IS_VAR)) && (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
		/* ASSIGN_DIM may increase refcount of the key */
		op2_info |= MAY_BE_RCN;
	}
#endif

	|9:
	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline->lineno

	if (zend_may_throw(opline, op_array, ssa)) {
		zend_jit_check_exception(Dst);
	}

	return 1;

fallback:
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign_dim_op(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED) {
		goto fallback;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	SEPARATE_ARRAY_REG op1_info, 1, op_array->filename, opline->lineno
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	SEPARATE_ARRAY opline->op1_type, opline->op1, op1_info, 1, op_array->filename, opline->lineno
		}
	} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) {
		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
		    if (op1_info & MAY_BE_REF) {
				|	cmp byte [FCARG1a + 8], IS_FALSE
			} else {
				|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
			}
			|	jg >7
		}
		if (op1_info & MAY_BE_UNDEF) {
			if (op1_info & (MAY_BE_NULL|MAY_BE_FALSE)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			}
			|	SAVE_VALID_OPLINE opline
			|	mov FCARG1a, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		|	// ZVAL_NEW_ARR(container);
		|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
		if (op1_info & MAY_BE_REF) {
			|	mov [r4], FCARG1a // save
		}
		||	if (ZEND_DEBUG) {
		||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|.if X64
		|		LOAD_ADDR CARG3, filename
		|		xor CARG4d, opline->lineno
		|.else
		|		push opline->lineno
		|		push filename
		|.endif
		||	} else {
		|.if not X64
		|		sub r4, 8
		|.endif
		||	}
		|.if X64
		|	LOAD_ADDR CARG2, 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|.else
		|	push 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|	push FCARG1a
		|.endif
		|	EXT_CALL _array_init, r0
		|.if not X64
		|	add r4, 16
		|.endif
		if (op1_info & MAY_BE_REF) {
			|	mov FCARG1a, [r4] // restore
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
		uint32_t var_info = zend_array_element_type(op1_info, 0, 0);

		|6:
		if (opline->op2_type == IS_UNUSED) {
			|	// var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		mov CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	}
			|	EXT_CALL _zend_hash_next_index_insert, r0
			|	// if (UNEXPECTED(!var_ptr)) {
			|	test r0, r0
			|	jz >1
			|.cold_code
			|1:
			|	// zend_error(E_WARNING, "Cannot add element to the array as the next element is already occupied");
			|	CANNOT_ADD_ELEMENT opline
			|	//ZEND_VM_C_GOTO(assign_dim_op_ret_null);
			|	jmp >9
			|.code
			|	mov FCARG1a, r0
		} else {
			if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, BP_VAR_RW, op1_info, op2_info, 8, 8)) {
				return 0;
			}

			|8:
			|	mov FCARG1a, r0
			if (op1_info & (MAY_BE_ARRAY_OF_REF)) {
				|	ZVAL_DEREF FCARG1a, MAY_BE_REF
			}
		}

		switch (opline->opcode) {
			case ZEND_ASSIGN_ADD:
			case ZEND_ASSIGN_SUB:
			case ZEND_ASSIGN_MUL:
			case ZEND_ASSIGN_DIV:
				if (!zend_jit_math_helper(Dst, opline, op_array, ssa, IS_CV, opline->op1, FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, FP, (opline+1)->op1.var, OP1_DATA_INFO(), FCARG1a, 0, OP1_DEF_INFO(), 1)) {
					return 0;
				}
				break;
			case ZEND_ASSIGN_CONCAT:
				if (!zend_jit_concat_helper(Dst, opline, op_array, ssa, IS_CV, opline->op1, FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, FP, (opline+1)->op1.var, OP1_DATA_INFO(), FCARG1a, 0, OP1_DEF_INFO())) {
					return 0;
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
	}

	if (((op1_info & MAY_BE_ARRAY) &&
	     (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE))) ||
	    (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)))) {
		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			|.cold_code
			|7:
		}

		if ((op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) &&
		    (op1_info & MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
				if (op1_info & (MAY_BE_NULL|MAY_BE_FALSE)) {
				    if (op1_info & MAY_BE_REF) {
						|	cmp byte [FCARG1a + 8], IS_FALSE
					} else {
						|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
					}
					|	jg >2
				}
			}
			if (op1_info & MAY_BE_UNDEF) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
				|	SAVE_VALID_OPLINE opline
				|	mov FCARG1a, opline->op1.var
				|	EXT_CALL zend_jit_undefined_op_helper, r0
				|1:
			}
			|	// ZVAL_NEW_ARR(container);
			|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
			if (op1_info & MAY_BE_REF) {
				|	mov [r4], FCARG1a // save
			}
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		xor CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	} else {
			|.if not X64
			|		sub r4, 8
			|.endif
			||	}
			|.if X64
			|	LOAD_ADDR CARG2, 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|.else
			|	push 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|	push FCARG1a
			|.endif
			|	EXT_CALL _array_init, r0
			|.if not X64
			|	add r4, 16
			|.endif
			if (op1_info & MAY_BE_REF) {
				|	mov FCARG1a, [r4] // restore
				|	GET_Z_PTR FCARG1a, FCARG1a
			} else {
				|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
			}
			|	// ZEND_VM_C_GOTO(assign_dim_op_new_array);
			|	jmp <6
			|2:
		}

		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			}
		    if (opline->op2_type == IS_UNUSED) {
				|	xor FCARG2a, FCARG2a
			} else {
				|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			}
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, (opline+1)->op1_type, (opline+1)->op1
			|.else
			|	PUSH_ZVAL_ADDR (opline+1)->op1_type, (opline+1)->op1, r0
			|.endif
			switch (opline->opcode) {
				case ZEND_ASSIGN_ADD:
					|	EXT_CALL zend_jit_assign_dim_add_helper, r0
					break;
				case ZEND_ASSIGN_SUB:
					|	EXT_CALL zend_jit_assign_dim_sub_helper, r0
					break;
				case ZEND_ASSIGN_MUL:
					|	EXT_CALL zend_jit_assign_dim_mul_helper, r0
					break;
				case ZEND_ASSIGN_DIV:
					|	EXT_CALL zend_jit_assign_dim_div_helper, r0
					break;
				case ZEND_ASSIGN_CONCAT:
					|	EXT_CALL zend_jit_assign_dim_concat_helper, r0
					break;
				default:
					ZEND_ASSERT(0);
			}
		}

		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
				|	jmp >9 // END
			}
			|.code
		}
	}

	|9:

	return 1;

fallback:
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign_op(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		return zend_jit_assign_dim_op(Dst, opline, op_array, ssa);
	} else if (opline->extended_value == ZEND_ASSIGN_OBJ) {
		goto fallback;
	}

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED) {
		goto fallback;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	switch (opline->opcode) {
		case ZEND_ASSIGN_ADD:
		case ZEND_ASSIGN_SUB:
		case ZEND_ASSIGN_MUL:
		case ZEND_ASSIGN_DIV:
			if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
			    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
				goto fallback;
			}
			break;
		case ZEND_ASSIGN_CONCAT:
			if (!(op1_info & MAY_BE_STRING) ||
			    !(op2_info & MAY_BE_STRING)) {
				goto fallback;
			}
			break;
		default:
			ZEND_ASSERT(0);
	}

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
		switch (opline->opcode) {
			case ZEND_ASSIGN_ADD:
			case ZEND_ASSIGN_SUB:
			case ZEND_ASSIGN_MUL:
			case ZEND_ASSIGN_DIV:
				return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FCARG1a, 0, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, FCARG1a, 0, OP1_DEF_INFO(), 1);
			case ZEND_ASSIGN_CONCAT:
				return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FCARG1a, 0, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, FCARG1a, 0, OP1_DEF_INFO());
			default:
				ZEND_ASSERT(0);
		}
	} else {
		switch (opline->opcode) {
			case ZEND_ASSIGN_ADD:
			case ZEND_ASSIGN_SUB:
			case ZEND_ASSIGN_MUL:
			case ZEND_ASSIGN_DIV:
				return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, FP, opline->op1.var, OP1_DEF_INFO(), 1);
			case ZEND_ASSIGN_CONCAT:
				return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, FP, opline->op2.var, op2_info, FP, opline->op1.var, OP1_DEF_INFO());
			default:
				ZEND_ASSERT(0);
		}
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp_long_long(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;
	int swap = 0;

	if (opline->op1_type == IS_CONST && opline->op2_type != IS_CONST) {
		zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op1));

		|   .if X64
		||  if (!IS_SIGNED_32BIT(val)) {
		|   	mov64 r0, val
		|   	cmp aword [FP + opline->op2.var], r0
		||  } else {
		|   	cmp aword [FP + opline->op2.var], val
		||  }
		|   .else
		|   	cmp aword [FP + opline->op2.var], val
		|   .endif
		swap = 1;
	} else if (opline->op2_type == IS_CONST && opline->op1_type != IS_CONST) {
		zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));

		|   .if X64
		||  if (!IS_SIGNED_32BIT(val)) {
		|   	mov64 r0, val
		|   	cmp aword [FP + opline->op1.var], r0
		||  } else {
		|   	cmp aword [FP + opline->op1.var], val
		||  }
		|   .else
		|   	cmp aword [FP + opline->op1.var], val
		|   .endif
	} else {
		|	LONG_LOAD r0, opline->op1_type, opline->op1
		|	LONG_OP cmp, r0, opline->op2_type, opline->op2
	}
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					| jle => target_label
				} else {
					| jge => target_label
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					| jl => target_label
				} else {
					| jg => target_label
				}
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					| jg => target_label
				} else {
					| jl => target_label
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					| jge => target_label
				} else {
					| jle => target_label
				}
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
			    if (swap) {
					| jle => target_label
			    } else {
					| jge => target_label
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					| jl => target_label
				} else {
					| jg => target_label
				}
				break;
		}
		target_label = ssa->cfg.blocks[b].successors[1];
		| jmp => target_label
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					|	setg al
				} else {
					|	setl al
				}
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					|	setge al
				} else {
					|	setle al
				}
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_double_common(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jnae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jna => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
		}
		target_label = ssa->cfg.blocks[b].successors[1];
		| jmp => target_label
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	jp >1
				|	mov eax, IS_TRUE
				|	je >2
				|1:
				|	mov eax, IS_FALSE
				|2:
				break;
			case ZEND_IS_NOT_EQUAL:
				|	jp >1
				|	mov eax, IS_FALSE
				|	je >2
				|1:
				|	mov eax, IS_TRUE
				|2:
				break;
			case ZEND_IS_SMALLER:
				|	setnae al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setna al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_long_double(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG xmm0, opline->op1_type, opline->op1
	|	SSE_OP ucomisd, xmm0, opline->op2_type, opline->op2
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LONG_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_long(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD xmm0, opline->op1_type, opline->op1
	|	SSE_LOAD_LONG xmm1, opline->op2_type, opline->op2
	|	ucomisd xmm0, xmm1
	|.else
	|	FPU_LONG_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_double(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD xmm0, opline->op1_type, opline->op1
	|	SSE_OP ucomisd, xmm0, opline->op2_type, opline->op2
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_slow(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	cmp aword [FP + opline->result.var], 0
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
		target_label = ssa->cfg.blocks[b].successors[1];
		| jmp => target_label
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow;

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	has_slow =
		(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		((op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
		 (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))));

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >4
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			if (op2_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
				if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
		}
		if (!zend_jit_cmp_long_long(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					if (!same_ops) {
						|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >5
					} else {
						|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
					}
				}
				if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
				}
				if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
			if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
			if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	if (has_slow ||
	    (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
	    (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE)))) {
		if (has_slow) {
			|.cold_code
			|9:
		}
		|	SAVE_VALID_OPLINE opline
		|	lea	FCARG1a, [FP + opline->result.var]
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
			|	IF_NOT_Z_TYPE FCARG2a, IS_UNDEF, >1
			|	mov FCARG1a, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
			|1:
		}
		if (opline->op2_type == IS_CV && (op2_info & MAY_BE_UNDEF)) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_UNDEF, >1
			|	mov [r4], FCARG2a // save
			|	mov FCARG1a, opline->op2.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|	mov FCARG2a, [r4] // restore
			|.if X64
			|	LOAD_ADDR CARG3, &EG(uninitialized_zval)
			|.else
			|	PUSH_ADDR &EG(uninitialized_zval), r0
			|.endif
			|	jmp >2
			|1:
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
			|.else
			|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
			|.endif
			|2:
		} else {
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
			|.else
			|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
			|.endif
		}
		|	EXT_CALL compare_function, r0
		||	if (opline->opcode != ZEND_CASE) {
		|		FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline->lineno
		||	}
		|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		if (!zend_jit_cmp_slow(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (has_slow) {
			|	jmp >6
			|.code
		}
	}

	|6:
	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
	}

	return 1;
}

static int zend_jit_jmpznz(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info = OP1_INFO();
	uint32_t true_label, false_label;

	if (opline->opcode == ZEND_JMPZ) {
		true_label = (uint32_t)-1;
		false_label = ssa->cfg.blocks[b].successors[0];
	} else if (opline->opcode == ZEND_JMPNZ) {
		true_label = ssa->cfg.blocks[b].successors[0];
		false_label = (uint32_t)-1;
	} else if (opline->opcode == ZEND_JMPZNZ) {
		true_label = ssa->cfg.blocks[b].successors[1];
		false_label = ssa->cfg.blocks[b].successors[0];
	} else {
		ZEND_ASSERT(0);
	}

	if ((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY)) == MAY_BE_TRUE) {
		if (true_label != (uint32_t)-1) {
			|	jmp =>true_label;
		}
	} else if (!(op1_info & (MAY_BE_ANY - (MAY_BE_NULL|MAY_BE_FALSE)))) {
		if (op1_info & MAY_BE_UNDEF) {
			if (op1_info & MAY_BE_ANY) {
				|	IF_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
				|.cold_code
				|1:
			}
			|	mov FCARG1d, opline->op1.var
			|	SAVE_VALID_OPLINE opline
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			if (zend_may_throw(opline, op_array, ssa)) {
				if (!zend_jit_check_exception(Dst)) {
					return 0;
				}
			}
			if (op1_info & MAY_BE_ANY) {
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label;
				} else {
					|	jmp >9
				}
				|.code
			}
		}
		if (false_label != (uint32_t)-1) {
			|	jmp =>false_label;
		}
	} else {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info

		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE)) {
			if (op1_info & MAY_BE_TRUE) {
				if (true_label != (uint32_t)-1) {
					|	IF_Z_TYPE FCARG1a, IS_TRUE, =>true_label
				} else if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
					|	IF_Z_TYPE FCARG1a, IS_TRUE, >9
				} else {
					|	//IF_Z_TYPE FCARG1a, IS_TRUE, >9
					|	cmp byte [FCARG1a + 8], IS_TRUE
				}
			} else {
				|	cmp byte [FCARG1a + 8], IS_TRUE
			}

			if (op1_info & MAY_BE_UNDEF) {
				if (op1_info & (MAY_BE_ANY - (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
					|	jg >2
				}
				|	IF_Z_TYPE FCARG1a, IS_UNDEF, >1
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				} else if (op1_info & (MAY_BE_ANY - (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
					|	jmp >9
				}
				|.cold_code
				|1:
				|	mov FCARG1d, opline->op1.var
				|	SAVE_VALID_OPLINE opline
				|	EXT_CALL zend_jit_undefined_op_helper, r0
				if (zend_may_throw(opline, op_array, ssa)) {
					if (!zend_jit_check_exception(Dst)) {
						return 0;
					}
				}
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				} else {
					|	jmp >9
				}
				|.code
			} else if (op1_info & (MAY_BE_NULL|MAY_BE_FALSE)) {
				if (false_label != (uint32_t)-1) {
					|	jl =>false_label
					if (!(op1_info & MAY_BE_LONG) &&
					    (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)))) {
						|	jmp >2
					}
				} else if (op1_info & (MAY_BE_ANY - (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
					if (op1_info & MAY_BE_LONG) {
						|	jl >9
					} else {
						|	jg >2
					}
				}
			}
		}

		if (op1_info & MAY_BE_LONG) {
			|2:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FCARG1a, IS_LONG, >2
			}
			|	cmp	aword [FCARG1a], 0
			if (true_label != (uint32_t)-1) {
				|	jne =>true_label
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				}
			} else {
				|	je =>false_label
			}
		}

		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG))) {
			if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
				|.cold_code
				|2:
			}
			|	SAVE_VALID_OPLINE opline
			|	EXT_CALL zend_is_true, r0

			if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
			    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
				|	test byte [FP + opline->op1.var + 9], IS_TYPE_REFCOUNTED
				|	jz >1
				|	mov FCARG1a, aword [FP + opline->op1.var]
				|	dec dword [FCARG1a]
				|	jnz >1
				|	mov aword [r4], r0 // save
				|	ZVAL_DTOR_FUNC op_array->filename, opline->lineno
				|	mov r0, aword [r4] // restore
				|1:
			}
			if (zend_may_throw(opline, op_array, ssa)) {
				if (!zend_jit_check_exception(Dst)) {
					return 0;
				}
			}

			|	test r0, r0
			if (true_label != (uint32_t)-1) {
				|	jne =>true_label
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
					|	jmp >9
				}
			} else {
				|	je =>false_label
				if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
					|	jmp >9
				}
			}

			if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
				|.code
			}
		}

		|9:
	}

	return 1;
}

static int zend_jit_qm_assign(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info = OP1_INFO();

	return zend_jit_simple_assign(Dst, opline, op_array, ssa, FP, opline->result.var, -1, opline->op1_type, opline->op1, op1_info, -1, 0);
}

static int zend_jit_assign(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
		if (!zend_jit_assign_to_variable(Dst, opline, op_array, ssa, FCARG1a, 0, op1_info, opline->op2_type, opline->op2, op2_info,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
			return 0;
		}
	} else {
		if (!zend_jit_assign_to_variable(Dst, opline, op_array, ssa, FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
			return 0;
		}
	}

	if (zend_may_throw(opline, op_array, ssa)) {
		zend_jit_check_exception(Dst);
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_push_call_frame(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_function *func)
{
	uint32_t used_stack;

	if (func) {
		used_stack = zend_vm_calc_used_stack(opline->extended_value, func);
	} else {
		used_stack = (ZEND_CALL_FRAME_SLOT + opline->extended_value) * sizeof(zval);

		|	// if (EXPECTED(ZEND_USER_CODE(func->type))) {
		|	test byte [r0 + offsetof(zend_function, type)], 1
		|	mov FCARG1a, used_stack
		|	jnz >1
		|	// used_stack += (func->op_array.last_var + func->op_array.T - MIN(func->op_array.num_args, num_args)) * sizeof(zval);
		|	mov	edx, opline->extended_value
		|	cmp edx, dword [r0 + offsetof(zend_function, op_array.num_args)]
		|	cmova edx, dword [r0 + offsetof(zend_function, op_array.num_args)]
		|	sub edx, dword [r0 + offsetof(zend_function, op_array.last_var)]
		|	sub edx, dword [r0 + offsetof(zend_function, op_array.T)]
		|	shl edx, 5
		|.if X64
		|	movsxd r2, edx
		|.endif
		|	sub FCARG1a, r2
		|1:
	}

	zend_jit_start_reuse_ip();

	|	// if (UNEXPECTED(used_stack > (size_t)(((char*)EG(vm_stack_end)) - (char*)call))) {
	|	mov RX, aword [&EG(vm_stack_top)]
	|	// Check Stack Overflow
	|	mov r2, aword [&EG(vm_stack_end)]
	|	sub r2, RX
	if (func) {
		|	cmp r2, used_stack
	} else {
		|	cmp r2, FCARG1a
	}
	|	jb >1
	|	// EG(vm_stack_top) = (zval*)((char*)call + used_stack);
	|.cold_code
	|1:
	if (func) {
		|	mov FCARG1d, used_stack
	}
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|	EXT_CALL zend_jit_int_extend_stack_helper, r0
	} else {
		|	mov FCARG2a, r0
		|	EXT_CALL zend_jit_extend_stack_helper, r0
	}
	|	mov RX, r0
	|	jmp >1
	|.code

	if (func) {
		|	add aword [&EG(vm_stack_top)], used_stack
	} else {
		|	add aword [&EG(vm_stack_top)], FCARG1a
	}
	|	// zend_vm_init_call_frame(call, call_info, func, num_args, called_scope, object);
	|	// ZEND_SET_CALL_INFO(call, 0, call_info);
	|	mov dword EX:RX->This.u1.type_info, (IS_UNDEF | (ZEND_CALL_NESTED_FUNCTION << ZEND_CALL_INFO_SHIFT))
	|	// call->func = func;
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|1:
		|.if X64
		||	if (!IS_32BIT(func)) {
		|		mov aword EX:RX->func, func
		||	} else {
		|		LOAD_ADDR r0, func
		|		mov aword EX:RX->func, r0
		||	}
		|.else
		|	mov aword EX:RX->func, func
		|.endif
	} else {
		|	mov aword EX:RX->func, r0
		|1:
	}
	|	// Z_CE(call->This) = called_scope;
	|	mov aword EX:RX->This.value.ptr, 0
	|	// ZEND_CALL_NUM_ARGS(call) = num_args;
	|	mov dword EX:RX->This.u2.num_args, opline->extended_value
	return 1;
}

static int zend_jit_needs_call_chain(zend_call_info *call_info, uint32_t b, zend_op_array *op_array, zend_ssa *ssa)
{
	const zend_op *opline, *end;
	int skip;

	if (!call_info) {
		return 1;
	}

	opline = call_info->caller_init_opline;
	end = call_info->caller_call_opline;

	if (end - op_array->opcodes >= ssa->cfg.blocks[b].start + ssa->cfg.blocks[b].len) {
		/* INIT_FCALL and DO_FCALL in different BasicBlocks */
		return 1;
	}

	opline++;
	skip = 1;
	while (opline != end) {
		if (skip) {
			switch (opline->opcode) {
				case ZEND_SEND_VAL:
				case ZEND_SEND_VAR:
				case ZEND_SEND_VAL_EX:
				case ZEND_SEND_VAR_EX:
				case ZEND_SEND_REF:
				case ZEND_SEND_VAR_NO_REF:
				case ZEND_SEND_VAR_NO_REF_EX:
					skip = 0;
					break;
				case ZEND_SEND_ARRAY:
				case ZEND_SEND_USER:
				case ZEND_SEND_UNPACK:
					return 1;
			}
		} else {
			if (zend_may_throw(opline, op_array, ssa)) {
				return 1;
			}
		}
		opline++;
	}

	return 0;
}

static int zend_jit_init_fcall(dasm_State **Dst, const zend_op *opline, uint32_t b, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;

	if (delayed_call_chain) {
		if (!zend_jit_save_call_chain(Dst, delayed_call_level)) {
			return 0;
		}
	}

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_init_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}

	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		/* load constant address later */
	} else if (func && op_array == &func->op_array) {
		/* recursive call */
		|	mov r0,	EX->func
	} else {
		zval *zv = RT_CONSTANT(op_array, opline->op2);

		|	// if (CACHED_PTR(Z_CACHE_SLOT_P(fname)))
		|	mov r0,	EX->run_time_cache
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
		|	test r0, r0
		|	jz >1
		|.cold_code
		|1:
		|	// SAVE_OPLINE();
		|	SAVE_VALID_OPLINE opline
		if (opline->opcode == ZEND_INIT_FCALL) {
			|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
			|	EXT_CALL zend_jit_find_func_helper, r0
		} else if (opline->opcode == ZEND_INIT_FCALL_BY_NAME) {
			|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
			|	LOAD_ADDR FCARG2a, Z_STR_P(zv + 1);
			|	EXT_CALL zend_jit_find_func_by_name_helper, r0
		} else {
			ZEND_ASSERT(0);
		}
		if (opline->opcode != ZEND_INIT_FCALL) {
			|	test r0, r0
			|	jz ->exception_handler
		}
		|	// CACHE_PTR(Z_CACHE_SLOT_P(fname), fbc);
		|	mov r1,	EX->run_time_cache
		|	mov aword [r1 + Z_CACHE_SLOT_P(zv)], r0
		|	jmp >3
		|.code
		|3:
	}

	if (!zend_jit_push_call_frame(Dst, opline, op_array, func)) {
		return 0;
	}

	if (zend_jit_needs_call_chain(call_info, b, op_array, ssa)) {
		if (!zend_jit_save_call_chain(Dst, call_level)) {
			return 0;
		}
	} else {
		delayed_call_chain = 1;
		delayed_call_level = call_level;
	}

	return 1;
}

static int zend_jit_do_fcall(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;
	uint32_t i;

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_call_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (!func) {
		// TODO: add support for unknown functions ???
		goto fallback;
	} else if (func->type == ZEND_USER_FUNCTION) {
		if (call_info->num_args > func->op_array.num_args ||
		    (opline-1)->opcode == ZEND_SEND_UNPACK ||
		    (func->op_array.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0) {
			goto fallback;
		}
	} else if (func->type == ZEND_INTERNAL_FUNCTION) {
#if ZEND_DEBUG
		if (func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) {
			goto fallback;
		}
#endif
		if ((opline-1)->opcode == ZEND_SEND_UNPACK) {
			goto fallback;
		}
	} else {
		ZEND_ASSERT(0);
	}

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}
	zend_jit_stop_reuse_ip();

	|	// fbc = call->func;
	|	// mov r2, EX:RX->func ???
	|	// SAVE_OPLINE();
	|	SAVE_VALID_OPLINE opline

	if (!delayed_call_chain) {
		if (call_level == 1) {
			|	mov aword EX->call, 0
		} else {
			|	//EX(call) = call->prev_execute_data;
			|	mov r0, EX:RX->prev_execute_data
			|	mov EX->call, r0
		}
	}
	delayed_call_chain = 0;

	|	//call->prev_execute_data = execute_data;
	|	mov EX:RX->prev_execute_data, EX
	|

	if (func && func->type == ZEND_USER_FUNCTION) {
		|	// EX(call) = NULL;
		|	mov aword EX:RX->call, 0
	}

	if (func && func->type == ZEND_USER_FUNCTION) {

		if (RETURN_VALUE_USED(opline)) {
			|	// ZVAL_NULL(EX_VAR(opline->result.var));
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
			|	// EX(return_value) = EX_VAR(opline->result.var);
			|	lea r0, aword [FP + opline->result.var]
			|	mov aword EX:RX->return_value, r0
		} else {
			|	// EX(return_value) = 0;
			|	mov aword EX:RX->return_value, 0
		}

		for (i = call_info->num_args; i < func->op_array.last_var; i++) {
			uint32_t n = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
			|	SET_Z_TYPE_INFO RX + n, IS_UNDEF
		}

		//EX_LOAD_RUN_TIME_CACHE(op_array);
		if (!func || func->op_array.cache_size) {
			if (func && op_array == &func->op_array) {
				/* recursive call */
				if (func->op_array.cache_size > sizeof(void*)) {
					|	mov r0, EX->run_time_cache
					|	mov EX:RX->run_time_cache, r0
				}
			} else {
				|	mov r2, EX:RX->func
				|	mov r0, aword [r2 + offsetof(zend_op_array, run_time_cache)]
				|	mov EX:RX->run_time_cache, r0
			}
		}

		|	//EX_LOAD_LITERALS(op_array);
		|.if X64
		|	LOAD_ADDR r0, func->op_array.literals
		|	mov EX:RX->literals, r0
		|.endif

		|	// EG(current_execute_data) = execute_data;
		|	mov aword [&EG(current_execute_data)], RX
		|	mov FP, RX

		|	// opline = op_array->opcodes;
		|	LOAD_ADDR IP, (func->op_array.opcodes + call_info->num_args)

		if (func && op_array == &func->op_array) {
			/* recursive call */
#ifdef CONTEXT_THREADED_JIT
			|	call =>(call_info->num_args+ssa->cfg.blocks_count)
#else
			|	jmp =>call_info->num_args
#endif
		} else {
#ifdef CONTEXT_THREADED_JIT
			|	call aword [IP]
#else
			|	add r4, SPAD // stack alignment
			|	jmp aword [IP]
#endif
		}
	} else if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		if (RETURN_VALUE_USED(opline)) {
			|	// ZVAL_NULL(EX_VAR(opline->result.var));
			|	lea FCARG2a, aword [FP + opline->result.var]
			|	SET_Z_TYPE_INFO FCARG2a, IS_NULL
		} else {
			|	sub r4, 16 /* alloca() */
			|	lea FCARG2a, aword [r4 + 8]
			|	SET_Z_TYPE_INFO FCARG2a, IS_NULL
		}

		|	// EG(current_execute_data) = execute_data;
		|	mov aword [&EG(current_execute_data)], RX

		zend_jit_reset_opline(Dst, NULL);

		|	// fbc->internal_function.handler(call, ret);
		|.if X64
		|	mov FCARG1a, RX
		|	EXT_CALL func->internal_function.handler, r0
		|.else
		|	sub r4, 8
		|	push FCARG2a
		|	push RX
		|	EXT_CALL func->internal_function.handler, r0
		|	add r4, 16
		|.endif

		|	// EG(current_execute_data) = execute_data;
		|	mov aword [&EG(current_execute_data)], FP

		|	// zend_vm_stack_free_args(call);
		for (i = 0; i < call_info->num_args; i++ ) {
			uint32_t offset = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
			|	ZVAL_PTR_DTOR RX + offset, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN, 0, 1, 1, op_array->filename, opline->lineno
		}

		|	// zend_vm_stack_free_call_frame(call);
		|	test byte [RX + offsetof(zend_execute_data, This.u1.type_info) + 2], ZEND_CALL_ALLOCATED
		|	jnz >1
		|.cold_code
		|1:
		|	mov FCARG1a, RX
		|	EXT_CALL zend_jit_free_call_frame, r0
		|	jmp >1
		|.code
		|	mov aword [&EG(vm_stack_top)], RX
		|1:

		if (opline->result_type == IS_UNUSED) {
			uint32_t func_info = zend_get_func_info(call_info, ssa);

			if (func_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
				|	ZVAL_PTR_DTOR r4 + 8, func_info, 1, 1, 0, op_array->filename, opline->lineno
			}
			|	add r4, 16 /* revert alloca() */
		}

		|	// if (UNEXPECTED(EG(exception) != NULL)) {
		|	cmp aword [&EG(exception)], 0
		|	jne ->icall_throw_handler

		// TODO: Can we avoid checking for interrupts after each call ???
		return zend_jit_check_timeout(Dst, opline + 1);
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	if (opline->opcode == ZEND_DO_FCALL ||
	    opline->opcode == ZEND_DO_UCALL ||
	    opline->opcode == ZEND_DO_FCALL_BY_NAME ){
		return zend_jit_call(Dst, opline);
	} else {
		return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
	}
}

static int zend_jit_send_val(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	uint32_t arg_num = opline->op2.num;

	if (opline->opcode == ZEND_SEND_VAL_EX && arg_num > MAX_ARG_FLAG_NUM) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}

	if (opline->opcode == ZEND_SEND_VAL_EX) {
		uint32_t mask = ZEND_SEND_BY_REF << ((arg_num + 3) * 2);

		|	mov r0, EX:RX->func
		if (arg_num <= MAX_ARG_FLAG_NUM) {
			|	test dword [r0 + offsetof(zend_function, quick_arg_flags)], mask
			|	jnz	>1
		} else {
			ZEND_ASSERT(0);
		}
		|.cold_code
		|1:
		|	SAVE_VALID_OPLINE opline
		|	jmp ->throw_cannot_pass_by_ref
		|.code
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);

		|	ZVAL_COPY_CONST RX + opline->result.var, -1, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
	} else {
		|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_send_ref(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int cold)
{
	uint32_t op1_info;

	op1_info = OP1_INFO();

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}

	if (opline->op1_type == IS_VAR) {
		|	lea r0, [FP + opline->op1.var]
		|	// if (EXPECTED(Z_TYPE_P(ret) == IS_INDIRECT)) {
		|	IF_NOT_Z_TYPE r0, IS_INDIRECT, >1
		|	// ret = Z_INDIRECT_P(ret);
		|	GET_Z_PTR r0, r0
		|1:
		if (op1_info & MAY_BE_ERROR) {
			if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
				if (cold) {
					|	IF_NOT_Z_TYPE r0, _IS_ERROR, >1
				} else {
					|	IF_Z_TYPE r0, _IS_ERROR, >1
					|.cold_code
					|1:
				}
			}

			|	// ZVAL_NEW_EMPTY_REF(arg);
			|	EMALLOC sizeof(zend_reference), op_array, opline
			|	SET_Z_PTR RX + opline->result.var, r0
			|	SET_Z_TYPE_INFO RX + opline->result.var, IS_REFERENCE_EX
			|	mov dword [r0], 1
			|	mov dword [r0 + 4], IS_REFERENCE;
			|	// ZVAL_NULL(Z_REFVAL_P(arg));
			|	SET_Z_TYPE_INFO r0 + 8, IS_NULL

			if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
				|	jmp >7
				if (cold) {
					|1:
				} else {
					|.code
				}
			}
		}
	} else if (opline->op1_type == IS_CV) {
		if (op1_info & MAY_BE_UNDEF) {
			if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
				|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_NULL
				|	jmp >2
				|1:
			}
			op1_info &= ~MAY_BE_UNDEF;
			op1_info |= MAY_BE_NULL;
		}
	} else {
		ZEND_ASSERT(0);
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) {
		if (op1_info & MAY_BE_REF) {
			if (opline->op1_type == IS_VAR) {
				|	IF_NOT_Z_TYPE r0, IS_REFERENCE, >2
				|	GET_Z_PTR r1, r0
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >2
				|	GET_Z_PTR r1, FP + opline->op1.var
			}
			|	GC_ADDREF r1
			|	SET_Z_PTR RX + opline->result.var, r1
			|	SET_Z_TYPE_INFO RX + opline->result.var, IS_REFERENCE_EX
			|	jmp	>6
		}
		|2:
		|	// ZVAL_NEW_REF(arg, varptr);
		if (opline->op1_type == IS_VAR) {
			|	mov aword [r4], r0 // save
		}
		|	EMALLOC sizeof(zend_reference), op_array, opline
		|	mov dword [r0], 2
		|	mov dword [r0 + 4], IS_REFERENCE;
		if (opline->op1_type == IS_VAR) {
			|	mov r1, aword [r4] // restore
			|	ZVAL_COPY_VALUE_clobber_src r0 + 8, r1, op1_info, r1, ecx, r2
			|	mov r1, aword [r4] // restore
			|	SET_Z_PTR r1, r0
			|	SET_Z_TYPE_INFO r1, IS_REFERENCE_EX
		} else {
			|	ZVAL_COPY_VALUE r0 + 8, FP + opline->op1.var, op1_info, r1, ecx, r2
			|	SET_Z_PTR FP + opline->op1.var, r0
			|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_REFERENCE_EX
		}
		|	SET_Z_PTR RX + opline->result.var, r0
		|	SET_Z_TYPE_INFO RX + opline->result.var, IS_REFERENCE_EX
	}

	|6:
	|	FREE_OP opline->op1_type, opline->op1, op1_info, !cold, op_array, opline->lineno
	|7:

	return 1;
}

static int zend_jit_send_var(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	uint32_t arg_num = opline->op2.num;

	if (opline->opcode == ZEND_SEND_VAR_EX && arg_num > MAX_ARG_FLAG_NUM) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}

	if (opline->opcode == ZEND_SEND_VAR_EX) {
		uint32_t mask = ZEND_SEND_BY_REF << ((arg_num + 3) * 2);

		|	mov r0, EX:RX->func
		if (arg_num <= MAX_ARG_FLAG_NUM) {
			|	test dword [r0 + offsetof(zend_function, quick_arg_flags)], mask
			|	jnz	>1
		} else {
			ZEND_ASSERT(0);
		}

		|.cold_code
		|1:

		if (!zend_jit_send_ref(Dst, opline, op_array, ssa, 1)) {
			return 0;
		}

		|	jmp >7
		|.code
	}

	if (op1_info & MAY_BE_UNDEF) {
		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			|.cold_code
			|1:
		}

		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op1.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		|	SET_Z_TYPE_INFO RX + opline->result.var, IS_NULL

		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|	jmp >7
			|.code
		}
	}

	if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
		if (op1_info & MAY_BE_REF) {
			if (opline->op1_type == IS_CV) {
				|	lea FCARG1a, [FP + opline->op1.var]
				|	ZVAL_DEREF FCARG1a, op1_info
				|	ZVAL_COPY_VALUE RX + opline->result.var, FCARG1a, op1_info, r0, eax, r2
				|	TRY_ADDREF op1_info, ah, r2
			} else {
				|	IF_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >1
				|.cold_code
				|1:
				|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
				|	GET_Z_PTR FCARG1a, FP + opline->op1.var
				|	// ZVAL_COPY_VALUE(return_value, &ref->value);
				|	ZVAL_COPY_VALUE RX + opline->result.var, FCARG1a + 8, op1_info, r0, eax, r2
				|	GC_DELREF FCARG1a
				|	je >1
				|	IF_NOT_REFCOUNTED ah, >2
				|	GC_ADDREF r2
				|	jmp >2
				|1:
				|	EFREE_REG_24 op_array, opline
				|	jmp >2
				|.code
				|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
				|2:
			}
		} else {
			|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
			||	if (opline->op1_type == IS_CV) {
			|		TRY_ADDREF op1_info, ah, r2
			||	}
		}
	}
	|7:

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_smart_true(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa, int jmp)
{
	uint32_t target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		if (jmp) {
			|	jmp >7
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		| 	jmp =>target_label
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[1];
		| 	jmp =>target_label
	} else {
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
		if (jmp) {
			|	jmp >7
		}
	}

	return 1;
}

static int zend_jit_smart_false(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa, int jmp)
{
	uint32_t target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		| 	jmp =>target_label
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		if (jmp) {
			|	jmp >7
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		| 	jmp =>target_label
	} else {
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
		if (jmp) {
			|	jmp >7
		}
	}

	return 1;
}

static int zend_jit_type_check(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, mask;
	uint32_t target_label;
	zend_uchar type;
	zend_bool smart_branch = 0;

	if (opline->extended_value == IS_RESOURCE) {
		// TODO: support for is_resource() ???
		goto fallback;
	}

	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		smart_branch = 1;
	}

	op1_info = OP1_INFO();
	if (op1_info & MAY_BE_UNDEF) {
		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			|.cold_code
			|1:
		}
		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op1.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		if (opline->extended_value == IS_NULL) {
			if (!zend_jit_smart_true(Dst, opline, b, op_array, ssa, (op1_info & (MAY_BE_ANY|MAY_BE_REF)) != 0)) {
				return 0;
			}
		} else {
			if (!zend_jit_smart_false(Dst, opline, b, op_array, ssa, (op1_info & (MAY_BE_ANY|MAY_BE_REF)) != 0)) {
				return 0;
			}
		}
		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|.code
		}
	}

	if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
		type = opline->extended_value;
		if (type == _IS_BOOL) {
			mask = MAY_BE_FALSE | MAY_BE_TRUE;
		} else {
			mask = (1 << type);
		}

		if (!(op1_info & (MAY_BE_ANY - mask))) {
			|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline->lineno
			if (!zend_jit_smart_true(Dst, opline, b, op_array, ssa, 0)) {
				return 0;
			}
	    } else if (!(op1_info & mask)) {
			|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline->lineno
			if (!zend_jit_smart_false(Dst, opline, b, op_array, ssa, 0)) {
				return 0;
			}
		} else {
			if (op1_info & MAY_BE_REF) {
				|	LOAD_ZVAL_ADDR r0, opline->op1_type, opline->op1
				|	ZVAL_DEREF r0, op1_info
			}
			if (opline->extended_value == _IS_BOOL) {
				if (smart_branch &&
				    (opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
				    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						|	// if (Z_REFCOUNTED_P(cv)) {
						if (op1_info & MAY_BE_REF) {
							|	IF_Z_REFCOUNTED r0, >1
						} else {
							|	IF_Z_REFCOUNTED FP + opline->op1.var, >1
						}
						|.cold_code
						|1:
					}
					|	// if (!Z_DELREF_P(cv)) {
					if (op1_info & MAY_BE_REF) {
						|	GET_Z_PTR FCARG1a, r0
					} else {
						|	GET_Z_PTR FCARG1a, FP + opline->op1.var
					}
					|	GC_DELREF FCARG1a
					if (RC_MAY_BE_1(op1_info)) {
						if (RC_MAY_BE_N(op1_info)) {
							|	jnz >1
						}
						if (op1_info & MAY_BE_REF) {
							|	mov al, byte [r0 + 8]
						} else {
							|	mov al, byte [FP + opline->op1.var + 8]
						}
						|	mov byte [r4], al // save
						|	// zval_dtor_func(r);
						|	ZVAL_DTOR_FUNC op_array->filename, opline->lineno
						|	mov cl, byte [r4] // restore
						|jmp >2
					}
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						if (!RC_MAY_BE_1(op1_info)) {
							|	jmp >1
						}
						|.code
					}
					|1:
					if (op1_info & MAY_BE_REF) {
						|	mov cl, byte [r0 + 8]
					} else {
						|	mov cl, byte [FP + opline->op1.var + 8]
					}
					|2:
                } else {
					if (op1_info & MAY_BE_REF) {
						|	mov cl, byte [r0 + 8]
					} else {
						|	mov cl, byte [FP + opline->op1.var + 8]
					}
				}
				|	mov al, 1
				|	shl al, cl
				|	test al, 0xc
				if ((opline+1)->opcode == ZEND_JMPZ &&
				    (opline+1)->op1_type == IS_TMP_VAR &&
				    (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	je =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	jne =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	je =>target_label
					target_label = ssa->cfg.blocks[b].successors[1];
					| 	jmp =>target_label
				} else {
					|	setne al
					|	movzx eax, al
					|	add eax, 2
					|	SET_Z_TYPE_INFO FP + opline->result.var, eax
					|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline->lineno
				}
			} else if (opline->extended_value == IS_RESOURCE) {
				ZEND_ASSERT(0);
			} else {
				if (smart_branch &&
				    (opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
				    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						|	// if (Z_REFCOUNTED_P(cv)) {
						if (op1_info & MAY_BE_REF) {
							|	IF_Z_REFCOUNTED r0, >1
						} else {
							|	IF_Z_REFCOUNTED FP + opline->op1.var, >1
						}
						|.cold_code
						|1:
					}
					|	// if (!Z_DELREF_P(cv)) {
					if (op1_info & MAY_BE_REF) {
						|	GET_Z_PTR FCARG1a, r0
					} else {
						|	GET_Z_PTR FCARG1a, FP + opline->op1.var
					}
					|	GC_DELREF FCARG1a
					if (RC_MAY_BE_1(op1_info)) {
						if (RC_MAY_BE_N(op1_info)) {
							|	jnz >1
						}
						if (op1_info & MAY_BE_REF) {
							|	mov al, byte [r0 + 8]
						} else {
							|	mov al, byte [FP + opline->op1.var + 8]
						}
						|	mov byte [r4], al // save
						|	// zval_dtor_func(r);
						|	ZVAL_DTOR_FUNC op_array->filename, opline->lineno
						|	mov cl, byte [r4] // restore
						|jmp >2
					}
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						if (!RC_MAY_BE_1(op1_info)) {
							|	jmp >1
						}
						|.code
					}
					|1:
					if (op1_info & MAY_BE_REF) {
						|	mov cl, byte [r0 + 8]
					} else {
						|	mov cl, byte [FP + opline->op1.var + 8]
					}
					|2:
					|	cmp cl, opline->extended_value
				} else {
					if (op1_info & MAY_BE_REF) {
						|	cmp byte [r0 + 8], opline->extended_value
					} else {
						|	cmp byte [FP + opline->op1.var + 8], opline->extended_value
					}
				}
				if ((opline+1)->opcode == ZEND_JMPZ &&
				    (opline+1)->op1_type == IS_TMP_VAR &&
				    (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	jne =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	je =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	jne =>target_label
					target_label = ssa->cfg.blocks[b].successors[1];
					| 	jmp =>target_label
				} else {
					|	sete al
					|	movzx eax, al
					|	add eax, 2
					|	SET_Z_TYPE_INFO FP + opline->result.var, eax
					|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline->lineno
				}
			}
	    }
	}

	|7:

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_free_compiled_variables(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
    uint32_t i, j, info;

	// Use type inference to avoid useless zval_ptr_dtor()
	for (i = 0 ; i < op_array->last_var; i++) {
		if (ssa->vars && ssa->var_info) {
			info = ssa->var_info[i].type;
			for (j = op_array->last_var; j < ssa->vars_count; j++) {
				if (ssa->vars[j].var == i) {
					info |= ssa->var_info[j].type;
				}
			}
		} else {
			info = MAY_BE_RC1 | MAY_BE_RCN | MAY_BE_REF | MAY_BE_ANY | MAY_BE_UNDEF;
		}

#ifdef ZEND_JIT_USE_RC_INFERENCE
		/* Refcount may be increased by RETRUN opcode */
		if ((info & MAY_BE_RC1) && !(info & MAY_BE_RCN)) {
			for (j = 0; j < ssa->cfg.blocks_count; j++) {
				if ((ssa->cfg.blocks[j].flags & ZEND_BB_REACHABLE) &&
				    ssa->cfg.blocks[j].len > 0) {
					const zend_op *opline = op_array->opcodes + ssa->cfg.blocks[j].start + ssa->cfg.blocks[j].len - 1;

					if (opline->opcode == ZEND_RETURN) {
						if (opline->op1_type == IS_CV &&
						    opline->op1.var == (uint32_t)(uintptr_t)(ZEND_CALL_VAR_NUM(NULL, i))) {
							info |= MAY_BE_RCN;
							break;
						}
					}
				}
			}
		}
#endif

		if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
			uint32_t offset = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
			| ZVAL_PTR_DTOR FP + offset, info, 1, 1, 1, op_array->filename, opline->lineno
		}
	}
	return 1;
}

static int zend_jit_leave_func(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	// Avoid multiple leave sequnces
	if (jit_return_label >= 0) {
		| jmp =>jit_return_label
		return 1;
	}

	jit_return_label = ssa->cfg.blocks_count * 2;

	|=>jit_return_label:

	// i_free_compiled_variables(execute_data);
	if (!zend_jit_free_compiled_variables(Dst, opline, op_array, ssa)) {
		return 0;
	}

	|	movzx FCARG1d, word [FP + offsetof(zend_execute_data, This.u1.type_info) + 2]
	|	test FCARG1d, (ZEND_CALL_TOP|ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_ALLOCATED|ZEND_CALL_FAKE_CLOSURE)
	|	jnz ->leave_function_handler

	if (op_array->scope || (op_array->fn_flags & ZEND_ACC_CLOSURE)) {
		|	// EG(current_execute_data) = EX(prev_execute_data);
		|	mov r0, EX->prev_execute_data
		|	mov aword [&EG(current_execute_data)], r0
		if (op_array->scope) {
			|	// if (call_info & ZEND_CALL_RELEASE_THIS)
			|	test FCARG1d, ZEND_CALL_RELEASE_THIS
			if (op_array->fn_flags & ZEND_ACC_STATIC) {
				|	jnz >1
				|.cold_code
				|1:
			} else {
				|	je >2
			}
			|	// zend_object *object = Z_OBJ(execute_data->This);
			|	mov r0, EX->This.value.obj
			if (op_array->scope && op_array->scope->constructor == (zend_function*)op_array) {
				|	// if (UNEXPECTED(EG(exception) != NULL)
				|	cmp aword [&EG(exception)], 0
				|	jne >6
				|.cold_code
				|6:
				|	// if (call_info & ZEND_CALL_CTOR)
				|	test FCARG1d, ZEND_CALL_CTOR
				|	jz >5
				|	// GC_REFCOUNT(object)--;
				|	GC_DELREF r0
				|	// zend_object_store_ctor_failed(object);
				|.if X64
				|	mov CARG1, r0
				|	EXT_CALL zend_object_store_ctor_failed, r0
				|.else
				|	sub r4, 12
				|	push r0
				|	EXT_CALL zend_object_store_ctor_failed, r0
				|	add r4, 16
				|.endif
				|	// reload registers
				|	mov r0, EX->This.value.obj
				|	jmp >5
				|.code
				|5:
			}
			|	// OBJ_RELEASE(object);
			|	OBJ_RELEASE r0, ecx, >4
			|	jmp >4
			if (op_array->fn_flags & ZEND_ACC_STATIC) {
				|.code
			} else {
				|2:
			}
		}
		if (op_array->fn_flags & ZEND_ACC_CLOSURE) {
			|	test FCARG1d, ZEND_CALL_CLOSURE
			|	jnz >3
			|.cold_code
			|3:
			|	// OBJ_RELEASE((zend_object*)execute_data->func->op_array.prototype);
			|	mov r0, EX->func
			|	mov r0, aword [r0 + offsetof(zend_op_array, prototype)]
			|	OBJ_RELEASE r0, ecx, >4
			|	jmp >4
			|.code
		}
		|4:
		|	// EG(vm_stack_top) = (zval*)execute_data;
		|	mov aword [&EG(vm_stack_top)], FP
		|	// execute_data = EX(prev_execute_data);
		|	mov FP, EX->prev_execute_data
	} else {
		|	// EG(vm_stack_top) = (zval*)execute_data;
		|	mov aword [&EG(vm_stack_top)], FP
		|	// execute_data = EX(prev_execute_data);
		|	mov FP, EX->prev_execute_data
		|	// EG(current_execute_data) = execute_data
		|	mov aword [&EG(current_execute_data)], FP
	}
	|	// if (EG(exception))
	|	cmp aword [&EG(exception)], 0
	|	mov IP, EX->opline
	|	jne ->leave_throw_handler
	|	// opline = EX(opline) + 1
	|	add IP, sizeof(zend_op)
	|	add r4, SPAD // stack alignment
#ifdef CONTEXT_THREADED_JIT
	|	ret
#else
	|	jmp aword [IP]
#endif

	return 1;
}

static int zend_jit_return(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (op_array->type == ZEND_EVAL_CODE || !op_array->function_name || !ssa->ops || !ssa->var_info) {
		// TODO: support for top-level code
		return zend_jit_tail_handler(Dst, opline);
	}

	op1_info = OP1_INFO();
	if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
		// TODO: support for IS_UNDEF ???
		return zend_jit_tail_handler(Dst, opline);
	}

	// if (!EX(return_value))
	|	mov r1, EX->return_value
	|	test r1, r1
	if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
	    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	jz >1
		|.cold_code
		|1:
		||	if (jit_return_label >= 0) {
		|		IF_NOT_Z_REFCOUNTED FP + opline->op1.var, =>jit_return_label
		||	} else {
		|		IF_NOT_Z_REFCOUNTED FP + opline->op1.var, >9
		||	}
		|	GET_Z_PTR FCARG1a, FP + opline->op1.var
		|	GC_DELREF FCARG1a
		||	if (RC_MAY_BE_1(op1_info)) {
		||		if (RC_MAY_BE_N(op1_info)) {
		||			if (jit_return_label >= 0) {
		|				jnz =>jit_return_label
		||			} else {
		|				jnz >9
		||			}
		||		}
		|		//SAVE_OPLINE()
		|		SAVE_VALID_OPLINE opline
		|		ZVAL_DTOR_FUNC op_array->filename, opline->lineno
		|		//????mov r1, EX->return_value // reload ???
		||	}
		||	if (jit_return_label >= 0) {
		|		jmp =>jit_return_label
		||	} else {
		|		jmp >9
		||	}
		|.code
	} else {
		||	if (jit_return_label >= 0) {
		|		jz =>jit_return_label
		||	} else {
		|		jz >9
		||	}
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);
		|	ZVAL_COPY_CONST r1, -1, zv, r0
		if (Z_REFCOUNTED_P(zv)) {
		|	ADDREF_CONST zv, r0
		}
	} else if (opline->op1_type == IS_TMP_VAR) {
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
	} else if (opline->op1_type == IS_CV) {
		if (op1_info & MAY_BE_REF) {
			|	lea r0, [FP + opline->op1.var]
			|	ZVAL_DEREF r0, op1_info
			|	ZVAL_COPY_VALUE_clobber_src r1, r0, op1_info, r0, eax, r2
			|	TRY_ADDREF op1_info, ah, r2
		} else {
			|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
			|	// TODO: JIT: if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) ZVAL_NULL(retval_ptr); ???
			|	TRY_ADDREF op1_info, ah, r2
		}
	} else {
		if (op1_info & MAY_BE_REF) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >1
			|.cold_code
			|1:
			|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
			|	GET_Z_PTR r0, FP + opline->op1.var
			|	// ZVAL_COPY_VALUE(return_value, &ref->value);
			|.if X64
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|.else
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|	GET_Z_W2 r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_W2 r1 + 4, r2
			|.endif
			|	GET_Z_TYPE_INFO edx, r0 + offsetof(zend_reference, val)
			|	SET_Z_TYPE_INFO r1, edx
			|	GC_DELREF r0
			|	je >2
			|	// if (IS_REFCOUNTED())
			||	if (jit_return_label >= 0) {
			|		IF_NOT_REFCOUNTED dh, =>jit_return_label
			||	} else {
			|		IF_NOT_REFCOUNTED dh, >9
			||	}
			|	// ADDREF
			|	GET_Z_PTR r2, r1
			|	GC_ADDREF r2
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|2:
			|	EFREE_24 r0, op_array, opline
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|.code
		}
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
	}

	|9:
	//JIT: ZEND_VM_DISPATCH_TO_HELPER(zend_leave_helper);
	return zend_jit_leave_func(Dst, opline, op_array, ssa);
}

static int zend_jit_fetch_dim_read(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, res_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	res_info = RES_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
		if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, (opline->opcode == ZEND_FETCH_DIM_R) ? BP_VAR_R : BP_VAR_IS, op1_info, op2_info, 8, 9)) {
			return 0;
		}
	}

	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_ARRAY)) {
		if (op1_info & MAY_BE_ARRAY) {
			|.cold_code
			|7:
		}

		if (op1_info & MAY_BE_STRING) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING))) {
			    if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_STRING, >6
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_STRING, >6
			    }
			}
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_str_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_str_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			|6:
		}

		if (op1_info & MAY_BE_OBJECT) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_OBJECT))) {
			    if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_OBJECT, >6
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_OBJECT, >6
			    }
			}
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_obj_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_obj_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			|6:
		}

		if ((opline->opcode != ZEND_FETCH_DIM_IS && (op1_info & MAY_BE_UNDEF)) ||
		    (op2_info & MAY_BE_UNDEF)) {
			|	SAVE_VALID_OPLINE opline
		}
		if (opline->opcode != ZEND_FETCH_DIM_IS && (op1_info & MAY_BE_UNDEF)) {
		    if (op1_info & MAY_BE_REF) {
				|	IF_NOT_Z_TYPE FCARG1a, IS_UNDEF, >1
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
		    }
			|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
			|	mov FCARG1d, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		if (op2_info & MAY_BE_UNDEF) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_UNDEF, >1
			|	mov FCARG1d, opline->op2.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
		|	jmp >9 // END
		if (op1_info & MAY_BE_ARRAY) {
			|.code
		}
	}

	|8:
	if (res_info & MAY_BE_REF) {
	|	// ZVAL_COPY_UNREF
	|	IF_NOT_Z_REFCOUNTED r0, >2
	|	GET_Z_PTR r1, r0
	|	IF_NOT_Z_TYPE r0, IS_REFERENCE, >1
	|	cmp dword [r1], 1
	|	jne >1
	|	lea FCARG1a, [FP + opline->result.var]
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_zval_copy_unref_helper, r0
	|	jmp >9
	|1:
	|	GC_ADDREF r1
	|2:
	|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
	} else  {
	|	// ZVAL_COPY
	|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
	|	TRY_ADDREF res_info, ch, r2
	}
	|9: // END

#ifdef ZEND_JIT_USE_RC_INFERENCE
	if ((opline->op2_type & (IS_TMP_VAR|IS_VAR)) && (op1_info & MAY_BE_OBJECT)) {
		/* Magic offsetGet() may increase refcount of the key */
		op2_info |= MAY_BE_RCN;
	}
#endif

	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline->lineno
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline->lineno

	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_isset_isempty_dim(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info || !(opline->extended_value & ZEND_ISSET)) {
		// TODO: support for empty() ???
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
		if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, BP_JIT_IS, op1_info, op2_info, 8, 9)) {
			return 0;
		}
	}

	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_ARRAY)) {
		if (op1_info & MAY_BE_ARRAY) {
			|.cold_code
			|7:
		}

		|	SAVE_VALID_OPLINE opline
	    if (!(op1_info & MAY_BE_REF)) {
			|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		}
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		|	EXT_CALL zend_jit_isset_dim_helper, r0
		|	test r0, r0
		|	jz >9
		|	jmp >8

		if (op1_info & MAY_BE_ARRAY) {
			|.code
		}
	}

#ifdef ZEND_JIT_USE_RC_INFERENCE
	if ((opline->op2_type & (IS_TMP_VAR|IS_VAR)) && (op1_info & MAY_BE_OBJECT)) {
		/* Magic offsetExists() may increase refcount of the key */
		op2_info |= MAY_BE_RCN;
	}
#endif

	|8:
	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline->lineno
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline->lineno
	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}
	if (opline->extended_value & ZEND_ISSET) {
		if ((opline+1)->opcode == ZEND_JMPZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[1];
			|	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[0];
			|	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[1];
			|	jmp =>target_label
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
			|	jmp >8
		}
	} else {
		|	//????
		|	int3
	}

	|9: // not found
	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline->lineno
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline->lineno
	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}
	if (opline->extended_value & ZEND_ISSET) {
		if ((opline+1)->opcode == ZEND_JMPZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[0];
			|	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ) {
		} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[0];
			|	jmp =>target_label
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
		}
	} else {
		|	//????
		|	int3
	}

	|8:

	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_bind_global(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	zval *varname = RT_CONSTANT(op_array, opline->op2);

	if (!ssa->ops || !ssa->var_info) {
		op1_info = MAY_BE_ANY|MAY_BE_REF;
	} else {
		op1_info = OP1_INFO();
	}

	//idx = (uint32_t)(uintptr_t)CACHED_PTR(Z_CACHE_SLOT_P(varname)) - 1;
	|	mov	r0, EX->run_time_cache
	|	mov r0, aword [r0 + Z_CACHE_SLOT_P(varname)]
	|	dec r0
	//if (EXPECTED(idx < EG(symbol_table).nNumUsed))
	|	cmp r0, [&EG(symbol_table).nNumUsed]
	|	jae >9
	//Bucket *p = EG(symbol_table).arData + idx;
	|.if X64
	|	shl r0, 5
	|.else
	|	imul r0, sizeof(Bucket)
	|.endif
	|.if X64
	|	LOAD_ADDR r1, &EG(symbol_table.arData)
	|	add r0, [r1]
	|.else
	|	add r0, [&EG(symbol_table).arData]
	|.endif
	|	IF_Z_TYPE r0, IS_UNDEF, >9
	//	(EXPECTED(p->key == Z_STR_P(varname))
	|.if X64
	|	LOAD_ADDR r1, Z_PTR_P(varname)
	|	cmp [r0 + offsetof(Bucket, key)], r1
	|.else
	|	cmp aword [r0 + offsetof(Bucket, key)], Z_PTR_P(varname)
	|.endif
	|	jne >1
	|.cold_code
	|1:
	//(EXPECTED(p->h == ZSTR_H(Z_STR_P(varname)))
	|.if X64
	|	mov64 r1, ZSTR_H(Z_STR_P(varname))
	|	cmp qword [r0 + offsetof(Bucket, h)], r1
	|.else
	|	cmp dword [r0 + offsetof(Bucket, h)], ZSTR_H(Z_STR_P(varname))
	|.endif
	|	jne >9
	//EXPECTED(p->key != NULL)
	|	mov r1, [r0 + offsetof(Bucket, key)]
	|	test r1, r1
	|	jz >9
	//EXPECTED(ZSTR_LEN(p->key) == Z_STRLEN_P(varname))
	|	cmp dword [r1 + offsetof(zend_string, len)], Z_STRLEN_P(varname)
	|	jne >9
	//EXPECTED(memcmp(ZSTR_VAL(p->key), Z_STRVAL_P(varname), Z_STRLEN_P(varname)) == 0)
	|	add r1, offsetof(zend_string, val)
	|	mov [r4], r0
	|.if X64
	|	mov CARG1, r1
	|	LOAD_ADDR CARG2, Z_STRVAL_P(varname)
	|	mov CARG3, Z_STRLEN_P(varname)
	|	call &memcmp
	|.else
	|	sub r4, 4
	|	push Z_STRLEN_P(varname)
	|	push Z_STRVAL_P(varname)
	|	push r1
	|	call &memcmp
	|	add r4, 16
	|.endif
	|	test al, al
	|	mov r0, aword [r4]
	|	jnz >9
	|	jmp >2
	|.code
	|2:
	// if (UNEXPECTED(Z_TYPE_P(value) == IS_INDIRECT))
	|	mov cl, byte [r0 + 8]
	|	cmp cl, IS_INDIRECT
	|	je >1
	|.cold_code
	|1:
	//value = Z_INDIRECT_P(value)
	|	mov r0, [r0]
	|	mov cl, byte [r0 + 8]
	|	cmp cl, IS_UNDEF
	|	jne >2
	|	SET_Z_TYPE_INFO r0, IS_NULL
	|	jmp >8
	|.code
	|2:
	|	cmp cl, IS_REFERENCE
	|	jne >8
	|1:
	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		//stash this for later use
	|	mov r2, r0
	}
	|	GET_Z_PTR r0, r0
	|	GC_ADDREF r0
	//if (UNEXPECTED(Z_REFCOUNTED_P(variable_ptr)))
	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		if (op1_info & (MAY_BE_ANY - (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	IF_Z_REFCOUNTED FP + opline->op1.var, >2
		}
		|.cold_code
		//zval_dtor_func(Z_COUNTED_P(variable_ptr))
		|2:
		//if (EXPECTED(variable_ptr != value))
		|	lea FCARG1a, aword [FP + opline->op1.var]
		|	cmp FCARG1a, r2
		|	je >4
		|	GET_Z_PTR FCARG1a, FCARG1a
		|	GC_DELREF FCARG1a
		if (op1_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
		|	jnz >3
		}
		|	mov aword [r4], r0 // save
		|	ZVAL_DTOR_FUNC op_array->filename, opline->lineno
		|	mov r0, aword [r4] // restore
		|	jmp >5
		if (op1_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
		|3:
		// GC_ZVAL_CHECK_POSSIBLE_ROOT(variable_ptr)
		|	IF_GC_MAY_NOT_LEAK FCARG1a, eax, >5
		|	mov aword [r4], r0 //save
		|	EXT_CALL gc_possible_root, r1
		|	mov r0, aword [r4] // restore
		|	jmp >5
		}
		|4:
		|	GET_Z_PTR FCARG1a, FCARG1a
		|	GC_DELREF FCARG1a
		|	jmp >5
		|.code
	}
	|5:
	//ZVAL_REF(variable_ptr, ref)
	|	SET_Z_PTR FP + opline->op1.var, r0
	|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_REFERENCE_EX
	//END of handler

	|.cold_code
	|8:
	|	mov FCARG1a, r0
	|	EXT_CALL zend_jit_new_ref_helper, r0
	|	jmp <1
	|9:
	|	mov FCARG1a, FP
	|	LOAD_ADDR FCARG2a, (ptrdiff_t)varname
	|	EXT_CALL zend_jit_fetch_global_helper, r0
	|	jmp <1
	|.code

	return 1;
}

static int zend_jit_recv_init(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_bool is_last, zend_ssa *ssa)
{
	zend_arg_info *arg_info;
	zend_bool has_slow = 0;
	uint32_t arg_num = opline->op1.num;
	zval *zv = RT_CONSTANT(op_array, opline->op2);

	|	cmp dword EX->This.u2.num_args, arg_num
	|	jae >4
	|	ZVAL_COPY_CONST FP + opline->result.var, -1, zv, r0
	if (Z_REFCOUNTED_P(zv)) {
	|	ADDREF_CONST zv, r0
	}
	if (Z_CONSTANT_P(zv)) {
		has_slow = 1;
	|	SAVE_VALID_OPLINE opline
	|.if X64
	|	lea CARG1, [FP + opline->result.var]
	|	mov r0, EX->func
	|	mov CARG2, [r0 + offsetof(zend_op_array, scope)]
	|	EXT_CALL zval_update_constant_ex, r0
	|.else
	|	sub r4, 8
	|	mov r0, EX->func
	|	push dword [r0 + offsetof(zend_op_array, scope)]
	|	lea r0, [FP + opline->result.var]
	|	push r0
	|	EXT_CALL zval_update_constant_ex, r0
	|	add r4, 16
	|.endif
	|	test al, al
	|	jnz >7
	}
	|4:
	if (op_array->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) {
		do {
			if (arg_num <= op_array->num_args) {
				arg_info = &op_array->arg_info[arg_num-1];
			} else if (op_array->fn_flags & ZEND_ACC_VARIADIC) {
				arg_info = &op_array->arg_info[op_array->num_args];
			} else {
				break;
			}
			if (!arg_info->type_hint) {
				break;
			}
			has_slow += 2;
			|	lea r0, aword [FP + opline->result.var]
			|	ZVAL_DEREF r0, MAY_BE_REF
			|	cmp byte [r0 + 8], arg_info->type_hint
			|	jne >8
			if (arg_info->class_name) {
			|	mov FCARG1a, r0
			|	mov r0,	EX->run_time_cache
			|	lea r0, [r0 + Z_CACHE_SLOT_P(zv)]
			|	LOAD_ADDR FCARG2a, (ptrdiff_t)op_array
			|.if X64
			|	mov CARG3, arg_num
			|	LOAD_ADDR CARG4, (ptrdiff_t)arg_info
			|	mov CARG5, r0
			|.else
			|	push r0
			|	push (ptrdiff_t)arg_info
			|	push arg_num
			|.endif
			|	EXT_CALL zend_jit_verify_arg_object, r0
			}
		} while (0);
	}
	|9:
	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}
	if (is_last) {
	|	LOAD_ADDR IP, (opline + 1)
		last_valid_opline = (opline + 1);
	}

	if (has_slow) {
	|.cold_code
	if (has_slow & 1) {
	|7:
	|	ZVAL_PTR_DTOR  FP + opline->result.var, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN, 1, 0, 0, op_array->filename, opline->lineno
	|	SET_Z_TYPE_INFO FP + opline->result.var, IS_UNDEF
	|	jmp <4
	}
	if (has_slow & 2) {
	|8:
	|	mov FCARG1a, r0
	|	mov r0,	EX->run_time_cache
	|	lea r0, [r0 + Z_CACHE_SLOT_P(zv)]
	|	LOAD_ADDR FCARG2a, (ptrdiff_t)op_array
	|.if X64
	|	mov CARG3, arg_num
	|	LOAD_ADDR CARG4, (ptrdiff_t)arg_info
	|	mov CARG5, r0
	|	LOAD_ADDR CARG6, zv
	|.else
	|	push zv
	|	push r0
	|	push (ptrdiff_t)arg_info
	|	push arg_num
	|.endif
	|	EXT_CALL zend_jit_verify_arg_slow, r0
	|	jmp <9
	}
	|.code
	}

	return 1;
}

static int zend_jit_fetch_obj_r(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, res_info;
	zend_ssa_var_info *op1_ssa;
	zval *member, *zv;
	zend_property_info *info;

	/* TODO: supports IS_UNUSED? */
	if (opline->op1_type != IS_CV || opline->op2_type != IS_CONST || !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	if ((op1_info & MAY_BE_ANY) != MAY_BE_OBJECT) {
		goto fallback;
	}

	op1_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].op1_use];
	if (!op1_ssa->ce || op1_ssa->is_instanceof || op1_ssa->ce->create_object) {
		goto fallback;
	}

	member = RT_CONSTANT(op_array, opline->op2);
	if (Z_TYPE_P(member) != IS_STRING || Z_STRVAL_P(member)[0] == '\0') {
		goto fallback;
	}

	zv = zend_hash_find(&op1_ssa->ce->properties_info, Z_STR_P(member));
	if (zv == NULL) {
		goto fallback;
	}

	info = (zend_property_info*)Z_PTR_P(zv);
	if (!(info->flags & ZEND_ACC_PUBLIC) || info->offset == ZEND_WRONG_PROPERTY_OFFSET) {
		goto fallback;
	}

	if (opline->op1_type == IS_CV) {
	|	lea r0, [FP + opline->op1.var]
	|	ZVAL_DEREF r0, op1_info
	} else {
	|	lea r0, EX->This
	}
	if (op1_info & MAY_BE_UNDEF) {
	|	IF_Z_TYPE r0, IS_UNDEF, >8
	}
	|	mov r0, [r0]
	|   lea r0, [r0 + info->offset]
	|	// ZVAL_COPY_UNREF
	if (res_info & MAY_BE_REF) {
	|	// ZVAL_COPY_UNREF
	|	IF_NOT_Z_REFCOUNTED r0, >2
	|	GET_Z_PTR r1, r0
	|	IF_NOT_Z_TYPE r0, IS_REFERENCE, >1
	|	cmp dword [r1], 1
	|	jne >1
	|	lea FCARG1a, [FP + opline->result.var]
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_zval_copy_unref_helper, r0
	|	jmp >9
	|1:
	|	GC_ADDREF r1
	|2:
	|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
	} else  {
	|	// ZVAL_COPY
	|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
	|	TRY_ADDREF res_info, ch, r2
	}
	|9: // END

	if (op1_info & MAY_BE_UNDEF) {
	|.cold_code
	|8:
	|.if X64
	|	mov CARG1, 0
	|	LOAD_ADDR CARG2, "Using $this when not in object context"
	|	EXT_CALL zend_throw_error, r0
	|.else
	|	sub r4, 8
	|	push "Using $this when not in object context"
	|	push 0
	|	EXT_CALL zend_throw_error, r0
	|	add r4, 16
	|.endif
	|	jmp <9
	|.code
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

#ifdef ZEND_JIT_RECORD
static int zend_jit_func_header(dasm_State **Dst, zend_op_array *op_array)
{
	|	EXT_CALL zend_jit_func_header_helper, r0
	return 1;
}

static int zend_jit_loop_header(dasm_State **Dst, zend_op_array *op_array, zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst, opline)) {
		return 0;
	}
	|	EXT_CALL zend_jit_loop_header_helper, r0
	return 1;
}
#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
