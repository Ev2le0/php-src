/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,      r14
 |.define IP,      r15
 |.define IPl,     r15d
 |.define CARG1,   rdi       // x64/POSIX C call arguments.
 |.define CARG2,   rsi
 |.define CARG3,   rdx
 |.define CARG4,   rcx
 |.define CARG5,   r8
 |.define CARG6,   r9
 |.define CARG1d,  edi
 |.define CARG2d,  esi
 |.define CARG3d,  edx
 |.define CARG4d,  ecx
 |.define CARG5d,  r8d
 |.define CARG6d,  r9d
 |.define FCARG1a, CARG1    // Simulate x86 fastcall.
 |.define FCARG2a, CARG2
 |.define FCARG1d, CARG1d
 |.define FCARG2d, CARG2d
 |.define SPAD,    8
 |.define SSE,     1
|.else
 |.define FP,      esi
 |.define IP,      edi
 |.define IPl,     edi
 |.define FCARG1a, ecx       // x86 fastcall arguments.
 |.define FCARG2a, edx
 |.define FCARG1d, ecx
 |.define FCARG2d, edx
 |.define SPAD,    12
 |.define SSE,     1
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_opline, IP

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code, cold_codes

|.macro LOAD_ADDR, reg, addr
|.if X64
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.else
|	mov reg, addr
|.endif
|.endmacro

|.macro EXT_CALL, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	call qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	call tmp_reg
||}
|.else
|	call dword &func
|.endif
|.endmacro

|.macro EXT_JMP, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	jmp qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	jmp tmp_reg
||}
|.else
|	jmp dword &func
|.endif
|.endmacro

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0x7fffffff)

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OT_FUNC

|.macro FP_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins qword [op.zv]
|   .endif
||} else {
|   fp_ins qword [FP + op.var]
||}
|.endmacro

|.macro FP_LOAD, op_type, op
|	FP_OP fld, op_type, op
|.endmacro

|.macro FP_MATH, opcode, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
|         FP_OP fadd, op_type, op
||        break;
||    case ZEND_SUB:
|         FP_OP fsub, op_type, op
||        break;
||    case ZEND_MUL:
|         FP_OP fmul, op_type, op
||        break;
||    case ZEND_DIV:
|         FP_OP fdiv, op_type, op
||        break;
||}
|.endmacro

|.macro FP_STORE, op
|    fstp qword [FP + op.var]
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro

|.macro SSE_OP, sse_ins, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   sse_ins reg, qword [r0 + op.constant]
|   .else
|   sse_ins reg, qword [op.zv]
|   .endif
||} else {
|   sse_ins reg, qword [FP + op.var]
||}
|.endmacro

|.macro SSE_LOAD, op_type, op, reg
|	SSE_OP movsd, op_type, op, reg
|.endmacro

|.macro SSE_MATH, opcode, op_type, op, reg
||switch (opcode) {
||    case ZEND_ADD:
|         SSE_OP addsd, op_type, op, reg
||        break;
||    case ZEND_SUB:
|         SSE_OP subsd, op_type, op, reg
||        break;
||    case ZEND_MUL:
|         SSE_OP mulsd, op_type, op, reg
||        break;
||    case ZEND_DIV:
|         SSE_OP divsd, op_type, op, reg
||        break;
||}
|.endmacro

|.macro SSE_MATH2, opcode, reg1, reg2
||switch (opcode) {
||    case ZEND_ADD:
|         addsd reg2, reg1
||        break;
||    case ZEND_SUB:
|         subsd reg2, reg1
||        break;
||    case ZEND_MUL:
|         mulsd reg2, reg1
||        break;
||    case ZEND_DIV:
|         divsd reg2, reg1
||        break;
||}
|.endmacro

|.macro SSE_STORE, op, reg
|    movsd qword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro

|.macro LONG_OP, long_ins, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   	long_ins reg, r1
||  } else {
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   long_ins reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_LOAD, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  } else {
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   mov reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_MATH, opcode, op_type, op, reg
||switch (opcode) {
||    case ZEND_ADD:
|         LONG_OP add, op_type, op, reg
||        break;
||    case ZEND_SUB:
|         LONG_OP sub, op_type, op, reg
||        break;
||    case ZEND_MUL:
|         LONG_OP imul, op_type, op, reg
||        break;
||    case ZEND_DIV:
|         idiv aword [FP + op.var]
||        break;
||}
|.endmacro

|.macro LONGF_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins dword [op.zv]
|   .endif
||} else {
|   fp_ins aword [FP + op.var]
||}
|.endmacro

|.macro LONGF_LOAD, op_type, op
|	LONGF_OP fild, op_type, op
|.endmacro

|.macro LONGF_MATH, opcode
||switch (opcode) {
||    case ZEND_ADD:
|  	   fadd st0, st1
||        break;
||    case ZEND_SUB:
|         fsub st0, st1
||        break;
||    case ZEND_MUL:
|         fmul st0, st1
||        break;
||    case ZEND_DIV:
|         fdiv st0, st1
||        break;
||}
|.endmacro

|.macro LONG_STORE, op, reg
|    mov aword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_LONG
|.endmacro

|.macro ZVAL_COPY_CONST, dst_base, dst_offset, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst_base + dst_offset], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			mov qword [dst_base + dst_offset], tmp_reg
||		} else {
|			mov qword [dst_base + dst_offset], Z_LVAL_P(zv)
||		}
|.else
|		mov dword [dst_base + dst_offset], Z_LVAL_P(zv)
|.endif
||	}
||}
||if ((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) {
|	mov dword [dst_base + dst_offset + 8], Z_TYPE_INFO_P(zv);
||}
|.endmacro

|.macro ZVAL_COPY_VALUE, dst_base, dst_offset, src_base, src_offset, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		mov tmp_reg2, aword [src_base + src_offset]
| 		mov aword [dst_base + dst_offset], tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src_base + src_offset]
|		movsd qword [dst_base + dst_offset], xmm0
|.else
|		fld qword [src_base + src_offset]
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
|		mov tmp_reg2, aword [src_base + src_offset]
|		mov aword [dst_base + dst_offset], tmp_reg2
|.else
|		mov tmp_reg2, dword [src_base + src_offset]
|		mov tmp_reg1, dword [src_base + src_offset + 4]
|		mov dword [dst_base + dst_offset], tmp_reg2
|		mov dword [dst_base + dst_offset + 4], tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	mov dword [dst_base + dst_offset + 8], type
||} else {
|	mov tmp_reg1d, dword [src_base + src_offset + 8]
|	mov dword [dst_base + dst_offset + 8], tmp_reg1d
||}
|.endmacro

|.macro ADDREF_CONST, zv, tmp_reg
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			inc dword [tmp_reg]
||		} else {
|			inc dword [Z_LVAL_P(zv)]
||		}
|.else
|		inc dword [Z_LVAL_P(zv)]
|.endif
|.endmacro

|.macro TRY_ADDREF, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		and type_flags_reg, IS_TYPE_REFCOUNTED
|		je >1
||	}
|	inc	dword [value_ptr_reg]
|1:
||}
|.endmacro

|.macro INC_OPLINE
|	add IP, sizeof(zend_op)
|.endmacro

#endif

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static inline zend_bool is_signed(double d)
{
    return (((unsigned char*)&d)[sizeof(double)-1] & 0x80) != 0;
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|.else
	|	push 0
	|.endif
	|	EXT_CALL zend_timeout, r0
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		|	mov CARG1, FP
		|.else
		|	push FP
		|.endif
		|	EXT_CALL zend_interrupt_function, r0
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline, int may_throw)
{
	| EXT_CALL opline->handler, r0
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	|	add r4, SPAD // stack alignment
	|	EXT_JMP opline->handler, r0
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst, uint32_t skip)
{
	|	add IP, sizeof(zend_op) * skip
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	|	LOAD_ADDR IP, target_opline
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jnz =>target_label
	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	jz =>next_label
	|	cmp IPl, target_opline
	|	jz =>target_label
	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jz >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline, uint32_t *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	if (!zend_jit_handler(Dst, opline, 1)) {
		return 0;
	}
	if (opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL) {
		zend_class_entry *ce = NULL;
#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC
		if (ssa->ops && ssa->var_info) {
			zend_ssa_var_info *res_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].result_def];
			if (res_ssa->ce && !res_ssa->is_instanceof) {
				ce = res_ssa->ce;
			}
		}
#else
		if (opline->op1_type == IS_CONST) {
			zval *zv = RT_CONSTANT(op_array, opline->op1);
			if (Z_TYPE_P(zv) == IS_STRING) {
				zval *lc = zv + 1;
				ce = (zend_class_entry*)zend_hash_find_ptr(EG(class_table), Z_STR_P(lc));
			}
		}
#endif
		(*opnum)++;
		if (!ce || ce->constructor) {
			zend_op *next_opline = opline + 1;
			|	cmp IPl, next_opline
			|	jnz >1
			zend_jit_call(Dst, next_opline);
			|1:
		} else {
			//| INC_OPLINE
		}
	}
	return 1;
}

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC

static int zend_jit_inc_dec(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	if (!ssa->ops || !ssa->var_info || opline->op1_type != IS_CV || opline->result_type != IS_UNUSED) {
		goto fallback;
	}
	op1_info = OP1_INFO();

	if (!(op1_info & MAY_BE_LONG)) {
		goto fallback;
	}

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
		|	jne >2
	}
	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|	inc aword [FP + opline->op1.var]
	} else {
		|	dec aword [FP + opline->op1.var]
	}
	op1_def_info = OP1_DEF_INFO();
	if (op1_def_info & MAY_BE_DOUBLE) {
		|	jo >1
		|.cold_codes
		|1:
		if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
			|.if X64
			|	mov64 rax, 0x43e0000000000000
			|	mov qword [FP + opline->op1.var], rax
			|.else
			|	mov dword [FP + opline->op1.var], 0
			|	mov dword [FP + opline->op1.var + 4], 0x41e00000
			|.endif
		} else {
			|.if X64
			|	mov64 rax, 0xc3e0000000000000
			|	mov qword [FP + opline->op1.var], rax
			|.else
			|	mov dword [FP + opline->op1.var], 0x00200000
			|	mov dword [FP + opline->op1.var + 4], 0xc1e00000
			|.endif
		}
		|	mov dword [FP + opline->op1.var + 8], IS_DOUBLE
		|	jmp >3
		|.code
	}
	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|.cold_codes
		|2:
		|	lea	FCARG1a, [FP + opline->op1.var]
		||	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|		EXT_CALL increment_function, r0
		||	} else {
		|		EXT_CALL decrement_function, r0
		||	}
		|	jmp >3
		|.code
	}
	|3:
	|	INC_OPLINE
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, res_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) &&
		((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG)) {
		res_info = RES_INFO();
		|	LONG_LOAD opline->op1_type, opline->op1, r0
		|	LONG_MATH opline->opcode, opline->op2_type, opline->op2, r0
		if ((res_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) {
			|	LONG_STORE opline->result, r0
		} else {
			|	jo >1
			|.cold_codes
			|1:
			|	LONGF_LOAD opline->op2_type, opline->op2
			|	LONGF_LOAD opline->op1_type, opline->op1
			|	LONGF_MATH opline->opcode
			|	FP_STORE opline->result
			|	jmp >2
			|.code
			|	LONG_STORE opline->result, r0
			|2:
		}
	} else if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE)) {
		|.if X64 or SSE
		|	SSE_LOAD opline->op1_type, opline->op1, xmm0
		if (opline->op1_type == opline->op2_type && opline->op1.var == opline->op2.var) {
			|	SSE_MATH2 opline->opcode, xmm0, xmm0
		} else {
			|	SSE_MATH opline->opcode, opline->op2_type, opline->op2, xmm0
		}
		|	SSE_STORE opline->result, xmm0
		|.else
		|	FP_LOAD opline->op1_type, opline->op1
		|	FP_MATH opline->opcode, opline->op2_type, opline->op2
		|	FP_STORE opline->result
		|.endif
    } else {
		goto fallback;
    }
	|	INC_OPLINE

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	unsigned int target_label;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}
	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG)) {
		|	LONG_LOAD opline->op1_type, opline->op1, r0
		|	LONG_OP cmp, opline->op2_type, opline->op2, r0
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| jne => target_label
					break;
				case ZEND_IS_NOT_EQUAL:
					| je => target_label
					break;
				case ZEND_IS_SMALLER:
					| jg => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jge => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
		           (opline+1)->op1_type == IS_TMP_VAR &&
		           (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| je => target_label
					break;
				case ZEND_IS_NOT_EQUAL:
					| jne => target_label
					break;
				case ZEND_IS_SMALLER:
					| jl => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jle => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else {
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					|	sete al
					|	add eax, 2
				case ZEND_IS_NOT_EQUAL:
					|	setne al
					|	add eax, 2
					break;
				case ZEND_IS_SMALLER:
					|	setl al
					|	add eax, 2
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					|	setle al
					|	add eax, 2
					break;
			}
			|	mov dword [FP + opline->result.var + 8], eax
			| INC_OPLINE
		}
	} else if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE)) {
		|.if X64 or SSE
		|	SSE_LOAD opline->op1_type, opline->op1, xmm0
		|	SSE_OP ucomisd, opline->op2_type, opline->op2, xmm0
		|.else
		|	FP_LOAD opline->op2_type, opline->op2
		|	FP_LOAD opline->op1_type, opline->op1
		|	fucomip st1
		|	fstp st0
		|.endif
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| jp >1
					| je => target_label
					|1:
					break;
				case ZEND_IS_NOT_EQUAL:
					| jp >1
					| jne => target_label
					|1:
					break;
				case ZEND_IS_SMALLER:
					| ja => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jae => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
		           (opline+1)->op1_type == IS_TMP_VAR &&
		           (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| jp >1
					| jne => target_label
					|1:
					break;
				case ZEND_IS_NOT_EQUAL:
					| jp >1
					| je => target_label
					|1:
					break;
				case ZEND_IS_SMALLER:
					| jna => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jnae => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else {
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					|	jp >1
					|	mov eax, IS_TRUE
					|	je >2
					|1:
					|	mov eax, IS_FALSE
					|2:
					break;
				case ZEND_IS_NOT_EQUAL:
					|	jp >1
					|	mov eax, IS_TRUE
					|	jne >2
					|1:
					|	mov eax, IS_FALSE
					|2:
					break;
				case ZEND_IS_SMALLER:
					|	seta al
					|	add eax, 2
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					|	setae al
					|	add eax, 2
					break;
			}
			|	mov dword [FP + opline->result.var + 8], eax
			| INC_OPLINE
		}
    } else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_simple_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t var, uint32_t var_info, zend_uchar val_type, znode_op val, uint32_t val_info)
{
	if (val_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		/* TODO: Support for references ??? */
		goto fallback;
	} else if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);
		|	ZVAL_COPY_CONST FP, var, var_info, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
		|	INC_OPLINE
		return 1;
	}

	|	ZVAL_COPY_VALUE FP, var, FP, val.var, val_info, r0, eax, r1
	||	if (val_type == IS_CV) {
	|		TRY_ADDREF val_info, ah, r1
	||	}
	|	INC_OPLINE

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_qm_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->result.var, -1, opline->op1_type, opline->op1, op1_info);

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNDEF ||
	    !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (!(op1_info & (MAY_BE_STRING|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_REF))) {
		return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info);
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_push_stack_frame(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_function *func)
{
	if (!func) {
		assert(0);
	}

	uint32_t used_stack = zend_vm_calc_used_stack(opline->extended_value, func);

	|	// if (UNEXPECTED(used_stack > (size_t)(((char*)EG(vm_stack_end)) - (char*)call))) {
	|	LOAD_ADDR r1, EG(vm_stack_top)
	|	LOAD_ADDR r2, EG(vm_stack_end)
	|	sub r2,r1
	|	cmp r2, used_stack
	|	jz >1 // TODO proper condition
		// EG(vm_stack_top) = (zval*)((char*)call + used_stack);
	|	// ???
	|	// zend_vm_init_call_frame(call, call_info, func, num_args, called_scope, object);
	|	//???
	|.cold_codes
	|1:
	|	//???
	|	jmp >2
	|.code
	|2:

	return 1;
}

static int zend_jit_init_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_function *func = NULL;

	if (info) {
		zend_call_info *call_info = info->callee_info;

		while (call_info && call_info->caller_init_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|	LOAD_ADDR r0, func
	} else if (func && op_array == &func->op_array) {
		/* recursive call */
		|	mov r0,	EX->func
	} else {
		zval *zv = RT_CONSTANT(op_array, opline->op2);

		|	// if (CACHED_PTR(Z_CACHE_SLOT_P(fname))) {
		|	mov r0,	EX->run_time_cache
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
		|	test r0, r0
		|	jz >1
		|.cold_codes
		|1:
		|	// if ((func = zend_hash_find(EG(function_table), Z_STR_P(fname))) == NULL) {
		|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
		|	EXT_CALL zend_hash_find, r0
		|	test r0, r0
		|	jz >2
		|	mov r0, aword [r0]
		|	jmp >3
		|2:
		|	// SAVE_OPLINE();
		|	mov EX->opline, IP
		|	// zend_throw_error(NULL, "Call to undefined function %s()", Z_STRVAL_P(fname));
		|.if X64
		|	xor CARG1, CARG1
		|	LOAD_ADDR CARG2, "Call to undefined function %s()"
		|	LOAD_ADDR CARG3, Z_STRVAL_P(zv)
		|.else
		|	push 0
		|	push "Call to undefined function %s()"
		|	push Z_STRVAL_P(zv)
		|.endif
		|	EXT_CALL zend_throw_error, r0
		|	jmp ->exception_handler
		|.code
		|3:
	}
	if (!zend_jit_push_stack_frame(Dst, opline, op_array, func)) {
		return 0;
	}
	|	// call->prev_execute_data = EX(call);
	|	mov	r1, EX->call
	|	mov EX:r0->prev_execute_data, r1
	|	// EX(call) = call;
	|	mov EX->call, r0

	return 1;
}

static int zend_jit_send_val(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);

		|	mov r0, EX->call
		|	ZVAL_COPY_CONST r0, opline->result.var, -1, zv, r1
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r1
		||	}
		|	INC_OPLINE
		return 1;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	|	mov r0, EX->call
	|	ZVAL_COPY_VALUE r0, opline->result.var, FP, opline->op1.var, op1_info, r1, ecx, r2
	|	INC_OPLINE
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_send_var(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	if (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		// TODO: support for references ???
		goto fallback;
	}

	op1_info = OP1_INFO();
	|	mov r0, EX->call
	|	ZVAL_COPY_VALUE r0, opline->result.var, FP, opline->op1.var, op1_info, r1, ecx, r2
	||	if (opline->op1_type == IS_CV) {
	|		TRY_ADDREF op1_info, ch, r2
	||	}
	|	INC_OPLINE
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_type_check(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	unsigned int target_label;
	zend_uchar type;

	if (!ssa->ops || !ssa->var_info || opline->extended_value == IS_RESOURCE) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	type = opline->extended_value;
	if ((op1_info & (MAY_BE_ANY|MAY_BE_UNDEF|MAY_BE_REF)) == (1<<type)) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|   add IP, sizeof(zend_op) * 2
			}
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else {
			|	mov dword [FP + opline->result.var + 8], IS_TRUE
			|	INC_OPLINE
		}
    } else if (!(op1_info & (1<<type))) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
			|	add IP, sizeof(zend_op) * 2
			}
		} else {
			|	mov dword [FP + opline->result.var + 8], IS_FALSE
			|	INC_OPLINE
		}
	} else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
