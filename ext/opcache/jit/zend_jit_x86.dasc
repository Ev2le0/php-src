/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,     r14
 |.define IP,     r15
 |.define IPl,    r15d
 |.define CARG1,  rdi       // x64/POSIX C call arguments.
 |.define CARG2,  rsi
 |.define CARG3,  rdx
 |.define CARG4,  rcx
 |.define CARG5,  r8
 |.define CARG6,  r9
 |.define CARG1d, edi
 |.define CARG2d, esi
 |.define CARG3d, edx
 |.define CARG4d, ecx
 |.define CARG5d, r8d
 |.define CARG6d, r9d
 |.define FCARG1, CARG1d    // Simulate x86 fastcall.
 |.define FCARG2, CARG2d
 |.define SPAD,   8
|.else
 |.define FP,     esi
 |.define IP,     edi
 |.define IPl,    edi
 |.define FCARG1, ecx       // x86 fastcall arguments.
 |.define FCARG2, edx
 |.define SPAD,   12
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_opline, IP

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code

|.macro load_addr, reg, addr
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.endmacro

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0x7fffffff)

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	if (IS_32BIT(dasm_end) && IS_32BIT(zend_timeout)) {
	|	call qword &zend_timeout
	} else {
	|	load_addr rax, zend_timeout
	|	call rax
	}
	|.else
	|	push 0
	|	call dword &zend_timeout
	|.endif
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		if (IS_32BIT(dasm_end) && IS_32BIT(zend_interrupt_function)) {
		|	mov CARG1, FP
		|	call qword &zend_interrupt_function
		} else {
		|	load_addr rax, zend_interrupt_function
		|	mov CARG1, FP
		|	call rax
		}
		|.else
		|	push FP
		|	call dword &zend_interrupt_function
		|.endif
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|.if X64
	if (IS_32BIT(dasm_end) && IS_32BIT(EG(exception_op)->handler)) {
	|	jmp qword &(EG(exception_op)->handler)
	} else {
	|	load_addr rax, EG(exception_op)->handler
	|	jmp rax
	}
	|.else
	|	jmp dword &(EG(exception_op)->handler)
	|.endif

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline, int may_throw)
{
	const void *handler = opline->handler;

	|.if X64
	if (IS_32BIT(dasm_end) && IS_32BIT(handler)) {
	|	call qword &handler
	} else {
	|	load_addr rax, handler
	|	call rax
	}
	|.else
	|	call dword &handler
	|.endif
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	const void *handler = opline->handler;

	|	add r4, SPAD // stack alignment
	|.if X64
	if (IS_32BIT(dasm_end) && IS_32BIT(handler)) {
	|	jmp qword &handler
	} else {
	|	load_addr rax, handler
	|	jmp rax
	}
	|.else
	|	jmp dword &handler
	|.endif
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst, uint32_t skip)
{
	|	add IP, sizeof(zend_op) * skip
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	|.if X64
	|	load_addr IP, target_opline
	|.else
	|	mov IP, target_opline
	|.endif
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jnz =>target_label
	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	jz =>next_label
	|	cmp IPl, target_opline
	|	jz =>target_label
	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jz >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL)) {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jnz >1
		zend_jit_call(Dst, next_opline);
		|1:
	}
	return 1;
}

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_FULL

|.macro fp_op, fp_ins, op_type, op
|| if (op_type == IS_CONST) {
|    .if X64
|    mov r0, aword EX->literals
|    fp_ins qword [r0 + op.constant]
|    .else
|    fp_ins qword [op.zv]
|    .endif
|| } else {
|    fp_ins qword [FP + op.var]
|| }
|.endmacro
|
|.macro fp_load, op_type, op
|	fp_op fld, op_type, op
|.endmacro
|
|.macro fp_math, opcode, op_type, op
|| switch (opcode) {
||     case ZEND_ADD:
|	       fp_op fadd, op_type, op
||         break;
||     case ZEND_SUB:
|	       fp_op fsub, op_type, op
||         break;
||     case ZEND_MUL:
|	       fp_op fmul, op_type, op
||         break;
||     case ZEND_DIV:
|	       fp_op fdiv, op_type, op
||         break;
|| }
|.endmacro
|
|.macro fp_store, op
|    fstp qword [FP + op.var]
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro
|
|.macro sse_op, sse_ins, op_type, op, reg
|| if (op_type == IS_CONST) {
|    .if X64
|    mov r0, aword EX->literals
|    sse_ins reg, qword [r0 + op.constant]
|    .else
|    sse_ins reg, qword [op.zv]
|    .endif
|| } else {
|    sse_ins reg, qword [FP + op.var]
|| }
|.endmacro
|
|.macro sse_load, op_type, op, reg
|	sse_op movsd, op_type, op, reg
|.endmacro
|
|.macro sse_math, opcode, op_type, op, reg
|| switch (opcode) {
||     case ZEND_ADD:
|	       sse_op addsd, op_type, op, reg
||         break;
||     case ZEND_SUB:
|	       sse_op subsd, op_type, op, reg
||         break;
||     case ZEND_MUL:
|	       sse_op mulsd, op_type, op, reg
||         break;
||     case ZEND_DIV:
|	       sse_op divsd, op_type, op, reg
||         break;
|| }
|.endmacro
|
|.macro sse_math2, opcode, reg1, reg2
|| switch (opcode) {
||     case ZEND_ADD:
|	       addsd reg2, reg1
||         break;
||     case ZEND_SUB:
|	       subsd reg2, reg1
||         break;
||     case ZEND_MUL:
|	       mulsd reg2, reg1
||         break;
||     case ZEND_DIV:
|	       divsd reg2, reg1
||         break;
|| }
|.endmacro
|
|.macro sse_store, op, reg
|    movsd qword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro
|
|.macro next_opline
|	add IP, sizeof(zend_op)
|.endmacro

static int zend_jit_inc_dec(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	if (!ssa->ops || !ssa->var_info || opline->result_type != IS_UNUSED) {
		goto fallback;
	}
	op1_info = OP1_INFO();

	if (!(op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY)-(MAY_BE_LONG/*|MAY_BE_DOUBLE*/)))) {
		if (op1_info & MAY_BE_LONG) {
			if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
				|	jne >2
			}
			if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
				|	inc aword [FP + opline->op1.var]
			} else {
				|	dec aword [FP + opline->op1.var]
			}
			op1_def_info = OP1_DEF_INFO();
			if (op1_def_info & MAY_BE_DOUBLE) {
				|	jno >2
				if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
					|.if X64
					|	mov64 rax, 0x43e0000000000000
					|	mov qword [FP + opline->op1.var], rax
					|.else
					|	mov dword [FP + opline->op1.var], 0
					|	mov dword [FP + opline->op1.var + 4], 0x41e00000
					|.endif
				} else {
					|.if X64
					|	mov64 rax, 0x43e0000000000000
					|	mov qword [FP + opline->op1.var], rax
					|.else
					|	mov dword [FP + opline->op1.var], 0x00200000
					|	mov dword [FP + opline->op1.var + 4], 0xc1e00000
					|.endif
				}
				|	mov dword [FP + opline->op1.var + 8], IS_DOUBLE
				|	jmp >1
			} else if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
				|	jmp >1
			}
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|2:
			|
		}
		|1:
		|	add IP, sizeof(zend_op)
		return 1;
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}
	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE)) {
		|.if X64 // TODO: or SSE ???
		|	sse_load opline->op1_type, opline->op1, xmm0
		if (opline->op1_type == opline->op2_type && opline->op1.var == opline->op2.var) {
			|	sse_math2 opline->opcode, xmm0, xmm0
		} else {
			|	sse_math opline->opcode, opline->op2_type, opline->op2, xmm0
		}
		|	sse_store opline->result, xmm0
		|.else
		|	fp_load opline->op1_type, opline->op1
		|	fp_math opline->opcode, opline->op2_type, opline->op2
		|	fp_store opline->result
		|.endif
		| next_opline
    } else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}
#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
