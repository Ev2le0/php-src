/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,     r14
 |.define IP,     r15
 |.define IPl,    r15d
 |.define CARG1,  rdi       // x64/POSIX C call arguments.
 |.define CARG2,  rsi
 |.define CARG3,  rdx
 |.define CARG4,  rcx
 |.define CARG5,  r8
 |.define CARG6,  r9
 |.define CARG1d, edi
 |.define CARG2d, esi
 |.define CARG3d, edx
 |.define CARG4d, ecx
 |.define CARG5d, r8d
 |.define CARG6d, r9d
 |.define FCARG1, CARG1d    // Simulate x86 fastcall.
 |.define FCARG2, CARG2d
 |.define SPAD,   8
 |.define SSE,    1
|.else
 |.define FP,     esi
 |.define IP,     edi
 |.define IPl,    edi
 |.define FCARG1, ecx       // x86 fastcall arguments.
 |.define FCARG2, edx
 |.define SPAD,   12
 |.define SSE,    1
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_opline, IP

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code

|.macro LOAD_ADDR, reg, addr
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.endmacro

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0x7fffffff)

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	if (IS_32BIT(dasm_end) && IS_32BIT(zend_timeout)) {
	|	call qword &zend_timeout
	} else {
	|	LOAD_ADDR rax, zend_timeout
	|	call rax
	}
	|.else
	|	push 0
	|	call dword &zend_timeout
	|.endif
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		if (IS_32BIT(dasm_end) && IS_32BIT(zend_interrupt_function)) {
		|	mov CARG1, FP
		|	call qword &zend_interrupt_function
		} else {
		|	LOAD_ADDR rax, zend_interrupt_function
		|	mov CARG1, FP
		|	call rax
		}
		|.else
		|	push FP
		|	call dword &zend_interrupt_function
		|.endif
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|.if X64
	if (IS_32BIT(dasm_end) && IS_32BIT(EG(exception_op)->handler)) {
	|	jmp qword &(EG(exception_op)->handler)
	} else {
	|	LOAD_ADDR rax, EG(exception_op)->handler
	|	jmp rax
	}
	|.else
	|	jmp dword &(EG(exception_op)->handler)
	|.endif

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline, int may_throw)
{
	const void *handler = opline->handler;

	|.if X64
	if (IS_32BIT(dasm_end) && IS_32BIT(handler)) {
	|	call qword &handler
	} else {
	|	LOAD_ADDR rax, handler
	|	call rax
	}
	|.else
	|	call dword &handler
	|.endif
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	const void *handler = opline->handler;

	|	add r4, SPAD // stack alignment
	|.if X64
	if (IS_32BIT(dasm_end) && IS_32BIT(handler)) {
	|	jmp qword &handler
	} else {
	|	LOAD_ADDR rax, handler
	|	jmp rax
	}
	|.else
	|	jmp dword &handler
	|.endif
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst, uint32_t skip)
{
	|	add IP, sizeof(zend_op) * skip
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	|.if X64
	|	LOAD_ADDR IP, target_opline
	|.else
	|	mov IP, target_opline
	|.endif
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jnz =>target_label
	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	jz =>next_label
	|	cmp IPl, target_opline
	|	jz =>target_label
	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jz >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL)) {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jnz >1
		zend_jit_call(Dst, next_opline);
		|1:
	}
	return 1;
}

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_FULL

|.macro FP_OP, fp_ins, op_type, op
|| if (op_type == IS_CONST) {
|    .if X64
|    mov r0, aword EX->literals
|    fp_ins qword [r0 + op.constant]
|    .else
|    fp_ins qword [op.zv]
|    .endif
|| } else {
|    fp_ins qword [FP + op.var]
|| }
|.endmacro

|.macro FP_LOAD, op_type, op
|	FP_OP fld, op_type, op
|.endmacro

|.macro FP_MATH, opcode, op_type, op
|| switch (opcode) {
||     case ZEND_ADD:
|	       FP_OP fadd, op_type, op
||         break;
||     case ZEND_SUB:
|	       FP_OP fsub, op_type, op
||         break;
||     case ZEND_MUL:
|	       FP_OP fmul, op_type, op
||         break;
||     case ZEND_DIV:
|	       FP_OP fdiv, op_type, op
||         break;
|| }
|.endmacro

|.macro FP_STORE, op
|    fstp qword [FP + op.var]
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro

|.macro SSE_OP, sse_ins, op_type, op, reg
|| if (op_type == IS_CONST) {
|    .if X64
|    mov r0, aword EX->literals
|    sse_ins reg, qword [r0 + op.constant]
|    .else
|    sse_ins reg, qword [op.zv]
|    .endif
|| } else {
|    sse_ins reg, qword [FP + op.var]
|| }
|.endmacro

|.macro SSE_LOAD, op_type, op, reg
|	SSE_OP movsd, op_type, op, reg
|.endmacro

|.macro SSE_MATH, opcode, op_type, op, reg
|| switch (opcode) {
||     case ZEND_ADD:
|	       SSE_OP addsd, op_type, op, reg
||         break;
||     case ZEND_SUB:
|	       SSE_OP subsd, op_type, op, reg
||         break;
||     case ZEND_MUL:
|	       SSE_OP mulsd, op_type, op, reg
||         break;
||     case ZEND_DIV:
|	       SSE_OP divsd, op_type, op, reg
||         break;
|| }
|.endmacro

|.macro SSE_MATH2, opcode, reg1, reg2
|| switch (opcode) {
||     case ZEND_ADD:
|	       addsd reg2, reg1
||         break;
||     case ZEND_SUB:
|	       subsd reg2, reg1
||         break;
||     case ZEND_MUL:
|	       mulsd reg2, reg1
||         break;
||     case ZEND_DIV:
|	       divsd reg2, reg1
||         break;
|| }
|.endmacro

|.macro SSE_STORE, op, reg
|    movsd qword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_DOUBLE
|.endmacro

|.macro LONG_OP, long_ins, op_type, op, reg
|| if (op_type == IS_CONST) {
|    .if X64
||   if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|    	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|    	long_ins reg, r1
||   } else {
|    	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||   }
|    .else
|    	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|    .endif
|| } else {
|    long_ins reg, aword [FP + op.var]
|| }
|.endmacro

|.macro LONG_LOAD, op_type, op, reg
|| if (op_type == IS_CONST) {
|    .if X64
||   if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|    	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||   } else {
|    	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||   }
|    .else
|    	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|    .endif
|| } else {
|    mov reg, aword [FP + op.var]
|| }
|.endmacro

|.macro LONG_MATH, opcode, op_type, op, reg
|| switch (opcode) {
||     case ZEND_ADD:
|	       LONG_OP add, op_type, op, reg
||         break;
||     case ZEND_SUB:
|	       LONG_OP sub, op_type, op, reg
||         break;
||     case ZEND_MUL:
|	       LONG_OP imul, op_type, op, reg
||         break;
||     case ZEND_DIV:
|	       idiv aword [FP + op.var]
||         break;
|| }
|.endmacro

|.macro LONGF_LOAD, op_type, op
|	FP_OP fild, op_type, op
|.endmacro

|.macro LONGF_MATH, opcode
|| switch (opcode) {
||     case ZEND_ADD:
|		   fadd st0, st1
||         break;
||     case ZEND_SUB:
|	       fsub st0, st1
||         break;
||     case ZEND_MUL:
|	       fmul st0, st1
||         break;
||     case ZEND_DIV:
|	       fdiv st0, st1
||         break;
|| }
|.endmacro


|.macro LONG_STORE, op, reg
|    mov aword [FP + op.var], reg
|    mov dword [FP + op.var + 8], IS_LONG
|.endmacro

|.macro INC_OPLINE
|	add IP, sizeof(zend_op)
|.endmacro

static int zend_jit_inc_dec(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	if (!ssa->ops || !ssa->var_info || opline->result_type != IS_UNUSED) {
		goto fallback;
	}
	op1_info = OP1_INFO();

	if (!(op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY)-(MAY_BE_LONG/*|MAY_BE_DOUBLE*/)))) {
		if (op1_info & MAY_BE_LONG) {
			if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
				|	jne >2
			}
			if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
				|	inc aword [FP + opline->op1.var]
			} else {
				|	dec aword [FP + opline->op1.var]
			}
			op1_def_info = OP1_DEF_INFO();
			if (op1_def_info & MAY_BE_DOUBLE) {
				|	jno >2
				if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
					|.if X64
					|	mov64 rax, 0x43e0000000000000
					|	mov qword [FP + opline->op1.var], rax
					|.else
					|	mov dword [FP + opline->op1.var], 0
					|	mov dword [FP + opline->op1.var + 4], 0x41e00000
					|.endif
				} else {
					|.if X64
					|	mov64 rax, 0x43e0000000000000
					|	mov qword [FP + opline->op1.var], rax
					|.else
					|	mov dword [FP + opline->op1.var], 0x00200000
					|	mov dword [FP + opline->op1.var + 4], 0xc1e00000
					|.endif
				}
				|	mov dword [FP + opline->op1.var + 8], IS_DOUBLE
				|	jmp >1
			} else if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
				|	jmp >1
			}
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|2:
			|
		}
		|1:
		|	INC_OPLINE
		return 1;
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, res_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) &&
		((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG)) {
		res_info = RES_INFO();
		|	LONG_LOAD opline->op1_type, opline->op1, r0
		|	LONG_MATH opline->opcode, opline->op2_type, opline->op2, r0
		if ((res_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) {
			|	LONG_STORE opline->result, r0
		} else {
			| jo >1
			|	LONG_STORE opline->result, r0
			|	jmp >2
			|1:
			|	LONGF_LOAD opline->op2_type, opline->op2
			|	LONGF_LOAD opline->op1_type, opline->op1
			|	LONGF_MATH opline->opcode
			|	FP_STORE opline->result
		}
	} else if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE)) {
		|.if X64 or SSE
		|	SSE_LOAD opline->op1_type, opline->op1, xmm0
		if (opline->op1_type == opline->op2_type && opline->op1.var == opline->op2.var) {
			|	SSE_MATH2 opline->opcode, xmm0, xmm0
		} else {
			|	SSE_MATH opline->opcode, opline->op2_type, opline->op2, xmm0
		}
		|	SSE_STORE opline->result, xmm0
		|.else
		|	FP_LOAD opline->op1_type, opline->op1
		|	FP_MATH opline->opcode, opline->op2_type, opline->op2
		|	FP_STORE opline->result
		|.endif
    } else {
		goto fallback;
    }
	|2:
	|	INC_OPLINE

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	unsigned int target_label;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}
	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG)) {
		|	LONG_LOAD opline->op1_type, opline->op1, r0
		|	LONG_OP cmp, opline->op2_type, opline->op2, r0
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| jne => target_label
					break;
				case ZEND_IS_NOT_EQUAL:
					| je => target_label
					break;
				case ZEND_IS_SMALLER:
					| jg => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jge => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
		           (opline+1)->op1_type == IS_TMP_VAR &&
		           (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| je => target_label
					break;
				case ZEND_IS_NOT_EQUAL:
					| jne => target_label
					break;
				case ZEND_IS_SMALLER:
					| jl => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jle => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else {
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					|	sete al
					|	add eax, 2
				case ZEND_IS_NOT_EQUAL:
					|	setne al
					|	add eax, 2
					break;
				case ZEND_IS_SMALLER:
					|	setg al
					|	add eax, 2
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					|	setge al
					|	add eax, 2
					break;
			}
			|	mov dword [FP + opline->result.var + 8], eax
			| INC_OPLINE
		}
	} else if (((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE) &&
	    ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_DOUBLE)) {
		|.if X64 or SSE
		|	SSE_LOAD opline->op1_type, opline->op1, xmm0
		|	SSE_OP ucomisd, opline->op2_type, opline->op2, xmm0
		|.else
		|	FP_LOAD opline->op2_type, opline->op2
		|	FP_LOAD opline->op1_type, opline->op1
		|	fucomip st1
		|	fstp st0
		|.endif
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| jp >1
					| je => target_label
					|1:
					break;
				case ZEND_IS_NOT_EQUAL:
					| jp >1
					| jne => target_label
					|1:
					break;
				case ZEND_IS_SMALLER:
					| ja => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jae => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
		           (opline+1)->op1_type == IS_TMP_VAR &&
		           (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					| jp >1
					| jne => target_label
					|1:
					break;
				case ZEND_IS_NOT_EQUAL:
					| jp >1
					| je => target_label
					|1:
					break;
				case ZEND_IS_SMALLER:
					| jna => target_label
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					| jnae => target_label
					break;
			}
			if (!(ssa->cfg.blocks[ssa->cfg.blocks[b].successors[1]].flags & ZEND_BB_TARGET)) {
				|	add IP, sizeof(zend_op) * 2
			}
		} else {
			switch (opline->opcode) {
				case ZEND_IS_EQUAL:
					|	jp >1
					|	mov eax, IS_TRUE
					|	je >2
					|1:
					|	mov eax, IS_FALSE
					|2:
					break;
				case ZEND_IS_NOT_EQUAL:
					|	jp >1
					|	mov eax, IS_TRUE
					|	jne >2
					|1:
					|	mov eax, IS_FALSE
					|2:
					break;
				case ZEND_IS_SMALLER:
					|	seta al
					|	add eax, 2
					break;
				case ZEND_IS_SMALLER_OR_EQUAL:
					|	setae al
					|	add eax, 2
					break;
			}
			|	mov dword [FP + opline->result.var + 8], eax
			| INC_OPLINE
		}
    } else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_simple_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t var, zend_uchar val_type, znode_op val, uint32_t val_info)
{
	if (val_type == IS_CV && (val_info & (MAY_BE_UNDEF|MAY_BE_REF|MAY_BE_STRING|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
		/* TODO: allow JIT for Z_ADDREF_P() ??? */
		goto fallback;
	} else if (val_type == IS_VAR && (val_info & MAY_BE_REF)) {
		goto fallback;
	} else if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);

		if (Z_OPT_REFCOUNTED_P(zv)) {
			/* TODO: allow JIT for Z_ADDREF_P() ??? */
			goto fallback;
		}
		if (Z_TYPE_P(zv) > IS_TRUE) {
			if (Z_TYPE_P(zv) == IS_DOUBLE) {
				|.if X64 or SSE
				||	if (Z_DVAL_P(zv) == 0.0) {
				|		xorps xmm0, xmm0
				|.if X64
				||  } else if (!IS_32BIT(zv)) {
				|		mov64 r0, ((uintptr_t)zv)
				|    	movsd xmm0, qword [r0]
				|.endif
				||   } else {
				|    	movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
				||   }
				|	movsd qword [FP + var], xmm0
				|.else
				||	if (Z_DVAL_P(zv) == 0.0) {
				|		fldz
				||	} else if (Z_DVAL_P(zv) == 1.0) {
				|		fld1
				||	} else  {
				|		fld qword [zv]
				||	}
				|	fstp qword [FP + var]
				|.endif
			} else {
				|.if X64
				||	if (!IS_32BIT(Z_LVAL_P(zv))) {
				|		mov64 r0, ((uintptr_t)Z_LVAL_P(zv))
				|    	mov qword [FP + var], r0
				||	} else {
				|		mov qword [FP + var], Z_LVAL_P(zv)
				||	}
				|.else
				|	mov dword [FP + var], Z_LVAL_P(zv)
				|.endif
			}
		}
		|	mov dword [FP + var + 8], Z_TYPE_INFO_P(zv);
		|	INC_OPLINE
		return 1;
	}

	if (val_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
		if (!(val_info & MAY_BE_DOUBLE)) {
			|	mov r0, aword [FP + val.var]
			|	mov aword [FP + var], r0
		} else if ((val_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
			|.if X64 or SSE
			|	movsd xmm0, qword [FP + val.var]
			|	movsd qword [FP + var], xmm0
			|.else
			|	fld qword [FP + val.var]
			|	fstp qword [FP + var]
			|.endif
		} else {
			|.if X64
			|	mov r0, aword [FP + val.var]
			|	mov aword [FP + var], r0
			|.else
			|	mov r0, dword [FP + val.var]
			|	mov r1, dword [FP + val.var + 4]
			|	mov dword [FP + var], r0
			|	mov dword [FP + var + 4], r1
			|.endif
		}
	}

	if ((val_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
	    has_concrete_type(val_info & MAY_BE_ANY)) {
		zend_uchar type = concrete_type(val_info);
		|	mov dword [FP + var + 8], type
	} else {
		|	mov eax, dword [FP + val.var + 8]
		|	mov dword [FP + var + 8], eax
	}
	|	INC_OPLINE

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_qm_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->result.var, opline->op1_type, opline->op1, op1_info);

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNDEF ||
	    !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (!(op1_info & (MAY_BE_STRING|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_REF))) {
		return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->op1.var, opline->op2_type, opline->op2, op2_info);
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
