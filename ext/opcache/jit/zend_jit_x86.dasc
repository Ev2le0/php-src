/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  |          Xinchen Hui <xinchen.h@zend.com>                            |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,      r14
 |.define IP,      r15
 |.define IPl,     r15d
 |.define CARG1,   rdi       // x64/POSIX C call arguments.
 |.define CARG2,   rsi
 |.define CARG3,   rdx
 |.define CARG4,   rcx
 |.define CARG5,   r8
 |.define CARG6,   r9
 |.define CARG1d,  edi
 |.define CARG2d,  esi
 |.define CARG3d,  edx
 |.define CARG4d,  ecx
 |.define CARG5d,  r8d
 |.define CARG6d,  r9d
 |.define FCARG1a, CARG1    // Simulate x86 fastcall.
 |.define FCARG2a, CARG2
 |.define FCARG1d, CARG1d
 |.define FCARG2d, CARG2d
 |.define SPAD,    8
 |.define SSE,     1
|.else
 |.define FP,      esi
 |.define IP,      edi
 |.define IPl,     edi
 |.define FCARG1a, ecx       // x86 fastcall arguments.
 |.define FCARG2a, edx
 |.define FCARG1d, ecx
 |.define FCARG2d, edx
 |.define SPAD,    12
 |.define SSE,     1
|.endif

|.type EX, zend_execute_data, FP
|.type OP, zend_op, IP

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code, cold_code

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0x7fffffff)

|.macro LOAD_ADDR, reg, addr
|.if X64
||if (((ptrdiff_t)addr) <= 0x7fffffff) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.else
|	mov reg, addr
|.endif
|.endmacro

|.macro EXT_CALL, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	call qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	call tmp_reg
||}
|.else
|	call dword &func
|.endif
|.endmacro

|.macro EXT_JMP, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	jmp qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	jmp tmp_reg
||}
|.else
|	jmp dword &func
|.endif
|.endmacro

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OT_FUNC

|.macro LOAD_ZVAL_ADDR, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov reg, aword EX->literals
|   add reg, op.constant
|   .else
|   mov reg, op.zv
|   .endif
||} else {
|   lea reg, qword [FP + op.var]
||}
|.endmacro

|.macro PUSH_ZVAL_ADDR, op_type, op, tmp_reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov tmp_reg, aword EX->literals
|   add tmp_reg, op.constant
|	push tmp_reg
|   .else
|   push op.zv
|   .endif
||} else {
|   lea tmp_reg, qword [FP + op.var]
|	push tmp_reg
||}
|.endmacro

|.macro SET_TYPE_INFO, dst_base, dst_offset, type
|	mov dword [dst_base + dst_offset + 8], type
|.endmacro

|.macro FPU_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins qword [op.zv]
|   .endif
||} else {
|   fp_ins qword [FP + op.var]
||}
|.endmacro

|.macro FPU_LOAD, op_type, op
|	FPU_OP fld, op_type, op
|.endmacro

|.macro FPU_MATH, opcode, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
|         FPU_OP fadd, op_type, op
||        break;
||    case ZEND_SUB:
|         FPU_OP fsub, op_type, op
||        break;
||    case ZEND_MUL:
|         FPU_OP fmul, op_type, op
||        break;
||    case ZEND_DIV:
|         FPU_OP fdiv, op_type, op
||        break;
||}
|.endmacro

|.macro FPU_STORE, dst_base, dst_offset
|	fstp qword [dst_base + dst_offset]
|.endmacro

|.macro SSE_OP, sse_ins, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   sse_ins reg, qword [r0 + op.constant]
|   .else
|   sse_ins reg, qword [op.zv]
|   .endif
||} else {
|   sse_ins reg, qword [FP + op.var]
||}
|.endmacro

|.macro SSE_LOAD_LONG, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   cvtsi2sd reg, qword [r0 + op.constant]
|   .else
|   cvtsi2sd reg, dword [op.zv]
|   .endif
||} else {
|   .if X64
|   cvtsi2sd reg, qword [FP + op.var]
|   .else
|   cvtsi2sd reg, dword [FP + op.var]
|   .endif
||}
|.endmacro

|.macro SSE_LOAD, op_type, op, reg
|	SSE_OP movsd, op_type, op, reg
|.endmacro

|.macro SSE_MATH, opcode, op_type, op, reg
||switch (opcode) {
||    case ZEND_ADD:
|         SSE_OP addsd, op_type, op, reg
||        break;
||    case ZEND_SUB:
|         SSE_OP subsd, op_type, op, reg
||        break;
||    case ZEND_MUL:
|         SSE_OP mulsd, op_type, op, reg
||        break;
||    case ZEND_DIV:
|         SSE_OP divsd, op_type, op, reg
||        break;
||}
|.endmacro

|.macro SSE_MATH2, opcode, reg1, reg2
||switch (opcode) {
||    case ZEND_ADD:
|         addsd reg2, reg1
||        break;
||    case ZEND_SUB:
|         subsd reg2, reg1
||        break;
||    case ZEND_MUL:
|         mulsd reg2, reg1
||        break;
||    case ZEND_DIV:
|         divsd reg2, reg1
||        break;
||}
|.endmacro

|.macro SSE_STORE, dst_base, dst_offset, reg
|	movsd qword [dst_base + dst_offset], reg
|.endmacro

|.macro DOUBLE_STORE, dst_base, dst_offset, reg
|.if X64 or SSE
|	SSE_STORE dst_base, dst_offset, reg
|.else
|	FPU_STORE dst_base, dst_offset
|.endif
|.endmacro

|.macro LONG_OP, long_ins, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   	long_ins reg, r1
||  } else {
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   long_ins reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_LOAD, op_type, op, reg
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  } else {
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   mov reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_MATH, opcode, op_type, op, reg
||switch (opcode) {
||    case ZEND_ADD:
|         LONG_OP add, op_type, op, reg
||        break;
||    case ZEND_SUB:
|         LONG_OP sub, op_type, op, reg
||        break;
||    case ZEND_MUL:
|         LONG_OP imul, op_type, op, reg
||        break;
||    case ZEND_DIV:
|         idiv aword [FP + op.var] // (reg == r0)
||        break;
||}
|.endmacro

|.macro LONG_MATH2, opcode, reg1, reg2
||switch (opcode) {
||    case ZEND_ADD:
|         add reg2, reg1
||        break;
||    case ZEND_SUB:
|         sub reg2, reg1
||        break;
||    case ZEND_MUL:
|         imul reg2, reg1
||        break;
||    case ZEND_DIV:
|         idiv reg2 // (reg1 == r0)
||        break;
||}
|.endmacro

|.macro FPU_LONG_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins dword [op.zv]
|   .endif
||} else {
|   fp_ins aword [FP + op.var]
||}
|.endmacro

|.macro FPU_LONG_LOAD, op_type, op
|	FPU_LONG_OP fild, op_type, op
|.endmacro

|.macro FPU_MATH2, opcode
||switch (opcode) {
||    case ZEND_ADD:
|         fadd st1
||        break;
||    case ZEND_SUB:
|         fsub st1
||        break;
||    case ZEND_MUL:
|         fmul st1
||        break;
||    case ZEND_DIV:
|         fdiv st1
||        break;
||}
|.endmacro

|.macro LONG_STORE, dst_base, dst_offset, reg
|	mov aword [dst_base + dst_offset], reg
|.endmacro

|.macro ZVAL_COPY_CONST, dst_base, dst_offset, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst_base + dst_offset], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			mov qword [dst_base + dst_offset], tmp_reg
||		} else {
|			mov qword [dst_base + dst_offset], Z_LVAL_P(zv)
||		}
|.else
|		mov dword [dst_base + dst_offset], Z_LVAL_P(zv)
|.endif
||	}
||}
||if ((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) {
|	SET_TYPE_INFO dst_base, dst_offset, Z_TYPE_INFO_P(zv)
||}
|.endmacro

|.macro ZVAL_COPY_VALUE, dst_base, dst_offset, src_base, src_offset, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		mov tmp_reg2, aword [src_base + src_offset]
| 		mov aword [dst_base + dst_offset], tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src_base + src_offset]
|		movsd qword [dst_base + dst_offset], xmm0
|.else
|		fld qword [src_base + src_offset]
|		fstp qword [dst_base + dst_offset]
|.endif
||	} else {
|.if X64
|		mov tmp_reg2, aword [src_base + src_offset]
|		mov aword [dst_base + dst_offset], tmp_reg2
|.else
|		mov tmp_reg2, dword [src_base + src_offset]
|		mov tmp_reg1, dword [src_base + src_offset + 4]
|		mov dword [dst_base + dst_offset], tmp_reg2
|		mov dword [dst_base + dst_offset + 4], tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_TYPE_INFO dst_base, dst_offset, type
||} else {
|	mov tmp_reg1d, dword [src_base + src_offset + 8]
|	SET_TYPE_INFO dst_base, dst_offset, tmp_reg1d
||}
|.endmacro

|.macro ADDREF_CONST, zv, tmp_reg
|.if X64
||		if (!IS_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			inc dword [tmp_reg]
||		} else {
|			inc dword [Z_LVAL_P(zv)]
||		}
|.else
|		inc dword [Z_LVAL_P(zv)]
|.endif
|.endmacro

|.macro TRY_ADDREF, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		test type_flags_reg, IS_TYPE_REFCOUNTED
|		je >1
||	}
|	inc	dword [value_ptr_reg]
|1:
||}
|.endmacro

|.macro ZVAL_DEREF, reg, info
||	if (info & MAY_BE_REF) {
|		cmp byte [reg + 8], IS_REFERENCE
|		jne >1
|		mov reg, [reg]
|		add reg, 8
|1:
||	}
|.endmacro

|.macro JNE_SLOW
|	jne >9
||	has_slow = 1;
|.endmacro

|.macro ZVAL_DTOR_FUNC, filename, lineno // arg1 must be in FCARG1a
||	if (ZEND_DEBUG) {
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|		EXT_CALL _zval_dtor_func, r0
|.endmacro

|.macro ZVAL_PTR_DTOR_NOGC, base, offset, filename, lineno
|		test byte [base + offset + 9], IS_TYPE_REFCOUNTED
|		je >1
|		mov FCARG1a, aword [base + offset]
|		dec dword [FCARG1a]
|		jnz >1
|		ZVAL_DTOR_FUNC filename, lineno
|1:
|.endmacro

|.macro ZVAL_PTR_DTOR, base, offset, info, cold, filename, lineno
||	if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
||		if (info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|			// if (Z_REFCOUNTED_P(cv)) {
|			test byte [base + offset + 9], IS_TYPE_REFCOUNTED
||			if (cold) {
|				jne >1
|.cold_code
|1:
||			} else {
|				je >3
||			}
||		}
|		// if (!Z_DELREF_P(cv)) {
|		mov FCARG1a, aword [base + offset]
|		dec dword [FCARG1a]
|		jnz >1
|		// ZVAL_NULL(cv);
|		mov dword [base + offset + 8], IS_NULL
|		// zval_dtor_func(r);
|		ZVAL_DTOR_FUNC filename, lineno
||		if (info & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT)) {
|			jmp >3
||		}
|1:
||		if (info & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT)) {
||			if (info & MAY_BE_REF) {
|				lea r1, [base + offset]
|				// ZVAL_DEREF(z);
|				ZVAL_DEREF r1, info
|				// if (Z_COLLECTABLE_P(z))
|				test byte [r1 + 9], IS_TYPE_COLLECTABLE
|				je >3
|				// if (UNEXPECTED(!Z_GC_INFO_P(z)))
|				mov FCARG1a, aword [r1]
|				cmp word [FCARG1a + 6], 0
|				jne >3
||			} else {
|				// if (Z_COLLECTABLE_P(z))
|				test byte [base + offset + 9], IS_TYPE_COLLECTABLE
|				je >3
|				// if (UNEXPECTED(!Z_GC_INFO_P(z)))
|				mov FCARG1a, aword [base + offset]
|				cmp word [FCARG1a + 6], 0
|				jne >3
||			}
|			// gc_possible_root(Z_COUNTED_P(z))
|			EXT_CALL gc_possible_root, r0
||			if (cold && (info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|				jmp >3
|.code
||			}
||		} else if (cold && (info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|			jmp >3
|.code
||		}
|3:
||	}
|.endmacro

|.macro FREE_OP, op_type, op, op_info, op_array, lineno
||if ((op_type & (IS_VAR|IS_TMP_VAR)) &&
||   (op_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|	ZVAL_PTR_DTOR_NOGC FP, op.var, (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), lineno
||}
|.endmacro

|.macro EFREE_SIZE, ptr, size, op_array, opline
|	mov FCARG1a, ptr
||	if (ZEND_DEBUG) {
||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, opline->lineno
|		xor CARG4, CARG4
|		xor CARG5, CARG5
|.else
|		push opline->lineno
|		push 0
|		push 0
|.endif
||	}
|	EXT_CALL _efree, r0
|.endmacro

|.macro OBJ_RELEASE, reg, exit_label
|	// if (--GC_REFCOUNT(obj) == 0) {
|	dec dword [reg]
|	jne >1
|	// zend_objects_store_del(obj);
|.if X64
|	mov CARG1, reg
|	EXT_CALL zend_objects_store_del, r0
|.else
|	sub r4, 12
|	push reg
|	EXT_CALL zend_objects_store_del, r0
|	add r4, 16
|.endif
|	jmp >exit_label
|1:
|	// if (UNEXPECTED(!GC_INFO(obj))) {
|	cmp word [reg + 6], 0
|	jne >exit_label
|	// gc_possible_root(obj)
|	mov FCARG1a, reg
|	EXT_CALL gc_possible_root, r0
|.endmacro

|.macro SAVE_VALID_OPLINE
||	if (valid_opline || valid_opline_offset) {
||		if (!valid_opline) {
|			lea r0, [IP + sizeof(zend_op) * valid_opline_offset]
||		} else {
||			const zend_op *target_opline = valid_opline + valid_opline_offset;
|			LOAD_ADDR r0, target_opline
||		}
|		mov EX->opline, r0
||	} else {
|		mov EX->opline, IP
||	}
|.endmacro

static const zend_op *valid_opline;
static uint32_t valid_opline_offset;
static int jit_return_label;
#endif

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static inline zend_bool is_signed(double d)
{
    return (((unsigned char*)&d)[sizeof(double)-1] & 0x80) != 0;
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|.else
	|	push 0
	|.endif
	|	EXT_CALL zend_timeout, r0
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		|	mov CARG1, FP
		|.else
		|	push FP
		|.endif
		|	EXT_CALL zend_interrupt_function, r0
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static int zend_jit_leave_function_stub(dasm_State **Dst)
{
	|->leave_function_handler:
	|	add r4, SPAD
	|	test FCARG1d, ZEND_CALL_TOP
	|	jne >1
	|	EXT_JMP zend_jit_leave_nested_func_helper, r0
	|1:
	|	EXT_JMP zend_jit_leave_top_func_helper, r0

	return 1;
}

static int zend_jit_leave_throw_stub(dasm_State **Dst)
{
	|->leave_throw_handler:
	|	// if (opline->opcode != ZEND_HANDLE_EXCEPTION) {
	|	cmp byte OP:IP->opcode, ZEND_HANDLE_EXCEPTION
	|	je >5
	|	// EG(opline_before_exception) = opline;
	|	mov aword [&EG(opline_before_exception)], IP
	|	// if (RETURN_VALUE_USED(old_opline)) {
	|	cmp byte OP:IP->result_type, IS_UNUSED
	|	je >5
	|	// zval_ptr_dtor(EX_VAR(old_opline->result.var));
	|.if X64
	|	movsxd r0, dword OP:IP->result.var
	|.else
	|	mov r0, OP:IP->result.var
	|.endif
	|	add r0, FP
	|	ZVAL_PTR_DTOR r0, 0, MAY_BE_ANY, 0, NULL, 0
	|5:
	|	// EX(opline) = EG(exception_op);
	|	LOAD_ADDR IP, &EG(exception_op)
	|	mov EX->opline, IP
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
	JIT_STUB(leave_function),
	JIT_STUB(leave_throw),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	valid_opline = NULL;
	valid_opline_offset = 0;
	jit_return_label = -1;
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_set_valid_ip(dasm_State **Dst)
{
	if (valid_opline || valid_opline_offset) {
		if (!valid_opline) {
			|	add IP, sizeof(zend_op) * valid_opline_offset
		} else {
			const zend_op *target_opline = valid_opline + valid_opline_offset;

			valid_opline = NULL;
			|	LOAD_ADDR IP, target_opline
		}
		valid_opline_offset = 0;
	}
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst)
{
	if (zend_interrupt_function) {
		if (!zend_jit_set_valid_ip(Dst)) {
			return 0;
		}
	}
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_handler(dasm_State **Dst, zend_op *opline, int may_throw)
{
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	EXT_CALL opline->handler, r0
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	add r4, SPAD // stack alignment
	|	EXT_JMP opline->handler, r0
	return 1;
}

static int zend_jit_skip_handler(dasm_State **Dst)
{
	valid_opline_offset++;
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, zend_op *target_opline)
{
	valid_opline = target_opline;
	valid_opline_offset = 0;
	return 1;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jnz =>target_label

	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	zend_op *next_opline = opline + 1;
	zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	jz =>next_label
	|	cmp IPl, target_opline
	|	jz =>target_label

	return 1;
}

#ifdef CONTEXT_THREDED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	jz >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, zend_op *opline)
{
#ifdef CONTEXT_THREDED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	if (!zend_jit_handler(Dst, opline, 1)) {
		return 0;
	}
	if (opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL) {
		zend_class_entry *ce = NULL;
#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC
		if (ssa->ops && ssa->var_info) {
			zend_ssa_var_info *res_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].result_def];
			if (res_ssa->ce && !res_ssa->is_instanceof) {
				ce = res_ssa->ce;
			}
		}
#else
		if (opline->op1_type == IS_CONST) {
			zval *zv = RT_CONSTANT(op_array, opline->op1);
			if (Z_TYPE_P(zv) == IS_STRING) {
				zval *lc = zv + 1;
				ce = (zend_class_entry*)zend_hash_find_ptr(EG(class_table), Z_STR_P(lc));
			}
		}
#endif
		(*opnum)++;
		if (!ce || ce->constructor) {
			zend_op *next_opline = opline + 1;
			|	cmp IPl, next_opline
			|	jnz >1
			zend_jit_call(Dst, next_opline);
			|1:
		} else {
			valid_opline_offset++;
		}
	}
	return 1;
}

#if ZEND_JIT_LEVEL >= ZEND_JIT_LEVEL_OPT_FUNC

static int zend_jit_inc_dec(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	if (!ssa->ops || !ssa->var_info || opline->op1_type != IS_CV) {
		goto fallback;
	}
	op1_info = OP1_INFO();

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_STRING|MAY_BE_ARRAY)) {
		// TODO: support for IS_STRING and IS_ARRAY ???
		goto fallback;
	}
	if (!(op1_info & MAY_BE_LONG)) {
		goto fallback;
	}

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
		|	jne >2
	}
	||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC) &&
	||	    opline->result_type != IS_UNUSED) {
	|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_LONG, r0, eax, r1
	||	}
	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|	inc aword [FP + opline->op1.var]
	} else {
		|	dec aword [FP + opline->op1.var]
	}
	op1_def_info = OP1_DEF_INFO();
	if (op1_def_info & MAY_BE_DOUBLE) {
		|	jo >1
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
		|.cold_code
		|1:
		if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
			|.if X64
			|	mov64 rax, 0x43e0000000000000
			|	mov qword [FP + opline->op1.var], rax
			|.else
			|	mov dword [FP + opline->op1.var], 0
			|	mov dword [FP + opline->op1.var + 4], 0x41e00000
			|.endif
		} else {
			|.if X64
			|	mov64 rax, 0xc3e0000000000000
			|	mov qword [FP + opline->op1.var], rax
			|.else
			|	mov dword [FP + opline->op1.var], 0x00200000
			|	mov dword [FP + opline->op1.var + 4], 0xc1e00000
			|.endif
		}
		|	SET_TYPE_INFO FP, opline->op1.var, IS_DOUBLE
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_DOUBLE, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	} else {
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
	}
	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
		|.cold_code
		|2:
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	// ZVAL_DEREF(var_ptr);
		|	ZVAL_DEREF FCARG1a, op1_info
		||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC)) {
		||		if (opline->result_type != IS_UNUSED) {
		|			ZVAL_COPY_VALUE FP, opline->result.var, FCARG1a, 0, op1_info, r0, eax, r2
		|			// zval_opt_copy_ctor(var_ptr);
		|			// ???
		|			TRY_ADDREF op1_info, ah, r2
		||		}
		||	} else {
		|		// SEPARATE_ZVAL_NOREF(var_ptr);
		|		// ???
		||	}
		||	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|		EXT_CALL increment_function, r0
		||	} else {
		|		EXT_CALL decrement_function, r0
		||	}
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP, opline->result.var, FP, opline->op1.var, op1_def_info, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	}
	|3:
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_long_long(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t res_forward)
{
	uint32_t res_info = RES_INFO();
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);

	|	LONG_LOAD opline->op1_type, opline->op1, r0
	||	if (same_ops && opline->opcode != ZEND_DIV) {
	|		LONG_MATH2 opline->opcode, r0, r0
	||	} else {
	|		LONG_MATH opline->opcode, opline->op2_type, opline->op2, r0
	||	}
	if ((res_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_LONG) {
		if (res_forward) {
			|	LONG_STORE r1, res_forward, r0
			|	SET_TYPE_INFO r1, res_forward, IS_LONG
		} else {
			|	LONG_STORE FP, opline->result.var, r0
			|	SET_TYPE_INFO FP, opline->result.var, IS_LONG
		}
	} else {
		|	jo >1
		|.cold_code
		|1:
		|.if X64 or SSE
		|	SSE_LOAD_LONG opline->op1_type, opline->op1, xmm0
		|	SSE_LOAD_LONG opline->op2_type, opline->op2, xmm1
		|	SSE_MATH2 opline->opcode, xmm1, xmm0
		|.else
		|	FPU_LONG_LOAD opline->op2_type, opline->op2
		|	FPU_LONG_LOAD opline->op1_type, opline->op1
		|	FPU_MATH2 opline->opcode
		|.endif
		if (res_forward) {
			|	DOUBLE_STORE r1, res_forward, xmm0
			|	SET_TYPE_INFO r1, res_forward, IS_DOUBLE
		} else {
			|	DOUBLE_STORE FP, opline->result.var, xmm0
			|	SET_TYPE_INFO FP, opline->result.var, IS_DOUBLE
		}
		|	jmp >2
		|.code
		if (res_forward) {
			|	LONG_STORE r1, res_forward, r0
			|	SET_TYPE_INFO r1, res_forward, IS_LONG
		} else {
			|	LONG_STORE FP, opline->result.var, r0
			|	SET_TYPE_INFO FP, opline->result.var, IS_LONG
		}
		|2:
	}

	return 1;
}

static int zend_jit_math_long_double(dasm_State **Dst, zend_op *opline, uint32_t res_forward)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG opline->op1_type, opline->op1, xmm0
	|	SSE_MATH opline->opcode, opline->op2_type, opline->op2, xmm0
	|.else
	|	FPU_LONG_LOAD opline->op1_type, opline->op1
	|	FPU_MATH opline->opcode, opline->op2_type, opline->op2
	|.endif
	if (res_forward) {
		|	DOUBLE_STORE r1, res_forward, xmm0
		|	SET_TYPE_INFO r1, res_forward, IS_DOUBLE
	} else {
		|	DOUBLE_STORE FP, opline->result.var, xmm0
		|	SET_TYPE_INFO FP, opline->result.var, IS_DOUBLE
	}

	return 1;
}

static int zend_jit_math_double_long(dasm_State **Dst, zend_op *opline, uint32_t res_forward)
{
	|.if X64 or SSE
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL) {
	|		SSE_LOAD_LONG opline->op2_type, opline->op2, xmm0
	|		SSE_MATH opline->opcode, opline->op1_type, opline->op1, xmm0
	||	} else {
	|		SSE_LOAD opline->op1_type, opline->op1, xmm0
	|		SSE_LOAD_LONG opline->op2_type, opline->op2, xmm1
	|		SSE_MATH2 opline->opcode, xmm1, xmm0
	||	}
	|.else
	|	FPU_LONG_LOAD opline->op2_type, opline->op2
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL) {
	|		FPU_MATH opline->opcode, opline->op1_type, opline->op1
	||	} else {
	|		FPU_LOAD opline->op1_type, opline->op1
	|		FPU_MATH2 opline->opcode
	||	}
	|.endif
	if (res_forward) {
		|	DOUBLE_STORE r1, res_forward, xmm0
		|	SET_TYPE_INFO r1, res_forward, IS_DOUBLE
	} else {
		|	DOUBLE_STORE FP, opline->result.var, xmm0
		|	SET_TYPE_INFO FP, opline->result.var, IS_DOUBLE
	}

	return 1;
}

static int zend_jit_math_double_double(dasm_State **Dst, zend_op *opline, uint32_t res_forward)
{
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);

	|.if X64 or SSE
	|	SSE_LOAD opline->op1_type, opline->op1, xmm0
	if (same_ops) {
		|	SSE_MATH2 opline->opcode, xmm0, xmm0
	} else {
		|	SSE_MATH opline->opcode, opline->op2_type, opline->op2, xmm0
	}
	|.else
	|	FPU_LOAD opline->op1_type, opline->op1
	|	FPU_MATH opline->opcode, opline->op2_type, opline->op2
	|.endif
	if (res_forward) {
		|	DOUBLE_STORE r1, res_forward, xmm0
		|	SET_TYPE_INFO r1, res_forward, IS_DOUBLE
	} else {
		|	DOUBLE_STORE FP, opline->result.var, xmm0
		|	SET_TYPE_INFO FP, opline->result.var, IS_DOUBLE
	}

	return 1;
}

static int zend_jit_math(dasm_State **Dst, zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow = 0;
	uint32_t  res_forward = 0;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		goto fallback;
	}

	if (opline->result_type == IS_TMP_VAR &&
	    (opline+1)->opcode == ZEND_SEND_VAL &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		/* Eliminate the following SEND_VAL */
		(*opnum)++;
		res_forward = (opline+1)->result.var;
		|	mov r1, EX->call
	}

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
			if (op1_info & MAY_BE_DOUBLE) {
				|	jne >4
			} else {
				|	JNE_SLOW
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
			if (op2_info & MAY_BE_DOUBLE) {
				|	jne >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					|	JNE_SLOW
				}
				if (!zend_jit_math_long_double(Dst, opline, res_forward)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	JNE_SLOW
			}
		}
		if (!zend_jit_math_long_long(Dst, opline, op_array, ssa, res_forward)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				|	JNE_SLOW
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					if (!same_ops) {
						|	jne >5
					} else {
						|	JNE_SLOW
					}
				}
				if (!zend_jit_math_double_double(Dst, opline, res_forward)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
					|	JNE_SLOW
				}
				if (!zend_jit_math_double_long(Dst, opline, res_forward)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, res_forward)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_math_double_long(Dst, opline, res_forward)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, res_forward)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_math_long_double(Dst, opline, res_forward)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	|6:
	if (res_forward) {
		valid_opline_offset += 2;
	} else {
		valid_opline_offset++;
	}

	if (has_slow) {
		|.cold_code
		|9:
		|	mov EX->opline, IP
		if (res_forward) {
			|	lea	FCARG1a, [r1 + res_forward]
		} else {
			|	lea	FCARG1a, [FP + opline->result.var]
		}
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		|.if X64
		|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
		|.else
		|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
		|.endif
		||	if (opline->opcode == ZEND_ADD) {
		|		EXT_CALL add_function, r0
		||	} else if (opline->opcode == ZEND_SUB) {
		|		EXT_CALL sub_function, r0
		||	} else if (opline->opcode == ZEND_MUL) {
		|		EXT_CALL mul_function, r0
		||	} else if (opline->opcode == ZEND_DIV) {
		|		EXT_CALL div_function, r0
		||	} else {
		||		ZEND_ASSERT(0);
		||	}
		|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
		|	FREE_OP opline->op2_type, opline->op2, op2_info, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		|	jmp <6
		|.code
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp_long_long(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	LONG_LOAD opline->op1_type, opline->op1, r0
	|	LONG_OP cmp, opline->op2_type, opline->op2, r0
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_TYPE_INFO FP, opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_double_common(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jnae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jna => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	jp >1
				|	mov eax, IS_TRUE
				|	je >2
				|1:
				|	mov eax, IS_FALSE
				|2:
				break;
			case ZEND_IS_NOT_EQUAL:
				|	jp >1
				|	mov eax, IS_FALSE
				|	je >2
				|1:
				|	mov eax, IS_TRUE
				|2:
				break;
			case ZEND_IS_SMALLER:
				|	setnae al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setna al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_TYPE_INFO FP, opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_long_double(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD_LONG opline->op1_type, opline->op1, xmm0
	|	SSE_OP ucomisd, opline->op2_type, opline->op2, xmm0
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LONG_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_long(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD opline->op1_type, opline->op1, xmm0
	|	SSE_LOAD_LONG opline->op2_type, opline->op2, xmm1
	|	ucomisd xmm0, xmm1
	|.else
	|	FPU_LONG_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_double(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	|	SSE_LOAD opline->op1_type, opline->op1, xmm0
	|	SSE_OP ucomisd, opline->op2_type, opline->op2, xmm0
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_slow(dasm_State **Dst, zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	cmp aword [FP + opline->result.var], 0
	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				|	movzx eax, al
				|	add eax, 2
				break;
		}
		|	SET_TYPE_INFO FP, opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow = 0;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
			if (op1_info & MAY_BE_DOUBLE) {
				|	jne >4
			} else {
				|	JNE_SLOW
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
			if (op2_info & MAY_BE_DOUBLE) {
				|	jne >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					|	JNE_SLOW
				}
				if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	JNE_SLOW
			}
		}
		if (!zend_jit_cmp_long_long(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				|	JNE_SLOW
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
					if (!same_ops) {
						|	jne >5
					} else {
						|	JNE_SLOW
					}
				}
				if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
					|	JNE_SLOW
				}
				if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op2.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	cmp	dword [FP + opline->op2.var + 8], IS_DOUBLE
			|	JNE_SLOW
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_DOUBLE
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	jne >3
				} else {
					|	JNE_SLOW
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	cmp	dword [FP + opline->op1.var + 8], IS_LONG
				|	JNE_SLOW
			}
			if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	if (has_slow ||
	    !(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (has_slow) {
			|.cold_code
			|9:
		}
		|	mov EX->opline, IP
		if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
			|	cmp dword [FP + opline->op1.var + 8], 0
			|	jnz >1
			|1:
		}
		|	lea	FCARG1a, [FP + opline->result.var]
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		|.if X64
		|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
		|.else
		|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
		|.endif
		|	EXT_CALL compare_function, r0
		||	if (opline->opcode != ZEND_CASE) {
		|		FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
		||	}
		|	FREE_OP opline->op2_type, opline->op2, op2_info, op_array, opline->lineno
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		if (!zend_jit_cmp_slow(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (has_slow) {
			|	jmp >6
			|.code
		}
	}

	|6:
	if (((opline+1)->opcode == ZEND_JMPZ || (opline+1)->opcode == ZEND_JMPNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		valid_opline_offset += 2;
	} else {
		valid_opline_offset++;
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_simple_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, uint32_t var, uint32_t var_info, zend_uchar val_type, znode_op val, uint32_t val_info)
{
	if (val_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		/* TODO: Support for references ??? */
		goto fallback;
	} else if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);
		|	ZVAL_COPY_CONST FP, var, var_info, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
		valid_opline_offset++;
		return 1;
	}

	|	ZVAL_COPY_VALUE FP, var, FP, val.var, val_info, r0, eax, r1
	||	if (val_type == IS_CV) {
	|		TRY_ADDREF val_info, ah, r1
	||	}
	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_qm_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->result.var, -1, opline->op1_type, opline->op1, op1_info);

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED || !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (!(op1_info & (MAY_BE_STRING|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_REF))) {
		return zend_jit_simple_assign(Dst, opline, op_array, ssa, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info);
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_push_call_frame(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_function *func)
{
	if (!func) {
		assert(0);
	}

	uint32_t used_stack = zend_vm_calc_used_stack(opline->extended_value, func);

	|	// if (UNEXPECTED(used_stack > (size_t)(((char*)EG(vm_stack_end)) - (char*)call))) {
	|	mov r1, aword [&EG(vm_stack_top)]
	|	mov r2, aword [&EG(vm_stack_end)]
	|	sub r2,r1
	|	cmp r2, used_stack
	|	jb >2
	|	// EG(vm_stack_top) = (zval*)((char*)call + used_stack);
	|	add aword [&EG(vm_stack_top)], used_stack
	|	// zend_vm_init_call_frame(call, call_info, func, num_args, called_scope, object);
	|	// call->func = func;
	|	mov aword EX:r1->func, r0
	|	// ZEND_SET_CALL_INFO(call, 0, call_info);
	|	mov dword EX:r1->This.u1.type_info, (IS_UNDEF | (ZEND_CALL_NESTED_FUNCTION << ZEND_CALL_INFO_SHIFT))
	|1:
	|	// Z_CE(call->This) = called_scope;
	|	mov aword EX:r1->This.value.ptr, 0
	|	// ZEND_CALL_NUM_ARGS(call) = num_args;
	|	mov dword EX:r1->This.u2.num_args, opline->extended_value
	|.cold_code
	|2:
	|	mov FCARG1d, used_stack
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_extend_stack_helper, r0
	|	mov r1, r0
	|	jmp <1
	|.code

	return 1;
}

static int zend_jit_init_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_function *func = NULL;

	if (info) {
		zend_call_info *call_info = info->callee_info;

		while (call_info && call_info->caller_init_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|	LOAD_ADDR r0, func
	} else if (func && op_array == &func->op_array) {
		/* recursive call */
		|	mov r0,	EX->func
	} else {
		zval *zv = RT_CONSTANT(op_array, opline->op2);

		|	// if (CACHED_PTR(Z_CACHE_SLOT_P(fname)))
		|	mov r0,	EX->run_time_cache
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
		|	test r0, r0
		|	jz >1
		|.cold_code
		|1:
		|	// SAVE_OPLINE();
		|	mov EX->opline, IP
		|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
		|	EXT_CALL zend_jit_find_func_helper, r0
		|	// This opcode must not throw exception ???
		|		// test r0, r0
		|		// jz ->exception_handler */
		|	// CACHE_PTR(Z_CACHE_SLOT_P(fname), fbc);
		|	mov r1,	EX->run_time_cache
		|	mov aword [r1 + Z_CACHE_SLOT_P(zv)], r0
		|	jmp >3
		|.code
		|3:
	}
	if (!zend_jit_push_call_frame(Dst, opline, op_array, func)) {
		return 0;
	}
	|	// call->prev_execute_data = EX(call);
	if (call_level == 1) {
		|	mov aword EX:r1->prev_execute_data, 0
	} else {
		|	mov r0, EX->call
		|	mov EX:r1->prev_execute_data, r0
	}
	|	// EX(call) = call;
	|	mov EX->call, r1
	valid_opline_offset++;

	return 1;
}

static int zend_jit_do_fcall(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;
	uint32_t i;

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_call_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (!func ||
	    func->type != ZEND_USER_FUNCTION ||
	    call_info->num_args > func->op_array.num_args ||
	    (opline-1)->opcode == ZEND_SEND_UNPACK ||
	    (func->op_array.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0) {
		goto fallback;
	}

	|	// call = EX(call);
	|	mov r1, EX->call
	|	// fbc = call->func;
	|	// mov r2, EX:r1->func ???
	|	// SAVE_OPLINE();
	if (!zend_jit_set_valid_ip(Dst)) {
		return 0;
	}
	|	mov EX->opline, IP
	||	if (call_level == 1) {
	|		mov aword EX->call, 0
	||	} else {
	|		//EX(call) = call->prev_execute_data;
	|		mov r0, EX:r1->prev_execute_data
	|		mov EX->call, r0
	||	}
	|	//call->prev_execute_data = execute_data;
	|	mov EX:r1->prev_execute_data, EX
	|
	|	// EX(call) = NULL;
	|	mov aword EX:r1->call, 0
	||	if (RETURN_VALUE_USED(opline)) {
	|		// ZVAL_NULL(EX_VAR(opline->result.var));
	|		SET_TYPE_INFO FP, opline->result.var, IS_NULL
	|		// EX(return_value) = EX_VAR(opline->result.var);
	|		lea r0, aword [FP + opline->result.var]
	|		mov aword EX:r1->return_value, r0
	||	} else {
	|		// EX(return_value) = 0;
	|		mov aword EX:r1->return_value, 0
	||	}
	|
	||	for (i = call_info->num_args; i < func->op_array.last_var; i++) {
	||		uint32_t n = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
	|		SET_TYPE_INFO r1, n, IS_UNDEF
	||	}
	|
	|	//EX_LOAD_RUN_TIME_CACHE(op_array);
	||	if (!func || func->op_array.cache_size) {
	||		if (func && op_array == &func->op_array) {
	||			/* recursive call */
	||			if (func->op_array.cache_size > sizeof(void*)) {
	|				mov r0, EX->run_time_cache
	|				mov EX:r1->run_time_cache, r0
	||			}
	||		} else {
	|			mov r2, EX:r1->func
	|			mov r0, aword [r2 + offsetof(zend_op_array, run_time_cache)]
	|			mov EX:r1->run_time_cache, r0
	||		}
	||	}
	|	//EX_LOAD_LITERALS(op_array);
	|.if X64
	|	LOAD_ADDR r0, func->op_array.literals
	|	mov EX:r1->literals, r0
	|.endif
	|	// EG(current_execute_data) = execute_data;
	|	mov aword [&EG(current_execute_data)], r1
	|	mov FP, r1
	|	// EX(opline) = op_array->opcodes;
	|	LOAD_ADDR IP, (func->op_array.opcodes + call_info->num_args)
	|	mov EX:r1->opline, IP
	||	if (func && op_array == &func->op_array) {
	||		/* recursive call */
	|		jmp =>call_info->num_args
	||	} else {
	|		add r4, SPAD // stack alignment
	|		jmp aword [IP]
	||	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	if (opline->opcode == ZEND_DO_FCALL ||
	    opline->opcode == ZEND_DO_UCALL ||
	    opline->opcode == ZEND_DO_FCALL_BY_NAME ){
		return zend_jit_call(Dst, opline);
	} else {
		return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
	}
}

static int zend_jit_send_val(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	uint32_t arg_num = opline->op2.num;

	if (opline->opcode == ZEND_SEND_VAL_EX && arg_num > MAX_ARG_FLAG_NUM) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	|	mov r1, EX->call

	if (opline->opcode == ZEND_SEND_VAL_EX) {
		uint32_t mask = ZEND_SEND_BY_REF << ((arg_num + 3) * 2);

		|	mov r0, EX:r1->func
		if (arg_num <= MAX_ARG_FLAG_NUM) {
			|	mov eax, dword [r0 + offsetof(zend_function, quick_arg_flags)]
			|	test eax, mask
			|	jnz	>1
		} else {
			ZEND_ASSERT(0);
		}
		|.cold_code
		|1:
		|	SET_TYPE_INFO r1, opline->result.var, IS_UNDEF
		|	mov EX->opline, IP
		|.if X64
		|	mov CARG1, 0
		|	LOAD_ADDR CARG2, "Cannot pass parameter %d by reference"
		|	mov CARG3d, arg_num
		|	EXT_CALL zend_throw_error, r0
		|.else
		|	sub r4, 4
		|	push arg_num
		|	push "Cannot pass parameter %d by reference"
		|	push 0
		|	EXT_CALL zend_throw_error, r0
		|	add r4, 16
		|.endif
		|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno
		|	jmp ->exception_handler
		|.code
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);

		|	ZVAL_COPY_CONST r1, opline->result.var, -1, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
	} else {
		|	ZVAL_COPY_VALUE r1, opline->result.var, FP, opline->op1.var, op1_info, r0, eax, r2
	}
	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_send_var(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	if (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) {
		// TODO: support for references ???
		goto fallback;
	}

	op1_info = OP1_INFO();
	|	mov r1, EX->call
	|	ZVAL_COPY_VALUE r1, opline->result.var, FP, opline->op1.var, op1_info, r0, eax, r2
	||	if (opline->op1_type == IS_CV) {
	|		TRY_ADDREF op1_info, ah, r2
	||	}
	valid_opline_offset++;
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_type_check(dasm_State **Dst, zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, mask;
	unsigned int target_label;
	zend_uchar type;

	if (!ssa->ops || !ssa->var_info || opline->extended_value == IS_RESOURCE) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	type = opline->extended_value;
	if (type == IS_RESOURCE) {
		goto fallback;
	} else if (type == _IS_BOOL) {
		mask = MAY_BE_FALSE | MAY_BE_TRUE;
	} else {
		mask = (1 << type);
	}
	if (!(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF|MAY_BE_REF) - mask))) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			valid_opline_offset++;
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else {
			|	SET_TYPE_INFO FP, opline->result.var, IS_TRUE
			valid_opline_offset++;
		}
    } else if (!(op1_info & mask)) {
		if ((opline+1)->opcode == ZEND_JMPZ &&
		    (opline+1)->op1_type == IS_TMP_VAR &&
		    (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			target_label = ssa->cfg.blocks[b].successors[0];
			| 	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ &&
                   (opline+1)->op1_type == IS_TMP_VAR &&
                   (opline+1)->op1.var == opline->result.var) {
			(*opnum)++;
			valid_opline_offset += 2;
		} else {
			|	SET_TYPE_INFO FP, opline->result.var, IS_FALSE
			valid_opline_offset++;
		}
	} else {
		goto fallback;
    }

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_free_compiled_variables(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
    uint32_t i, j, info;

	// Use type inference to avoid useless zval_ptr_dtor()
	for (i = 0 ; i < op_array->last_var; i++) {
		if (ssa->vars && ssa->var_info) {
			info = ssa->var_info[i].type;
			for (j = op_array->last_var; j < ssa->vars_count; j++) {
				if (ssa->vars[j].var == i) {
					info |= ssa->var_info[j].type;
				}
			}
		} else {
			info = MAY_BE_RC1 | MAY_BE_RCN | MAY_BE_REF | MAY_BE_ANY | MAY_BE_UNDEF;
		}

		if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
			uint32_t offset = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
			| ZVAL_PTR_DTOR FP, offset, info, 1, (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		}
	}
	return 1;
}

static int zend_jit_leave_func(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	// Avoid multiple leave sequnces
	if (jit_return_label >= 0) {
		| jmp =>jit_return_label
		return 1;
	}

	jit_return_label = ssa->cfg.blocks_count * 2;

	|=>jit_return_label:

	// i_free_compiled_variables(execute_data);
	if (!zend_jit_free_compiled_variables(Dst, opline, op_array, ssa)) {
		return 0;
	}

	|	movzx FCARG1d, byte [FP + offsetof(zend_execute_data, This.u1.type_info) + 2]
	|	test FCARG1d, (ZEND_CALL_TOP|ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_ALLOCATED)
	|	jne ->leave_function_handler
	|	// EG(current_execute_data) = EX(prev_execute_data);
	|	mov r0, EX->prev_execute_data
	|	mov aword [&EG(current_execute_data)], r0
	|	// if (call_info & ZEND_CALL_RELEASE_THIS)
	if (op_array->scope) {
		|	test FCARG1d, ZEND_CALL_RELEASE_THIS
		if (op_array->fn_flags & ZEND_ACC_STATIC) {
			|	jne >1
			|.cold_code
			|1:
		} else {
			|	je >2
		}
		|	// zend_object *object = Z_OBJ(execute_data->This);
		|	mov r0, EX->This.value.obj
		if (op_array->scope && op_array->scope->constructor == (zend_function*)op_array) {
			|	// if (UNEXPECTED(EG(exception) != NULL)
			|	cmp aword [&EG(exception)], 0
			|	jne >6
			|.cold_code
			|6:
			|	// if (call_info & ZEND_CALL_CTOR)
			|	test FCARG1d, ZEND_CALL_CTOR
			|	je >5
			|	// GC_REFCOUNT(object)--;
			|	dec dword [r0]
			|	// zend_object_store_ctor_failed(object);
			|.if X64
			|	mov CARG1, r0
			|	EXT_CALL zend_object_store_ctor_failed, r0
			|.else
			|	sub r4, 12
			|	push r0
			|	EXT_CALL zend_object_store_ctor_failed, r0
			|	add r4, 16
			|.endif
			|	// reload registers
			|	mov r0, EX->This.value.obj
			|	jmp >5
			|.code
			|5:
		}
		|	// OBJ_RELEASE(object);
		|	OBJ_RELEASE r0, 4
		|	jmp >4
		if (op_array->fn_flags & ZEND_ACC_STATIC) {
			|.code
		} else {
			|2:
		}
	}
	|	test FCARG1d, ZEND_CALL_CLOSURE
	|	jne >3
	|.cold_code
	|3:
	|	// OBJ_RELEASE((zend_object*)execute_data->func->op_array.prototype);
	|	mov r0, EX->func
	|	mov r0, aword [r0 + offsetof(zend_op_array, prototype)]
	|	OBJ_RELEASE r0, 4
	|	jmp >4
	|.code
	|4:
	|	// EG(vm_stack_top) = (zval*)execute_data;
	|	mov aword [&EG(vm_stack_top)], FP
	|	// execute_data = EX(prev_execute_data);
	|	mov FP, EX->prev_execute_data
	|	// if (EG(exception))
	|	cmp aword [&EG(exception)], 0
	|	mov IP, EX->opline
	|	jne ->leave_throw_handler
	|	// EX(opline)++
	|	add IP, sizeof(zend_op)
	|	mov EX->opline, IP
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_return(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (op_array->type == ZEND_EVAL_CODE || !op_array->function_name || !ssa->ops || !ssa->var_info) {
		// TODO: support for top-level code
		return zend_jit_tail_handler(Dst, opline);
	}

	op1_info = OP1_INFO();
	if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
		// TODO: support for IS_UNDEF ???
		return zend_jit_tail_handler(Dst, opline);
	}

	// if (!EX(return_value))
	|	mov r1, EX->return_value
	|	test r1, r1
	if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
	    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	jz >1
		|.cold_code
		|1:
		|	test byte [FP + opline->op1.var + 9], IS_TYPE_REFCOUNTED
		||	if (jit_return_label >= 0) {
		|		jz =>jit_return_label
		||	} else {
		|		jz >9
		||	}
		|	mov FCARG1a, aword [FP + opline->op1.var]
		|	dec dword [FCARG1a]
		||	if (jit_return_label >= 0) {
		|		jnz =>jit_return_label
		||	} else {
		|		jnz >9
		||	}
		|	//SAVE_OPLINE()
		|	mov EX->opline, IP
		|	ZVAL_DTOR_FUNC (op_array->filename ? ZSTR_VAL(op_array->filename) : NULL), opline->lineno
		|	mov r1, EX->return_value // reload ???
		||	if (jit_return_label >= 0) {
		|		jmp =>jit_return_label
		||	} else {
		|		jmp >9
		||	}
		|.code
	} else {
		||	if (jit_return_label >= 0) {
		|		jz =>jit_return_label
		||	} else {
		|		jz >9
		||	}
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);
		|	ZVAL_COPY_CONST r1, 0, -1, zv, r0
		if (Z_REFCOUNTED_P(zv)) {
		|	ADDREF_CONST zv, r0
		}
	} else if (opline->op1_type == IS_TMP_VAR) {
		|	ZVAL_COPY_VALUE r1, 0, FP, opline->op1.var, op1_info, r0, eax, r2
	} else if (opline->op1_type == IS_CV) {
		if (op1_info & MAY_BE_REF) {
			|	cmp byte [FP + opline->op1.var + 8], IS_REFERENCE
			|	jz >1
			|.cold_code
			|1:
			|	// retval_ptr = Z_REFVAL_P(retval_ptr);
			|	mov	r0, [FP + opline->op1.var]
			|	//	ZVAL_COPY(return_value, retval_ptr);
			|	mov edx, dword [r0 + 16]
			|	mov dword [r1 + 8], edx
			|	test dh, IS_TYPE_REFCOUNTED
			|	jnz >2
			|.if X64
			|	mov r2, aword [r0 + 8]
			|	mov aword [r1], r2
			|.else
			|	mov r2, aword [r0 + 8]
			|	mov aword [r1], r2
			|	mov r2, aword [r0 + 12]
			|	mov aword [r1 + 4], r2
			|.endif
			|	jmp >3
			|2:
			|.if X64
			|	mov r2, aword [r0 + 8]
			|	mov aword [r1], r2
			|.else
			|	mov r2, aword [r0 + 8]
			|	mov aword [r1], r2
			|.endif
			|	inc dword [r2]
			|	jmp >3
			|.code
		}
		|	ZVAL_COPY_VALUE r1, 0, FP, opline->op1.var, op1_info, r0, eax, r2
		|	// TODO: JIT: if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) ZVAL_NULL(retval_ptr); ???
		|	TRY_ADDREF op1_info, ah, r2
		|3:
	} else {
		if (op1_info & MAY_BE_REF) {
			|	cmp byte [FP + opline->op1.var + 8], IS_REFERENCE
			|	je >1
			|.cold_code
			|1:
			|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
			|	mov r0, aword [FP + opline->op1.var]
			|	// ZVAL_COPY_VALUE(return_value, &ref->value);
			|.if X64
			|	mov r2, aword [r0 + 8]
			|	mov aword [r1], r2
			|.else
			|	mov r2, aword [r0 + 8]
			|	mov aword [r1], r2
			|	mov r2, aword [r0 + 12]
			|	mov aword [r1 + 4], r2
			|.endif
			|	mov edx, dword [r0 + 16]
			|	mov dword [r1 + 8], edx
			|	dec dword [r0]
			|	je >2
			|	// if (IS_REFCOUNTED())
			|	test dh, IS_TYPE_REFCOUNTED
			||	if (jit_return_label >= 0) {
			|		je =>jit_return_label
			||	} else {
			|		je >9
			||	}
			|	// ADDREF
			|	mov r2,	aword [r1]
			|	inc dword [r2]
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|2:
			|	EFREE_SIZE r0, sizeof(zend_reference), op_array, opline
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|.code
		}
		|	ZVAL_COPY_VALUE r1, 0, FP, opline->op1.var, op1_info, r0, eax, r2
	}

	|9:
	//JIT: ZEND_VM_DISPATCH_TO_HELPER(zend_leave_helper);
	return zend_jit_leave_func(Dst, opline, op_array, ssa);
}

static int zend_jit_fetch_dim_read(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, res_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	res_info = RES_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea FCARG1a, [FP + opline->op1.var]
		|	cmp	byte [FCARG1a + 8], IS_REFERENCE
		|	jnz >1
		|	mov FCARG1a, aword [FCARG1a]
		|	add FCARG1a, 8
		|1:
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	cmp byte [FCARG1a + 8], IS_ARRAY
			|	jnz >7 // NOT_ARRAY
			|	mov FCARG1a, aword [FCARG1a]
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	// if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				|	cmp byte [FP + opline->op1.var + 8], IS_ARRAY
				|	jnz >7 // NOT_ARRAY
			}
			|	LONG_LOAD opline->op1_type, opline->op1, FCARG1a
		}
		if (op2_info & MAY_BE_LONG) {
			if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) {
				|	// if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) {
				|	cmp byte [FP + opline->op2.var + 8], IS_LONG
				|	jnz >3 // NOT_LONG
			}
			|	// hval = Z_LVAL_P(dim);
			|	LONG_LOAD opline->op2_type, opline->op2, FCARG2a

			if (opline->op2_type == IS_CONST) {
				zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));
				if (val >= 0 && val < HT_MAX_SIZE) {
					|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
					|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
					|	jz >1 // HASH_FIND
					|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed)) {
					|.if X64
					|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
					|	cmp r0, val
					|.else
					|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], val
					|.endif
					|	jle >2 // NOT_FOUND
					|	// _ret = &_ht->arData[_h].val;
					|	mov r0, aword [FCARG1a + offsetof(zend_array, arData)]
					|	add r0, val * sizeof(Bucket)
					|	cmp dword [r0 + 8], IS_UNDEF
					|	jne >8 // FOUND
					|	jmp >2 // NOT_FOUND
				}
			} else {
				|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
				|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
				|	jz >1 // HASH_FIND
				|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed)) {
				|.if X64
				|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
				|	cmp r0, FCARG2a
				|.else
				|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], FCARG2a
				|.endif
				|	jle >2 // NOT_FOUND
				|	// _ret = &_ht->arData[_h].val;
				|	imul FCARG2a, sizeof(Bucket)
				|	mov r0, aword [FCARG1a + offsetof(zend_array, arData)]
				|	add r0, FCARG2a
				|	cmp dword [r0 + 8], IS_UNDEF
				|	jne >8 // FOUND
				|	jmp >2 // NOT_FOUND
			}
			|1:
			|	EXT_CALL zend_hash_index_find, r0
			|	test r0, r0
			|	je >2 // NOT_FOUND
			|.cold_code
			|2:
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	// zend_error(E_NOTICE,"Undefined offset: " ZEND_LONG_FMT, hval);
				|.if X64
				|	mov CARG1, E_NOTICE
				|	LOAD_ADDR CARG2, "Undefined offset: " ZEND_LONG_FMT
				|	LONG_LOAD opline->op2_type, opline->op2, CARG3
				|	EXT_CALL zend_error, r0
				|.else
				|	sub r4, 4
				|	LONG_LOAD opline->op2_type, opline->op2, r0
				|	push r0
				|	push "Undefined offset: " ZEND_LONG_FMT
				|	push E_NOTICE
				|	EXT_CALL zend_error, r0
				|	add r4, 16
				|.endif
			}
			|	// retval = &EG(uninitialized_zval);
			|	mov dword [FP + opline->result.var + 8], IS_NULL
			|	jmp >9 // END
			|.code
			if (op2_info & (MAY_BE_ANY - MAY_BE_STRING)) {
				|	jmp >8 // FOUND
			}
			if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) {
				|3:
			}
		}
		if (op2_info & MAY_BE_STRING) {
			if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
				|	// if (EXPECTED(Z_TYPE_P(dim) == IS_STRING)) {
				|	cmp byte [FP + opline->op2.var + 8], IS_STRING
				|	jnz >3 // NOT_STRING
			}
			|	// offset_key = Z_STR_P(dim);
			|	LONG_LOAD opline->op2_type, opline->op2, FCARG2a
			|	// retval = zend_hash_find(ht, offset_key);
			if (opline->op2_type != IS_CONST) {
				|	EXT_CALL zend_jit_symtable_find, r0
			} else {
				|	EXT_CALL zend_hash_find, r0
			}
			|	test r0, r0
			|	je >2 // NOT_FOUND
			|	// if (UNEXPECTED(Z_TYPE_P(retval) == IS_INDIRECT)) {
			|	cmp dword [r0 + 8], IS_INDIRECT
			|	jz >1 // SLOW
			|.cold_code
			|1:
			|	//	retval = Z_INDIRECT_P(retval);
			|	mov r0, aword [r0]
			|	cmp dword [r0 + 8], IS_UNDEF
			|	jnz >8 // COPY
			|2:
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				//	zend_error(E_NOTICE, "Undefined index: %s", ZSTR_VAL(offset_key));
				|.if X64
				|	mov CARG1, E_NOTICE
				|	LOAD_ADDR CARG2, "Undefined index: %s"
				|	LONG_LOAD opline->op2_type, opline->op2, CARG3
				|	add CARG3, offsetof(zend_string, val)
				|	EXT_CALL zend_error, r0
				|.else
				|	sub r4, 4
				|	LONG_LOAD opline->op2_type, opline->op2, r0
				|	add r0, offsetof(zend_string, val)
				|	push r0
				|	push "Undefined index: %s"
				|	push E_NOTICE
				|	EXT_CALL zend_error, r0
				|	add r4, 16
				|.endif
			}
			|	mov dword [FP +opline->result.var + 8], IS_NULL
			|	jmp >9 // END
			|.code
			if (op2_info & (MAY_BE_ANY - (MAY_BE_LONG|MAY_BE_STRING))) {
				|	jmp >8 // FOUND
			}
		}
		if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
			if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
				|.cold_code
				|3:
			}
			|	SAVE_VALID_OPLINE
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
				|.code
			}
		}
	}

	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_ARRAY)) {
		if (op1_info & MAY_BE_ARRAY) {
			|.cold_code
			|7:
		}

		if (op1_info & MAY_BE_STRING) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING))) {
			    if (op1_info & MAY_BE_REF) {
					|	cmp byte [FCARG1a + 8], IS_STRING
				} else {
					|	cmp byte [FP + opline->op1.var + 8], IS_STRING
			    }
				|	jnz >6
			}
			|	SAVE_VALID_OPLINE
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_str_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_str_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			|6:
		}

		if (op1_info & MAY_BE_OBJECT) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_OBJECT))) {
			    if (op1_info & MAY_BE_REF) {
					|	cmp byte [FCARG1a + 8], IS_OBJECT
				} else {
					|	cmp byte [FP + opline->op1.var + 8], IS_OBJECT
			    }
				|	jnz >6
			}
			|	SAVE_VALID_OPLINE
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_obj_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_obj_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			|	jmp >9 // END
			|6:
		}

		if (opline->opcode != ZEND_FETCH_DIM_IS && (op1_info & MAY_BE_UNDEF)) {
		    if (op1_info & MAY_BE_REF) {
				|	cmp byte [FCARG1a + 8], IS_UNDEF
			} else {
				|	cmp byte [FP + opline->op1.var + 8], IS_UNDEF
		    }
			|	jnz >1
			|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
			|	mov FCARG1d, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		if (op2_info & MAY_BE_UNDEF) {
			|	cmp byte [FP + opline->op2.var + 8], IS_UNDEF
			|	jnz >1
			|	mov FCARG1d, opline->op2.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		|	mov dword [FP + opline->result.var + 8], IS_NULL
		|	jmp >9 // END
		if (op1_info & MAY_BE_ARRAY) {
			|.code
		}
	}

	|8:
	if (res_info & MAY_BE_REF) {
	|	// ZVAL_COPY_UNREF
	|	test byte [r0 + 9], IS_TYPE_REFCOUNTED
	|	jz >2
	|	mov r1, aword [r0]
	|	cmp byte [r0 + 8], IS_REFERENCE
	|	jnz >1
	|	cmp dword [r1], 1
	|	jnz >1
	|	lea FCARG1a, [FP + opline->result.var]
	|	mov FCARG2a, r0
	|	EXT_CALL zend_jit_zval_copy_unref_helper, r0
	|	jmp >9
	|1:
	|	inc dword [r1]
	|2:
	|	ZVAL_COPY_VALUE FP, opline->result.var, r0, 0, MAY_BE_ANY, r1, ecx, r2
	} else  {
	|	// ZVAL_COPY
	|	ZVAL_COPY_VALUE FP, opline->result.var, r0, 0, MAY_BE_ANY, r1, ecx, r2
	|	TRY_ADDREF res_info, ch, r2
	}
	|9: // END

	|	FREE_OP opline->op2_type, opline->op2, op2_info, op_array, opline->lineno
	|	FREE_OP opline->op1_type, opline->op1, op1_info, op_array, opline->lineno

	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}

	valid_opline_offset++;

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
